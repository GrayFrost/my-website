---
title: 网站搭建
description: 记录问题
---

# 个人网站搭建

## 自定义字体
https://github.com/vercel/next.js/discussions/16257

## SSR
window is not defined

```javascript
const WiredButtonComponent = dynamic(
  () =>
    import("react-wired-elements").then((res) => {
      return res.WiredButton;
    }),
  {
    ssr: false,
  }
);
```

## code

https://github.com/hashicorp/next-mdx-remote/issues/244

## notation
位置不对问题
可能被图片、字体加载等影响

https://github.com/rough-stuff/rough-notation/issues/51---
title: Svelte从入门到精通——安装与使用
description: 【入门篇】安装与使用
---

## 安装

工欲善其事，必先利其器。在安装 `Svelte`之前，笔者假定读者已完成了以下操作：

- 安装环境[Node.js](https://nodejs.org/en)

- 安装代码编辑器（推荐[VSCode](https://code.visualstudio.com/)）

- 掌握或了解Html、Css及JavaScript的使用

### Vite安装（推荐）

在我们安装好Node环境后，我们可以使用[Vite](https://vitejs.dev/)来安装。因为Vite的使用对Node.js有较高的版本要求，所以笔者建议读者安装比较新的Node.js。目前笔者使用的版本为`v18.15.0`。

![Node Version](/images/svelte/02-1.png)

如果存在不同的项目依赖不同版本的Node的情况，笔者推荐安装node版本管理工具，如[nvm](https://github.com/nvm-sh/nvm)。

  
准备就绪后，安装命令如下，我们分步骤执行：
```bash
npm create vite@latest my-svelte-project -- --template svelte
cd my-svelte-project
npm install
```

首先当我们在命令行工具中敲下 `npm create vite@latest my-svelte-project -- --template svelte`这一行时，稍等片刻，便会出现如下图：

![](/images/svelte/02-2.png)

接着便是按照图上所示，分别执行 `cd my-svelte-project`和 `npm install`。

`cd my-svelte-project`表示进入到我们刚才创建成功的目录my-svelte-project。
进入目录后，我们执行 `npm install`安装项目所需要的所有依赖项。

如果笔者比较擅长使用Typescript，那可以将 `--template svelte`替换为 `--template svelte-ts`。

  
如果我们执行的是下面这行（能看出和上面的有什么区别吗？）
```bash
npm create vite@latest my-svelte-app
```

没错，我们没有指定template，即没有指定使用哪个前端库的模板，那么我们会得到以下界面

![](/images/svelte/02-3.png)

因为我们是学习Svelte，那我们可以通过键盘的上下方向键，选中Svelte选项后回车；

在下一步，我们选择Javascript，同样，如果你掌握了Typescript，你也可选择Typescript。

![](/images/svelte/02-4.png)

回车后，同样能得到刚才的提示。

![](/images/svelte/02-5.png)

同样是cd到项目目录，然后执行安装依赖。
在 `npm install`依赖安装完成后，我们执行 `npm run dev`将我们的第一个Svelte项目运行起来。

在Github仓库[create-vite](https://github.com/vitejs/vite/tree/main/packages/create-vite)的代码中，我们能够发现我们下载的内容就是对应目录下的文件。

访问 `http://localhost:5173`，如果你能看到和我一样的页面，那么恭喜你，已经成功地踏出了第一步。

### 原始安装

这里说的原始安装，其实就是[官网](https://svelte.dev/)首页中出现的安装提示。

```bash
npm create svelte@latest my-app
cd my-app
npm install
npm run dev -- --open
```

敲下`npm create svelte@latest my-app`命令后，首先会要求我们安装`create-svelte`
![](/images/svelte/02-6.png)

可以看到，官方提供的模板和SvelteKit有关。

[SvelteKit](https://kit.svelte.dev/)是使用 Svelte 来构建 Web 应用的框架。

`Svelte`与`SvelteKit`之间的关系，相当于`React`与`Next.js`，或者`Vue`与 `Nuxt.js`。前者是UI框架，而后者则是基于前者来编写的Web框架。因此官网推荐的安装即是通过SvelteKit来安装。

我们随便选择其中一个模板后，回车确认。

![](/images/svelte/02-7.png)

后面会继续提供一些选项，按照自己的喜好选择完后，我们可以看到如下界面：

![](/images/svelte/02-8.png)


### 自定义安装
假如我们不想使用Vite或者SvelteKit，亦或者我们没有条件使用这两者，那就需要我们自己集成Svelte的环境。在日常开发时，我们通常会使用[webpack](https://webpack.js.org/)或者[Rollup](https://rollupjs.org/)作为我们项目的模块管理打包工具。因此笔者会分别介绍这两种环境下，如何搭建Svelte的运行环境。

这里笔者假设读者朋友们，在创建了webpack demo项目或者rollup demo项目后，在目录下都能有以下文件：
![](/images/svelte/02-9.png)

App.svelte内内容随意，符合Svelte文件格式即可；

index.js的文件内容如下：
```javascript
import App from './App.svelte';

new App({
  target: document.querySelector('#root')
});
```

index.html的内容如下：
```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
</head>

<body>
  <div id="root"></div>
  <script src="./dist/index.js"></script>
  </body>
</html>
```
#### webpack

在webpack中使用Svelte，除了必不可少的svelte，另外一个关键则是安装[svelte-loader](https://github.com/sveltejs/svelte-loader)

```bash
mkdir webpack-demo
cd webpack-demo

npm init -y
npm install webpack webpack-cli -D
npm install babel-loader @babel/core -D
npm install svelte svelte-loader
```

安装完依赖后，修改webpack配置`webpack.config.js`：
```javascript
const path = require("path");

module.exports = {
  entry: "./src/index.js",
  output: {
    filename: "index.js",
    path: path.resolve(__dirname, "dist"),
  },
  resolve: {
    extensions: [".js", ".svelte"],
    conditionNames: ["svelte"],
  },
  module: {
    rules: [
      {
        test: /\.(js|ts)$/,
        use: [{ loader: "babel-loader" }],
      },
      {
        test: /\.(svelte)$/,
        use: [
          "babel-loader",
          {
            loader: "svelte-loader",
          },
        ],
      },
    ],
  },
};
```

如果在package.json中的scripts里约定了build命令，试着`npm run build`一下；亦或者直接在命令行中执行`webpack`命令，可以看到有个打包目录dist，index.html里引用的则是dist目录下的index.js文件。直接用浏览器打开index.html，便能看到定义在App.svelte里的内容。至于如何用`npm run dev`跑起来，以及支持热更新等操作，就留给读者朋友们自行探索了。

#### Rollup

在Rollup中的关键则是[rollup-plugin-svelte](https://github.com/sveltejs/rollup-plugin-svelte)

```javascript
import svelte from 'rollup-plugin-svelte';
import resolve from '@rollup/plugin-node-resolve';

export default {
  input: './src/index.js',
  output: {
    file: 'dist/index.js',
    format: 'umd'
  },
  plugins: [
    svelte(),
    resolve({
      browser: true,
      exportConditions: ['svelte'],
      extensions: ['.svelte']
    })
  ],
};
```
  
## 使用

经过上述一系列的安装教学，相信读者朋友们早就发现了如何在项目中使用Svelte。
首先在index.html文件内，提供一个可以挂载的节点，通常如下（读者可自行定义）：
```html
<div id="root"></div>
```

在入口文件index.js或main.js中，如下定义：
```javascript
import App from './App.svelte';

new App({
  target: document.querySelector('#root')
})
```

App.svelte则是我们初始的svelte文件，我们把App.svelte里写好的内容挂载到定义好的root节点上。

Svelte的文件以 `.svelte`作为文件后缀名，在文件内，与vue的template语法相似。

```html
<script>
//代码文件
</script>

<style>
/* 样式文件*/
</style>

<!-- 此处一般放置元素标签（多个或者为空） -->
```
文件内的script，style和html内容三个部分均为可选的，顺序也没有要求。

### VsCode Extension

我们用Vscode把安装好的项目打开，然后添加Svelte扩展。插件在我们编写svelte文件时，为我们提供语法高亮和智能检测。
![](/images/svelte/02-10.png)

### REPL

REPL（Read-Eval-Print Loop），是一个简单的交互式的编程环境。如果读者朋友们只是想简单学习下Svelte的语法，又觉得搭建一个Svelte环境项目太麻烦，那Svelte官网为开发者和学习者们提供了[REPL](https://svelte.dev/repl/hello-world?version=4.2.11)环境，在上面我们可以快速编写试验Svelte的各种api语法。

![repl](/images/svelte/02-11.png)

快速上手试试吧！

## 小结

本章我们学习了：
- 使用Vite安装Svelte
- 使用SvelteKit安装Svelte
- 在webpack项目中运行Svelte
- 在Rollup项目中运行Svelte
- Svelte单文件的内容格式
- 使用Svelte时会用到的辅助工具：VsCode插件、REPL运行环境等。
---
title: Svelte从入门到精通——数据与方法
description: 【入门篇】数据与方法
---

## 数据绑定

数据是页面展示中最重要的一环。

在React中，我们通过 `this.state`来对变量进行声明存储，亦或是通过 `useState`来操作；在Vue中，我们可以把数据放到 `data()`方法的返回值里，亦或者使用 `ref`、`reactive`来声明变量；而在Svelte中，我们则直接在script标签中正常声明，然后再在html标签里使用 `{}`来包裹变量。

### 直接声明

```html
<script>
  let count = 0;
</script>

<div>count: {count}</div>
```

### 属性里使用

除了在标签内容里显示，我们可以在标签属性里进行操作变量，比如我们常需要判断动态的样式class。

```html
<script>
  let tab = 'hello'
</script>

<span class={tab === 'hello' ? 'active' : ''}>color text</span>

<style>
.active {
  color: blue;
}
</style>
```

在Svelte中，active的class还有缩写，我们在介绍样式的章节会继续说明。

## 数据更新

我们在上面只演示了如何声明和使用变量，但变量最为关键的特性便是——“变”，我们要如何更新声明的变量呢？

其实也是很简单，就像普通的操作一样。
```html
<script>
  let count = 0;

  const updateCount = () => {
    if (count >= 5) {
      return;
    }
    count++;
    setTimeout(() => {
      updateCount();
    }, 1000);
  };

  updateCount();
</script>

<span>count: {count}</span>
```

在上述代码中，笔者声明了一个定时更新的方法，如果你执行上述代码，便能看到count在页面中按秒更新。从上述代码的写法中我们可以看到，声明和使用方法的方式和我们正常写原生js没有差别。


### 数组、对象的更新

如果你使用过Vue，那你一定知道在Vue中，对于数组的更新需要一些Hack操作。那在Svelte中呢？
这里笔者举个例子：
```html
<script>
  let arr = [1];

  const updateArray = () => {
    arr.push(1);
    console.log(arr);
  };
</script>

<button on:click={updateArray}>update array</button>
<p>数组：{arr.join(",")}</p>
```
在这个例子中，如果我们点击按钮，会发现数组的内容在页面展示上完全没有更新，然而控制台里却能正常的打印出push后的数组内容。

是的，在Svelte中，数组的更新同样需要一些技巧。

> Because Svelte's reactivity is triggered by assignments, using array methods like `push` and `splice` won't automatically cause updates.

这是[官网](https://learn.svelte.dev/tutorial/updating-arrays-and-objects)里的一句话：Svelte的反应性是由赋值语句触发的。这句话已经点出了关键问题：“赋值语句”。因此我们可以如下修改：

```diff
const updateArray = () => {
  arr.push(1);
  console.log(arr);
+ arr = arr;
}
```
亦或者改成：
```javascript
const updateArray = () => {
  arr = [...arr, 1]
}
```

对于其他一些数组的操作方法，我们可以按此思路来替换：
```javascript
const pushNumber = () => {
  arr = [...arr, lastNumber];
}
const popNumber = () => {
  arr = [...arr.slice(0, arr.length - 1)]
}
const unshiftNumber = () => {
  arr = [firstNumber, ...arr];
}
const shiftNumber = () => {
  arr = [...arr.slice(1, arr.length)]
}
```

对象在更新时也有一点需要注意，举个例子：
```html
<script>
  let obj = {
    foo: {
      bar: "hello",
    },
  };
  let bar = obj.foo.bar;
  bar = "world";
</script>

<p>对象：{obj.foo.bar}</p>
```

在页面上，我们看到的仍是hello，要想更新，需要如下写法：
```html
<script>
  let obj = {
    foo: {
      bar: "hello",
    },
  };
  obj.foo.bar = "world";
  // let bar = obj.foo.bar;
  // bar = 'world'
</script>

<p>对象：{obj.foo.bar}</p>
```

官网也细心地给了我们提示：**被更新的变量的名称必须出现在赋值语句的左侧**

### 事件绑定

每个框架都有自己独特的事件监听的写法，在Svelte中，按照以下格式进行事件监听的绑定。

```javascript
on:eventname|modifiers={handler}
```

`eventname`是事件名，比如我们常用的 `click`、`mousemove`、`keydown`等等。

`modifiers`修饰符，这是一个可选项，有以下选项：
* `preventDefault` ：在程序运行之前调用 `event.preventDefault()`
* `stopPropagation` ：调用 `event.stopPropagation()`, 防止事件到达下一个标签
* `passive` ：改善了touch/wheel事件的滚动表现
* `capture`：表示在 capture阶段而不是bubbling触发其程序
* `once`：表示事件只执行一次

比如我们写一个最常见的事件绑定，把数据声明和事件监听绑定起来：

```html
<script>
  let count = 0;
  const updateCount = () => {
    count++;
  };
</script>

<div>
  count: {count}
  <button on:click={updateCount}>+1</button>
</div>
```

在上述例子中，我们暂时没有用到事件修饰符。笔者再举个例子：
```html
<script>
  let count = 0;
  const sayHello = () => {
    console.log("hello");
  };

  const updateCount = () => {
    count++;
  };
</script>

<div on:click={sayHello}>
  count: {count}
  <button on:click={updateCount}>+1</button>
</div>
```

此时如果我们点击button，那在控制台便会看到hello字符串也在打印出来。
想要阻止事件冒泡，一种方式是在监听的方法里设置 `stopPropagation`。
```javascript
const updateCount = (event) => {
  event.stopPropagation();
  count++;
}
```

另一种方式就是使用刚才我们介绍的修饰符，这样我们就不用在我们的业务代码里处理冒泡逻辑。

```html
<button on:click|stopPropagation={updateCount}>+1</button>
```

事件修饰符支持链式调用：
```javascript
on:eventname|modifier1|modifier2|modifier3={handler}
```

有时我们在事件绑定中需要拿到event对象，而拿event对象的写法也分情况，一种是事件没有接受其他参数：
```html
<script>
  const handleClick = (event) => {
    console.log(event);
  };
</script>

<button on:click={handleClick}>btn</button>
```

而另一种情况是，我们除了拿event对象，还需要让方法接收其他参数：
```html
<script>
  const handleClick = (event, param) => {
    console.log(event, param);
  };
</script>

<button on:click={(e) => handleClick(e, "hello")}>btn</button>
```

这种内联的事件绑定还能按如下写，主要区别是在某些编辑器下的高亮显示支持：
```html
<button on:click="{e => handleClick(e, 'hello')}">btn</button>
```

## 双向绑定

目前常见的软件开发架构模式有MVC、MVP、MVVM。
其中MVC（Model-View-Controller）分为三部分：
- 模型（Model）：负责管理应用程序的数据
- 视图（View）：主要对应应用程序中的用户交互页面
- 控制器（Controller）：接收从用户界面传递进来的数据，调用相应的控制器来更新数据。数据更新后，会触发页面的更新。

![](/images/svelte/03-1.png)

而另一种架构模式MVVM，同样分为三部分：
- 模型（Model）
- 视图（View）
- 视图模型（ViewModel）：负责暴露模型的数据和命令，以便视图可以使用它们。

![](/images/svelte/03-2.png)

双向绑定是数据变化驱动视图更新，视图更新触发数据变化。Vue和Svelte都支持双向数据绑定。在Vue中，我们通过 `v-model`实现双向数据绑定，聪明的你可能会想，既然Svelte操作数据这么方便，那我直接写下这一段代码，那Svelte便能帮我们处理双向绑定了。

```html
<script>
  let str = ''
</script>

<div>
  <input type="text" value={str} />
  <span>input value: {str}</span>
</div>
```

很遗憾，上述代码并没有帮我们处理双向绑定，如果我们想要做双向绑定，需要按下列写法：
```html
<script>
  let str = ''
</script>

<div>
  <input type="text" bind:value={str} />
  <span>input value: {str}</span>
</div>
```

注意到区别了吗？没错，我们需要使用到 `bind`。bind除了做双向绑定外，还有其他用处，后面的章节我们会继续使用到这个指令。

#### 表单组件的双向绑定

```html
<script>
  let value = '';
</script>

<input type="text" value={value} />
<p>value: {value}</p>
```

如果我们按照vue的逻辑直接写出上述代码，会发现当我们在输入框内填写内容时，页面上并没有跟随输出。

```html
<script>
  let value = '';
</script>

<input type="text" value={value} on:input="{e => value = e.target.value}" />
<p>value: {value}</span>
```

要实现双向的数据绑定，需要用到bind指令
##### `input[type="text"]`
```html
<script>
  let value = '';
</script>

<input bind:value={value} />
<p>value: {value}</p>
```

##### `input[type="number"]`
```html
<script>
  let value = 1;
</script>

<input type="number" bind:value={value} />
<input type="range" bind:value={value} min={1} max={5} />
```

##### `input[type="checkbox"]`
```html
<script>
  let checked = false;
</script>

<label>
  <input type="checkbox" bind:checked={checked} />
  select: {checked}
</label>
```

##### `input[type="radio"]`
```html
<script>
  let radioValue = "";
</script>

<label>
  <input type="radio" bind:group={radioValue} value={1} />
  1
</label>

<label>
  <input type="radio" bind:group={radioValue} value={2} />
  2
</label>

<label>
  <input type="radio" bind:group={radioValue} value={3} />
  3
</label>

<p>选择的是：{radioValue}</p>
```

##### `bind:group`
```html
<script>
  let checkboxValue = [];
</script>

<label>
  <input type="checkbox" bind:group={checkboxValue} value={1} />
  1
</label>

<label>
  <input type="checkbox" bind:group={checkboxValue} value={2} />
  2
</label>

<label>
  <input type="checkbox" bind:group={checkboxValue} value={3} />
  3
</label>

<p>选择的是：{checkboxValue.join(',')}</p>
```

##### `select`
```html
<script>
  let selectValue;
</script>

<select bind:value={selectValue}>
	<option value={1}>1</option>
	<option value={2}>2</option>
	<option value={3}>3</option>
</select>

<p>选择的是：{selectValue}</p>
```

除了以上列举的组件能够实现双向绑定外，Svelte还支持了许多元素的双向绑定，如textarea，媒体标签video、audio等等，读者们可深入探索。

#### 自定义组件的双向绑定
```html
<script>
  export let value;
</script>

<input bind:value={value} />
```
在这里我们遇到了一个新的关键字`export`，我们会在下一章讲解。

```html
<script>
  import Child from './Child.svelte';
  let fatherValue = ''
</script>

<Child bind:value={fatherValue} />
<input bind:value={fatherValue} />
```

## 小结
本章我们学习了：
- 在Svelte中声明数据和更新数据
- Svelte中数组、对象更新时的小技巧
- 在Svelte中如何使用事件监听，以及在监听事件中修饰符的使用
- 在Svelte中使用`bind`实现表单类型组件的双向数据绑定
---
title: Svelte从入门到精通——背景
description: 【入门篇】背景
---

## 是什么

对于国内前端开发者来说，前端框架首选无疑是React和Vue、退而其次是Angular。从本章开始，笔者将和大家一起了解一个不同于React和Vue等以虚拟DOM为核心的框架，它在国外的关注程度一度超过了前端框架的龙头React，这个框架就是——[Svelte](https://github.com/sveltejs/svelte)。
![logo](/images/svelte/01-13.png)

Svelte在英文中具有“苗条的，身材修长的”意思，对于刚接触的开发者来说，非常容易与Java的Servlet搞混。Servlet是运行在Web服务器中的小型Java程序，其是JavaWeb的三大组件之一，而Svelte则是一个前端UI框架，更准确地说，Svelte是一个编译器。

### 作者

正如我们提到React会想到[Dan Abramov](https://github.com/gaearon)，提到Vue会想到[Evan You](https://github.com/yyx990803)，那Svelte的创建者[Rich Harris](https://github.com/Rich-Harris)，在前端业界也享誉盛名。也许有些开发者不了解Rich Harris是何人，那和webpack齐名的打包工具Rollup便是出自此人之手。除了Rollup之外，Rich Harris还开发了Reactive、Svelte等诸多流行的开源作品，积极地投身于开源当中。
Svelte是Rich Harris在[《卫报》](https://www.theguardian.com/international)工作时的成果。Rich Harris曾担任《卫报》美国版的互动编辑。在加入卫报英国互动团队担任前端开发人员之前，他曾在 Citywire 担任财经记者、视频记者和网络制作人。

![Rich Harris](/images/svelte/01-5.jpeg)

### 历史

Svelte的前身是发布于2013年的[Ractive.js](https://github.com/ractivejs/ractive)，后者几乎与React同时问世。Reactive.js的灵感来自于 Knockout 和 Angular 以及当时其他一些东西的混搭。经过几年的实践，Rich Harris觉得Reactive.js并不是真正适合移动互联网时代的框架，于是在BrooklynJS聚会上和友人提出了自己的框架新想法——写一个编译器。

Svelte的第一个版本，基本上就是多了一个编译器的Reactive。因为当时《卫报》的同事在使用Reactive，且拥有一个现成的Reactive社区，为了能够更好地推广Svelte，Svelte第一版继承了Reactive的许多相同设计，让使用过Reactive的开发者能够快速上手Svelte。Svelte 这个名字是由Rich Harris和他在《卫报》的同事们选择的。随着时间的推移，越来越多的开发者开始了解Svelte,并对其产生了兴趣。

之后，Svelte开发团队意识到 Ractive 的一些设计决策是错误的，因此 Svelte 2 实际上只有一些小小的改进。例如，在模板语法中不再使用双花括号，而是使用单花括号，因此这更像是 JSX，并且还进行了一些其他类似的修饰性更改。但除此之外，它与 Svelte 1 几乎相同。

第三版是一次重大修改，Svelte开发团队开始[重新思考](https://svelte.dev/blog/svelte-3-rethinking-reactivity)现代 UI 框架的核心概念：反应性。到2019年，Svelte已经成为一个成熟的工具，可以构建具有[TypeScript](https://www.typescriptlang.org/)支持的开箱即用的Web应用程序。

经过4年的时间，Svelte4在2023年成功发布。Svelte4作为一个过渡版本，可以比作是React16 到18之间React 17版本，为下一代 Svelte（即 Svelte 5）的发布奠定了基础。

## 怎么样

凡是都有双面性，当我们要学习一个新事物时，需要斟酌思考这件事物值不值得我们学习，了解其在当前的优劣两面，是一个很好的切入点，针对框架亦是如此。

### 优势

#### 性能

通过[benchmark](https://github.com/krausest/js-framework-benchmark)上的性能对比，我们可以看到Svelte除了稍逊于Solid外，整体的表现优于React、Vue和Angular等前端框架。
![benchamark](/images/svelte/01-7.png)

再看一下Jacek Schae在2020年对各框架的RealWorld的Lighthouse跑分。
![RealWorld](/images/svelte/01-8.png)

Rich Harris 的[virtual-dom-is-pure-overhead](https://svelte.dev/blog/virtual-dom-is-pure-overhead)一文中，指出虚拟DOM并非免费的午餐，它也会带来性能和内存上的消耗。对于一个React组件来说，要把 `props`的值进行修改，需要分为三步：
1. 记录下前后两次虚拟DOM的快照，对相同的节点进行比较
2. 把该节点上所有的属性进行新旧对比，记录下变动的内容
3. 更新真实DOM

Svelte则是省去前面两步，直接更新DOM。Svelte是一个编译器，**不使用虚拟DOM**。Svelte.js 在构建时编译组件，从而产生高度优化的轻量级 JavaScript 代码。与其他在运行时依赖虚拟 DOM的框架不同，Svelte.js 完全消除了对虚拟 DOM 的需求，从而实现更快的加载时间、更流畅的动画并提高 Web 应用程序的整体性能。这是Svelte相对于其他任何Web框架的一个非常重要的优势。

#### 体积

同样是Jacek Schae的框架体积分析。Svelte在这块内容中遥遥领先。
![size](/images/svelte/01-9.png)

对于由使用框架后生成的代码行数中，Svelte同样拥有不俗的表现。虽然使用Svelte来编写的业务代码在编译后会产生较多的代码，但得益于较少的运行时代码，对于一般的中小型项目来说，整体的代码体积仍是比较小的。
![](/images/svelte/01-10.png)

在[npmtrends](https://npmtrends.com/react-vs-react-dom-vs-svelte-vs-vue)中显示的size，2.7KB同样遥遥领先。
![](/images/svelte/01-14.png)

与React、Vue、Angular等框架不同，Svelte不需要在代码运行时引入运行时代码。整个框架在构建过程中被编译掉，留下优化的 JavaScript 代码，直接与浏览器的本机 API 交互。这也是Svelte拥有更小的包体积、消耗更少内存而拥有更好性能的原因之一。

在代码体积的优势宣传中，Evan You曾提出一种质疑，为此还专门写了一个项目来[对比Svelte和Vue](https://github.com/yyx990803/vue-svelte-size-analysis)。
![](/images/svelte/01-11.png)

从文章中的结果我们可以得出以下结论：
* 编译后的 Svelte 组件代码比 Vue 3 等效代码重**70%**，在 SSR 模式下重**110%**
* 对于应用程序来说，当编写的组件超过19个组件这个阈值（SSR模式为13个组件）时，Svelte的优势与Vue3相比逐渐下降。

因此我们可以得出一个观点，虽说svelte项目的代码较小。但对于大型项目而言，随着业务的推进，业务复杂程度逐渐提升，项目文件大小逐渐增多，编译后的代码量陡增，使用Svelte的大型项目体积并不会比React、Vue等小，因此我们需要辩证看待体积优势问题。

#### 心智负担

Svelte语法简单，上手容易，学习曲线小。任何学过html，css和javascript的开发者都能上手。Svelte允许使用者使用足够少的代码来完成功能运行，比如一段最简单的代码：
```html
<script>
  let count = 0;
</script>

<button on:click={() => count++}>add</button>
```

Svelte帮助开发者以最小的代价构建用户界面，通过实现更好的反应性、绑定和顶层元素等，提高了代码的可读性，降低了开发者的心智负担和上手难度。

#### 关注度
Svelte的以上特性让其在国外前端圈大放异彩。

首先是在Github上，达到了75k以上的Star。
![](/images/svelte/01-3.png)

在[risingstars](https://risingstars.js.org/2023/en#section-framework)的2023年报告上。可以看到Svelte在Github上星数上涨在前端框架中排名第三。
![risingstars](/images/svelte/01-6.png)
  
在[stateofjs](https://2022.stateofjs.com/zh-Hans/libraries/front-end-frameworks/)的2022年度报告中（笔者在写文章时2023年报告结果暂时未出），Svelte的关注度和满意度都名列前茅。

![关注度](/images/svelte/01-1.png)

![满意度](/images/svelte/01-2.png)

### 劣势

#### 生态
在2016年才发布的Svelte，生态明显还达不到React和Vue的丰富程度。

#### 代码冗余
编译后的代码逻辑冗余。也许有读者会担心，如果业务逻辑复杂，导致编译之后的代码文件大小直线上升，是否会在一定程度上导致性能下降？Github上有相关开发人员对于这个问题进行了分析[svelte-it-will-scale](https://github.com/halfnelson/svelte-it-will-scale)：

![](/images/svelte/01-12.png)

文章中指出，拐点约为 120KB 的组件源代码。即是说，在大约 120KB 时，使用编译器相对于运行时的大小优势已经消失了。但实际上，只要合理地使用代码分割，单文件出现120KB的情况是不太可能的。

#### 抽象能力
因为Svelte不使用虚拟DOM，自然享受不到虚拟DOM带来的诸多好处，比如基于虚拟DOM来抽象各端渲染能力，基于vdom来完成测试等功能。

#### 推广

看一下三大框架在过去一年的[下载量](https://npmtrends.com/react-vs-svelte-vs-vue)。
![](/images/svelte/01-4.png)

虽然Svelte在国外已经风靡数时，但其下载量目前仍然无法和Vue相比，对比第一梯队的React，更是难以望其项背。同样在国内的推广程度仍不够高。

## 为什么

为什么我要学习Svelte？这里笔者简单的给出几点理由：

* 技术创新。当今的前端框架中，虚拟DOM的实现方式大行其道。不同于虚拟DOM的实现方式，Svelte以静态编译的方式实现了前端框架的响应性，这不仅开拓了我们的技术视野，也提升我们在开发中除了要拥抱潮流外，同样需要思考与创新。
* 性能。在中小型业务中的性能表现优秀。
* 学习曲线。上手简单，心智负担低。
* 国际化。Svelte在国外能够有如此高的呼声，自然有自身的吸睛点。我们不能固步自封，把自己的技术栈局限于React和Vue，学习Svelte能够让我们加入到前端新浪潮中，与国际前端圈接轨，减少彼此之间的信息差。同时，因为Svelte起步晚，有些生态库不够全面，如果读者你恰好是开源开好者，稍显贫瘠的生态土壤正是你大显身手的好时机。

## 小结

本章我们学习了：
- Svelte是一个新兴的前端框架，它与React、Vue等以虚拟DOM为核心的框架不同，Svelte在静态编译阶段就分析出变量之间的相互作用，核心是一个编译器。
- Svelte的作者是Rollup的开发者Rich Harris。
- Svelte有体积小、上手简单等优势，同时生态不够丰富也是它的劣势之一。
---
title: Svelte从入门到精通——组件与属性
description: 【入门篇】组件与属性
---

## 组件式开发

在项目开发中，我们通常推崇组件式的开发。所谓组件式，即抽离一些通用的逻辑到一个文件中组装成一个组件，当页面有用到该功能时，直接调用组件即可。那组件除了内部维持自身的逻辑之外，还需要通过接受外部传进来的数据，来实现组件的动态性和灵活性。

## 传值

举个最简单的todolist的例子，我们可以把列表展示封装成一个组件，组件的内部逻辑便是把列表数据展示出来，而对外则接收列表数据。页面引用了这个组件后，可以通过传递的是todo list还是done list来展示不同的数据。那传值在这里便是关键的一环。

当我们从父页面向子页面/组件传值时，通常传递的无非就是父页面的状态，亦或者是父页面的方法，那这两者在Svelte中该如何传递呢？

### 传递数据

在上一章的结尾处，我们遇到了如下代码：
```javascript
<script>
  export let value;
</script>
```

我们在页面中正常声明变量是`let value;`，当我们在前边添加`export`关键字时，便相当于把变量声明标记为是一个对外导出的属性，即*prop*，在外部引用该文件后，则可以通过属性赋值的形式来进行传值。
```html
<!-- Father .svelte -->
<script>
  import Child from './Child.svelte';
  let value = ''
</script>

<Child value={value} />
```

#### 默认值
当我们在组件内对外导出的形式是`export let value;`时，
```html
<script>
  export let value;
</script>

<div>child: {value || ''}</div>
```

而引用这个组件时却没有传值，
![](/images/svelte/04-12.png)
![](/images/svelte/04-1.png)

不止在VsCode中会提示我们需要传值，在Chrome控制台也会给出相应警告。

在我们开发时，往往会为某些传参提供一个默认值，因为有些组件在大部分情况下使用的是一个固定的状态，在遇到特殊情况时才会更改状态。比如在UI组件库中，类似Alert组件，有success，info，warning，error四种状态，我们在使用时大部分情况的提示都是正常的消息提示，也就是info状态，因此在组件内部便可以设置一个默认的info状态。

在为prop设置了默认值后，便可以消除我们上述演示中的告警。
在Svelte中，为prop设置默认值，只需在初始声明时进行赋值即可。
```html
<script>
  export let value = 'hello svelte';
</script>
```

#### 关键字
在JavaScript中，有一些特殊的词汇被称为关键字，它们用于编程语言的语法结构中，具有特定的含义。这些词汇不能被用作变量使用。

在Svelte中，我们在设置prop时，可以把一些关键字设置成prop。

举个非常普遍的例子，我们定义一个组件，在组件内有自己的class样式，然而我们需要组件支持在外部由用户自定义class样式属性，用户能够像`<Component class={} />`这种形式操作，而`class`在js中是用于定义一个类的关键字。因此，我们可以按如下写法：

```html
<script> 
  let className;
  export { className as class };
</script>
```
  
#### const

这里笔者有一个设想：export声明的变量能是一个方法吗？

```html
<!-- Child.svelte -->
<script>
  export let onChange = () => {return;}
</script>

<button on:click={onChange}>change</button>
```

```html
<script>
  import Child from './Child.svelte';
  let count = 0;
  const onChange = () => {
    count = Math.random();
  }
</script>

<Child onChange={onChange} />
<span>{count}</span>
```

答案是可以。
![](/images/svelte/04-2.gif)

然而需要注意的是，当我们导出的是`function`方法、`class`类和`const`常量时，导出的prop是不可变的。

仍旧以上面的导出方法作为例子，将Child.svelte的内容改成如下：
```html
<script>
  export function onChange() {
    console.log('no change');
  }
</script>

<button on:click={onChange}>change</button>
```

![](/images/svelte/04-3.gif)

因此我们要设置一个变量或方法为prop，尽量使用let或var声明。

## 方法调用

### createEventDispatcher

我们在上一章中了解到，为html标签进行事件绑定，使用的是`on:[eventName]`的形式。同样，我们如果想为一个组件进行事件绑定，也是使用这种形式。
```html
<Component on:[eventName]={eventHandler} />
```
在组件中进行事件绑定时，`eventName`需要在组件内部进行实现。

内部实现如下：
```javascript
import { createEventDispatcher } from 'svelte';

const dispatch = createEventDispatcher();

dispatch(eventName, data)
```
dispatch的第一个参数是事件名，第二个参数是则用来对外传递数据，如果有多个参数需要传递，把第二个参数设置成一个对象，在这个对象里存放多个对外传递的数据。

这里举个例子演示：
```html
<script>
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  const onClick = (e) => {
    dispatch("click", e);
  }
</script>

<button on:click={onClick}>按钮</button>
```


```html
<script>
  import Component from './Component.svelte';

  const onClick = (e) => {
    console.log('component click', e);
  }
</script>

<Component on:click={onClick} />
```

当我们点击时，能够看到控制台输出了一个`CustomEvent`类型的数据：
![](/images/svelte/04-4.png)
正常我们都会以为在页面中打印出的event参数，就是我们在子组件中我们进行传递的e。
然而笔者在这里需要让大家注意，在Svelte中使用`createEventDispatcher`进行数据传递时，数据都被放在了`event.detail`中。仔细观察上述图片，会发现打印出的数据里有个detail的key。里面存放的才是从子组件传递过来的数据。

也许上述例子不够直观，我们修改一下我们的子组件内的传值：
```html
<script>
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  const onClick = (e) => {
    dispatch("click", 123);
  }

</script>

<button on:click={onClick}>按钮</button>
```

![](/images/svelte/04-5.png)

需要注意的是，`createEventDispatcher`必须在组件初始化的时候就创建，即在顶层script作用域中，否则会报错。
```javascript
<script>
  import { createEventDispatcher } from 'svelte';

  const onClick = (e) => {
    const dispatch = createEventDispatcher();
    dispatch("click", 123);
  }

</script>

<button on:click={onClick}>按钮</button>
```

![](/images/svelte/04-6.png)


我们可以简单看下`createEventDispatcher`的实现：
```javascript
export function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(/** @type {string} */ (type), detail, {
        cancelable,
      });
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}

export function custom_event(
  type,
  detail,
  { bubbles = false, cancelable = false } = {}
) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
```
其实就是new了一个[CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)的实例，然后把第二个传参的数据都放到detail里进行传值。

### 事件转发

与DOM事件不同，组件事件不会冒泡。
```html
<script>
  // GrandSon.svelte
  import { createEventDispatcher, onMount } from 'svelte';

  const dispatch = createEventDispatcher();

  const func = () => {
    dispatch('func', 'hello');
  }

  onMount(() => {
    func();
  })
</script>

<div>孙组件</div>
```

```html
<script>
  // Child.svelte
  import { createEventDispatcher } from 'svelte';
  import GrandSon from './GrandSon.svelte';

  const dispatch = createEventDispatcher();

  const func = (e) => {
    dispatch('func', e.detail);
  }

</script>

<GrandSon on:func={func}/>
```

```html
<script>
  // Father.svelte
  import Child from './Child.svelte';

  const func = (e) => {
    console.log('孙子传值：', e.detail);
  }
</script>

<Child on:func={func} />
```

![](/images/svelte/04-7.png)
笔者这里使用这个例子主要是想说明，当某个内层组件想要对最外层派发事件时，每一层经过的组件都要使用`createEventDispatch()`然后再传递`event.detail`的步骤。
当在一些涉及到点击等交互的组件中，这种现象是常见的。我们可能会为某个组件添加点击事件的支持，但是点击事件的逻辑则交由外部用户来定义。为此，我们需要用到事件转发。
事件转发写法如下：
```html
on:eventName
```
只写事件名，组件本身不提供事件实现。事件的实现交由外层想实现的页面实现。

```html
<!-- GrandSon.svelte -->
<button on:click>孙组件</button>
```

```html
<script>
  // Child.svelte
  import GrandSon from './GrandSon.svelte';
</script>

<GrandSon on:click />
```

```html
<script>
  // Father.svelte
  import Child from './Child.svelte';

  const onClick = () => {
    console.log('点击');
  }
</script>

<Child on:click={onClick} />
```

![](/images/svelte/04-8.png)

我们可以转发组件的自定义事件，也能转发原生事件。

## 简写

当出现属性名和值一样时，可以进行简写。比如`value={value}`可以简写为`{value}`。

举个例子：
```html
<script>
  let checked = false;
  
  const onChange = () => {
    checked = true;
  }
</script>

<input type="checkbox" {checked} />
<button on:click={onChange}>change to checked</button>
```
原本，我们需要`<input type="checkbox" checked={checked} />`的形式书写。
![](/images/svelte/04-9.gif)

## `$$props`

`$$props`可以获取父级传递的所有属性，包括 props 属性和非props属性。

```html
<script>
  // Child.svelte
  export let value;

  console.log('$$props', $$props)
</script>

<div>子组件</div>
```

```html
<script>
  // Father.svelte
  import Child from './Child.svelte';
</script>

<Child value={'hello'} a={'a'} b={'b'} />
```

![](/images/svelte/04-10.png)

## `$$restProps`
`$$props`包含了props属性和非props属性，而`$$restProps`则只包含了非props属性。
将上个例子的console进行改写：
```html
<script>
  export let value;

  console.log('$$props', $$props);
  console.log('$$restProps', $$restProps);
</script>

<div>子组件</div>
```

![](/images/svelte/04-11.png)

我们可以把`$$props`和`$$restProps`直接解构传值，只是不推荐这种写法，因为容易造成混淆。
```html
<script>
  import GrandSon from './GrandSon.svelte';
  export let value;
</script>

<GrandSon {...$$props} />
```
## 小结
本章我们学习了：
- 使用`export`来声明一个变量为组件对外的prop，我们可以为prop设置默认值
- 如何将关键字声明为prop
- 使用`createEventDispatcher`方法可以在组件内对外发送事件，外部在引用组件时便能进行事件监听
- 组件的事件转发
- 组件属性赋值时的简写
- Svelte提供的`$$props`、`$$restProps`属性能够快速地获取对应prop值
---
title: Svelte从入门到精通——生命周期
description: 【入门篇】生命周期
---

每个组件从创建开始，到销毁结束这个过程，都有一个生命周期。在不同的生命周期阶段，组件对外提供一个方法，使调用组件的开发人员能够更灵活地在每个生命周期阶段对组件进行控制，这类方法便是生命钩子函数。

  Svelte的生命周期钩子有：
  - `onMount`
  - `beforeUpdate`
  - `afterUpdate`
  - `onDestroy`
  - `tick`
  
## 调用时机

如果使用服务端渲染（SSR），除了`onDestroy`，其余生命周期函数不会在SSR运行期间执行。

在Svelte中，生命周期函数只能在组件初始化时编写，以便将回调绑定到组件的实例，切勿将生命周期函数放在一些如setTimeout、setInterval之类的异步方法中。

虽然我们需要确保生命周期函数在组件初始化时被调用，但至于从何处调用它们则无关紧要。比如，我们可以把生命周期放到一个方法中：

```javascript
// app.js
import { onMount,onDestroy } from 'svelte';

export const startInterval = () => {
  let timer = null;
  let count = 0;

  onMount(() => {
    console.log('onMount');
    timer = setInterval(() => {
      count++;
      console.log('count');
    }, 1000)
  });

  onDestroy(() => {
    console.log('onDestroy');
    if (timer) {
      clearInterval(timer);
    }
  })
}
```

```html
<script>
  import { startInterval } from './app.js';

  startInterval();
</script>

<div>App</div>
```
这种情况下，生命周期依然能够确保在组件初始化时被调用。
## onMount

在组件挂载到DOM后立即执行的回调。
```typescript
onMount(callback: () => void)

onMount(callback: () => () => void)
```

`onMount`接收一个回调函数作为参数，如果这个回调函数内返回一个函数，则在卸载组件时调用该函数。

我们可以看下源码，在Svelte项目的`packages/svelte/src/runtime/internal/Component.js`文件内：
```javascript
/** @returns {void} */
export function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  // onMount happens before the initial afterUpdate
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    // if the component was destroyed immediately
    // it will update the `$$.on_destroy` reference to `null`.
    // the destructured on_destroy may still reference to the old array
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      // Edge case - component was destroyed immediately,
      // most likely as a result of a binding initialising
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
```
我们可以看到，会执行`onMount`的方法后拿到一个值，接着会判断组件内有没有声明`onDestroy`生命周期钩子，有则添加到`onDestroy`数组中，在执行`onDestroy`后执行这个返回值，没有则直接执行这个返回值。在React的`useEffect`hook中，有相同的功能。

```javascript
useEffect(() => {
  return () => {}
}, []);
```

我们演示一个Svelte的`onMount`返回值的例子：
```html
<script>
  // Child.svelre
  import { onMount } from 'svelte';

  onMount(() => {
    console.log('child mount');
    return () => {
      console.log('child destroy 1');
    }
  })
</script>

<div>child</div>
```

```html
<script>
  // Father.svelte
  import Child from './Child.svelte';
  let count = 0;

  const updateCount = () => {
    count++;
  }
</script>


<button on:click={updateCount}>add</button>
{#if count == 0}
<Child />
{/if}
```
这个例子是，我们在父级页面有一个变量count，通过count变化来控制子组价的显隐。
执行代码，控制台会依次输出：child mount -> child destroy 1。

然后我们添加`onDestroy`钩子：
```html
<script>
  import { onMount, onDestroy } from 'svelte';

  onMount(() => {
    console.log('child mount');
    return () => {
      console.log('child destroy 1');
    }
  })

  onDestroy(() => {
    console.log('child destroy 2');
  })
</script>

<div>child</div>
```
执行代码，控制台会依次打印出：child mount -> child destroy 2 -> child destroy 1。

对于兄弟组件，`onMount`会根据组件调用的顺序，从上往下执行。而对于父子组件，当子组件的`onMount`执行完毕之后，才会执行父组件的`onMount`，也就是从内到外。
```html
<script>
  import { onMount } from "svelte";
  import Child from "./Child.svelte";
  import Child2 from "./Child2.svelte";

  onMount(() => {
    console.log("fahter mount");
  });
</script>

<Child />
<Child2 />
```
我们定义三个组件：一个父组件，两个子组件。在三个组件内分别调用`onMount`。
执行后，我们能看到：child mount 1 -> child mount 2 -> father mount。

## beforeUpdate

在DOM更新之前执行，首次回调运行在`onMount`初始化之前。
```typescript
beforeUpdate(callback: () => void)
```

演示一个例子：
```html
<script>
  import { beforeUpdate } from "svelte";

  let count = 0;
  let str = "";

  const updateData = () => {
    count++;
    setTimeout(() => {
      str += "s";
    }, 1000);
  };

  beforeUpdate(() => {
    console.log("before update", count, str);
  });
</script>

<button on:click={updateData}>update</button>
<span>{count}</span><span>{str}</span>
```
加载页面后，我们会首先看到控制台打印出before update 0。点击按钮更新，看到打印出before update 1，1s后看到打印出before update 1 s。  
![](/images/svelte/05-1.png)
  
需要注意的是，如果组件中同时存在`beforeUpdate`与`onMount`，首次`beforeUpdate`回调会在`onMount`之前执行。如果我们在上述代码中调用`onMount`钩子，然后执行相同步骤，则看到：  
![](/images/svelte/05-2.png)

## afterUpdate

在组件渲染之后执行的回调。
```typescript
afterUpdate(callback: () => void)
```

对于兄弟组件，`beforeUpdate`和`afterUpdate`依然是按照组件调用的顺序，从上往下执行。而对于父子组件，会先执行父组件的`beforeUpdate`，然后执行子组件的`beforeUpdate`。

当子组件的`beforeUpdate`执行完毕之后，再执行父组件的`afterUpdate`，最后执行子组件的`afterUpdate`。

```html
<script>
  import { onMount, onDestroy, beforeUpdate, afterUpdate } from "svelte";
  import Child from "./Child.svelte";
  import Child2 from "./Child2.svelte";
  let count = 0;

  const updateCount = () => {
    count++;
  };

  beforeUpdate(() => {
    console.log("fater beforeupdate");
  });

  onMount(() => {
    console.log("father mount");
  });

  afterUpdate(() => {
    console.log("father afterupdate");
  });

  onDestroy(() => {
    console.log("father destroy");
  });
</script>

<button on:click={updateCount}>add</button>
{#if count <= 1}
  <Child {count} />
  <Child2 {count} />
{/if}
```

子组件内容如下，Child1.svelte和Child2.svelte只有输出内容的序号不同，其他无异：
```html
<script>
  // Child.svelte
  import { onMount, onDestroy, beforeUpdate, afterUpdate } from 'svelte';

  export let count;

  beforeUpdate(() => {
    console.log('child beforeupdate 1')
  });

  onMount(() => {
    console.log('child mount 1');
  });

  afterUpdate(() => {
    console.log('child afterupdate 1');
  });

  onDestroy(() => {
    console.log('child destroy 1');
  });
</script>

<div>child</div>
{count}
```

在初次执行时：  
![](/images/svelte/05-3.png)

点击按钮更新后：  
![](/images/svelte/05-4.png)

## onDestroy

在组件卸载后运行的回调。
```javascript
onDestroy(callback: () => void)
```

兄弟组件之间的`onDestroy`依然是根据调用顺序从上往下。而父子组件则是从外到内，先执行父组件的`onDestroy`，再执行子组件的`onDestroy`。
`onMount`返回的函数会在组件销毁的时候执行，这个函数会在`onDestroy`之后执行，我们在之前了解`onMount`时已讲解过源码。

## tick

`tick`函数与其他生命周期钩子不同，我们可以随时调用它，而不用等待组件首次初始化。它返回一个`Promise`，在任何一个state状态发生变化时立即resolve。
```typescript
promise: Promise = tick()
```

在Svelte中，当改变一个state状态时，不会立即更新DOM，而是会等到下一个微任务时更新，在等待期间会持续监听是否有其他state状态改变，然后在这个微任务中统一更新DOM，这样可以减少一些无用功，让浏览器更有效地批量处理这些事情。

我们在开发过程中可能会遇到这种问题：组件中的某个状态更新了，但DOM没有更新，而我恰恰就想获取dom的值，这时`tick`函数便能派上用场了！（不错，可以看成是Vue中的$nextTick()）

```html
<script>
  let count = 0;

  const addCount = () => {
    count++;
    let countDom = document.querySelector('#count');
    if (countDom) {
      console.log('count text', countDom.innerHTML);
    }
  }
</script>

<button on:click={addCount}>add</button>

<span id="count">{count}</span>
```

![](/images/svelte/05-5.gif)  

我们可以看到，即使页面上已经更新了，操作DOM获取的值依然是旧的数据。

为了解决上述问题，我们可以：
```html
<script>
  import { tick } from 'svelte';
  let count = 0;

  const addCount = async () => {
    count++;
    await tick();
    let countDom = document.querySelector('#count');
    if (countDom) {
      console.log('count text', countDom.innerHTML);
    }
  }
</script>

<button on:click={addCount}>add</button>

<span id="count">{count}</span>
```

![](/images/svelte/05-6.gif)  

而当我们使用了tick之后，能够取到最新的值。

## 小结

本章我们学习了：
- Svelte生命周期函数的作用
- 各生命周期函数在父子组件渲染时的执行顺序
- tick的作用---
title: Svelte从入门到精通——动态属性
description: 【入门篇】动态属性
---

如果读者接触过Vue或者React，那么必然了解过像Vue的`computed`、`watch`和React的`useMemo`等用于监听某些变量发生更改后才重新计算出新的变量或执行某些方法的Api。

在Svelte中，同样提供了类似的功能。Svelte称之为Reactivity，中文翻译为“反应性”，不过笔者更喜欢称其为响应式能力，触发响应式能力的核心则是——赋值，这个我们在《数据与方法》章节已经简单演示过了。具体写法如下：
```javascript
$: 你的逻辑
```

可能大家会好奇`$`是什么语法，其实它是js正常支持的语法[JS label 语法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label)，只是少有人用，相当于一个几乎废弃的语法。
  
Svelte通过使用 `$:` 作为前缀，可以让任何位于top-level的语句（即不在块或函数内部）具有反应性。每当它们依赖的值发生更改时，它们都会在组件更新之前立即运行。

## 声明

### `$:`语法

如果语句完全由未声明变量的赋值组成，则Svelte替你将 `let`插入声明
```html
<script>
  let count = 0;

  $: double = count * 2;
  
  let noReactiveDouble = count * 2;

  const add = () => {
    count++;
  }
</script>

<button on:click={add}>add</button><br>
count: {count}<br>
doubleCount: {double}<br>
noReactiveDouble: {noReactiveDouble}
```

![](/images/svelte/06-1.gif)

我们不用声明`let double`，在`$: double = count * 2;`中相当于Svelte自动帮我们声明了。

## 语句

我们在上述代码中添加一行：
```javascript
$: console.log('$ console', count, double, noReactiveDouble);
```

![](/images/svelte/06-2.gif)
可以直观地观察到各状态的变更。在`$:`里声明的变量double会随着count的改变而改变，而在`$:`之外声明的变量noReactiveDouble则由于初始的count是0，而即使count改变了，noReactiveDouble仍旧是0。

### 与beforeUpdate的区别

```html
<script>
  import { beforeUpdate } from 'svelte';

  let count = 0;
  let noReactiveDouble = count * 2;

  const add = () => {
    count++;
  }

  $: console.log('$ console', noReactiveDouble);

  beforeUpdate(() => {
    console.log('beforeUpdate console', noReactiveDouble)
  })
</script>

<button on:click={add}>add</button><br>
count: {count}<br>
noReactiveDouble: {noReactiveDouble}
```

![](/images/svelte/06-3.gif)
当我们重新刷新页面时，可以看到`$`里执行了一次，beforeUpdate也执行了一次。因为`let noReactiveDouble = count * 2`是赋值操作，在第一次赋值时触发了`$: console.log('$ console', noReactiveDouble);`；而beforeUpdate则是由于`count`和`noReactiveDouble`这两个变量有赋值操作。
当我们点击更新时，因为`noReactiveDouble`不是响应性的变量，因此只会触发`beforeUpdate`。

`$`语句内的逻辑只有在语句内的变量触发更新时才会执行。而beforeUpdate则相当于收集了所有变量依赖。当其中的一个依赖变化时则执行。

### 声明

语句除了能像`$: console.log()`这样单行写，也可以包裹在一个`{}`花括号中。
```javascript
$: {
  // 执行逻辑
}
```

在声明章节，我们知道了Svelte能够帮我们自动声明未使用let声明的变量。`$: double = count * 2;`这一句表达式相当于以下写法：
```javascript
let double;
$: {
  double = count * 2;
}
```

因此当我们使用`{}`时，还是需要自己进行声明：
```html
<script>
  let count = 0;
  $: double = count * 2;
  let double2;

  $: {
    double2 = count * 2;
  }

  const add = () => {
    count++;
  }
</script>

<button on:click={add}>add</button><br>
count: {count}<br>
doubleCount: {double}<br>
double2: {double2}
```

![](/images/svelte/06-4.gif)

## 依赖

当我们在使用`$: {}`进行一些复杂的响应式操作时，可能会遇到一种情况。我们只想要我们的代码在某个变量改变时才执行，而不是代码里的每个变量更改时都执行一次。比如：
```html
<script>
  let width = 1;
  let height = 1;

  $: area = width * height;
</script>

width: <input type="number" bind:value={width} /><br />
height: <input type="number" bind:value={height} /><br />
area: {area}
```
每当width或height改变时，`area = width * height`都会执行。

那有没有什么方法让我只在width更改时执行，height更改时不执行？其实技巧就在于把不想监听的依赖移出`$:`之外。

```html
<script>
  let width = 1;
  let height = 1;

  function setArea(width) {
    return width * height;
  }

  $: area = setArea(width);
</script>

width: <input type="number" bind:value={width} /><br />
height: <input type="number" bind:value={height} /><br />
area: {area}
```

![](/images/svelte/06-5.gif)
在`$:`之内，只有width变量，当width变化时会执行`setArea()`，而height没有在`$:`之内，即使height变化了，也没有执行响应式更新。

## 小结
本章我们学习了：
- Svelte中`$`语法的使用，通过`$`我们可以实现计算属性，也可以监听变量更新，从而执行一些操作
- `$`和`beforeUpdate`生命周期函数的区别
---
title: Svelte从入门到精通——模板语法之条件判断与循环判断
description: 【入门篇】模板语法之条件判断与循环判断
---

在程序语言中，当然不止数据的存储和更新，同样重要的还有如何更新和展示这些数据。本章中，笔者将与读者们一起了解如何通过条件判断来展示或隐藏页面内容，如何通过列表循环来展示数组内容。

## 条件判断

通过在模板语法内使用`{#if}`、`{:else if}`、`{:else}`、`{/if}`来控制展示内容：
```javascript
{#if condition}
  code
{:else if condition}
  code
{:else condition}
  code
{/if}
```

`condition`是我们要写的条件表达式，`code`则是页面的展示内容。其中`{:else if}`和`{:else}`是可选的。

```html
<script>
  let score = 0;
</script>

<input type="range" min="0" max="100" bind:value={score} />
分数{score}：
{#if score>=0 && score< 60}
  不及格
{:else if score>=60 && score < 80}
  良好
{:else}
  优秀
{/if}
```
![](/images/svelte/07-1.gif)

## 循环判断

使用`{#each}`、`{:else}`、`{/each}`来循环展示内容。
```javascript
{#each list as item, index (key))}
  code
{:else}
  code
{/each}
```

其中`{:else}`可选。else命中表示用于循环的数组为空数组。
```html
<script>
  let arr = [];

  const onAdd = () => {
    arr = [...arr, 1];
  }

  const onRemove = () => {
    arr.pop();
    arr = arr;
  }
</script>

<button on:click={onAdd}>add</button>
<button on:click={onRemove}>remove</button>
<ul>
  {#each arr as item}
    <li>{item}</li>
    {:else}
      No Data
  {/each}
</ul>
```

![](/images/svelte/07-2.gif)

除了展示正常的数组外，还能展示继承了Iterable接口的数据。  

遍历Entry对象：
```html
<script>
  let map = {
    a: 'hello',
    b: 'world'
  }
  let list = Object.entries(map)
</script>

<ul>
{#each list as item}
  <li>{item[0]}:{item[1]}</li>
{/each}
</ul>
```
![](/images/svelte/07-7.png)

遍历字符串：
```html
<script>
  let list = 'svelte';
</script>

<ul>
{#each list as item}
  <li>{item}</li>
{/each}
</ul>
```
![](/images/svelte/07-6.png)

### 解构
可以对数组的每一项进行解构赋值。
```html
<script>
  let arr = [{
    name: 'Bob',
    age: 18
  }, {
    name: 'Carter',
    age: 19
  }]
</script>

{#each arr as { name, age }}
  <p>
    姓名：{name}，年龄：{age}
  </p>
{/each}
```
![](/images/svelte/07-3.png)

### key

不管是在React、Vue还是在Svelte中，数组遍历时，我们都能看到会尽可能地要求为遍历项带上key属性。这是为什么呢？

首先我们看一个例子：
```html
<script>
  // Child.svelte
  export let bookName;

  const authors = {
    狂人日记: "鲁迅",
    骆驼祥子: "老舍",
    我与地坛: "史铁生",
    史记: "司马迁",
  };

  const author = authors[bookName];
</script>

<div>{bookName}：{author}</div>
```

然后我们引用这个子组件：
```html
<script>
  import Book from "./Child.svelte";

  let books = [{
      id: 1,
      name: "狂人日记",
    },{
      id: 2,
      name: "骆驼祥子",
    },{
      id: 3,
      name: "我与地坛",
    },{
      id: 4,
      name: "史记",
    },
  ];

  const deleteBook = () => {
    books = books.slice(1);
  };
</script>

<button on:click={deleteBook}>删除第一项</button>

{#each books as item}
  <Book bookName={item.name} />
{/each}
```

当我们点击删除时，便会惊讶地看到，作者和书名对不上了！
![](/images/svelte/07-4.gif)
如果读者感兴趣，可以把删除第一项的操作，改为往数组的第一项添加新项目，此类现象仍旧存在。

这时候便轮到我们的key派上用场。
```javascript
{#each list as item, index (key)}
或
{#each list as item (key)}
```

修改上述例子的代码
```html
...

{#each books as item (item.id)}
  <Book bookName={item.name} />
{/each}
```

![](/images/svelte/07-5.gif)

当我们使用key时，需要确保**key值的唯一**：当我们使用key时，实际上是在告诉Svelte将每个渲染block映射到该key。当key不再存在时，删除对应展示block并将其从DOM中删除。但是，如果我们不指定key时，Svelte将使用列表的索引作为key。如果我们从列表中删除block，key值并没有变化。如果key保持不变并且props发生变化，将会只更新props而不是重新创建block。

## 小结

本章我们学习了：
- Svelte中的条件判断。通过`{#if}{:else if}{:else}{/if}`来切换显示内容。
- Svelte中的循环判断。通过`{#each}{:else}{/each}`来展示列表内容。
- 循环中key的作用。
- 条件判断与循环判断的语句都放在特殊的标签语言当中。可能刚开始读者朋友们记这些标签会偶尔搞混，这里笔者给大家总结了规律。标签以`#`开头，中间部分`:`，以`/`结尾，这样是不是好记多了。---
title: Svelte从入门到精通——插槽
description: 【入门篇】插槽
---

当我们将功能封装成一个组件并引用时，通常的写法如下：
```html
<Component />
```

然而一些情况下，我们希望我们的组件可以支持如下功能：
```html
<Component>我的自定义内容</Component>
```
一个最常见的场景便是UI组件中的Modal弹窗组件。弹窗的弹出隐藏是通用的，但是弹窗内的内容则是五花八门，完全由用户自己定义，而这种能够往组件内部插入自定义内容的模块，我们称之为“插槽”。

## 默认插槽

在Vue中，使用 `slot`标签来表示这是一个插槽。在React当中，由于使用JSX语法，万物都可当成js来写，所以没有像Vue一样的特定标签，可以直接从 `props.children`拿到组件的插值。而Svelte和Vue一样，提供了特定的标签`slot`来放置插槽内容。

写法如下：
```html
<slot><!-- 可选回调 --></slot>
```

我们声明两个组件Child.svelte和Father.svelte

```html
<!-- Child.svelte -->
<slot>child content</slot>
```
  

```html
<!-- Father.svelte -->
<script>
  import Child from './Child.svelte';
</script>

<Child></Child>
```

此时页面上我们看见的是“child content”这个字符串内容。因为如果`<slot>`内部有内容，当我们没有在外部没有使用到slot时，这部分内容便会作为默认值展示。

如果我们往Child组件内添加一下内容：
```html
<Child>
  father content
</Child>
```
那么我们会看到，原来slot内提供的默认内容已被替换成了外部组件的内容“father content”。


## 具名插槽

有时候我们只希望用户能够替换组件功能的某一部分内容，比如一个input输入框，我们允许用户替换prefix和suffix：
![](/images/svelte/08-1.png)

亦或者是一个Modal模态框，我们允许用户使用组件写好的header和footer，也允许用户自定义头部和底部，那么这时候，我们便需要使用到带名字的插槽，即具名插槽。

```html
<slot name="x"><!-- 可选回调 --></slot>
```

  举个例子：
```html
<script>
  // Child.svelte
  import { createEventDispatcher } from "svelte";

  const dispatch = createEventDispatcher();

  export let show;

  let dialogRef;

  $: if (dialogRef && show) {
    dialogRef.showModal();
  }
  
  $: if (dialogRef && !show) {
    dialogRef.close();
  }
  
  const onClose = () => {
    dialogRef.close();
    show = false;
  };
</script>

<dialog bind:this={dialogRef}>
  <header>
    <slot name="header">
      header
      <span on:click|stopPropagation={onClose}>close</span>
    </slot>
  </header>
  <main>
    <slot>body</slot>
  </main>

  <footer><slot name="footer">footer</slot></footer>
</dialog>

<style>
  dialog {
    width: 300px;
    height: 250px;
    border: 1px solid black;
  }

  header {
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  main {
    height: 150px;
  }

  footer {
    height: 50px;
  }

  dialog::backdrop {
    background-image: linear-gradient(
      45deg,
      magenta,
      rebeccapurple,
      dodgerblue,
      green
    );
    opacity: 1;
  }
</style>
```
  
```html
<script>
  import Modal from './Child.svelte';
  let show = false;

  const onOpen = () => {
    show = true;
  }
</script>

<Modal bind:show={show}>
</Modal>
<button on:click={onOpen} >open</button>
```
页面展示效果如下：  
![](/images/svelte/08-2.gif)


当我们自定义slot内容时：
```html
<script>
  import Modal from './Child.svelte';
  let show = false;

  const onOpen = () => {
    show = true;
  }

  const onClose = () => {
    show = false;
  }
</script>

<Modal bind:show={show}>
  <div on:click={onClose} slot="header"> custom header </div>
  <div slot="footer">custom footer</div>
  custom body content
</Modal>
<button on:click={onOpen} >open</button>
```
那么我们可以得到如下效果：
![](/images/svelte/08-3.gif)

## 传值

通过prop属性将值传回父级,父级使用 `let:`指令将值暴露到slot模板。
```html
<slot prop={value}></slot>
```

一个非常经典的例子：在表格单元格中，获取到对应的数据项的值。

由于在Svelte5中方能支持[动态slot](https://svelte-5-preview.vercel.app/docs/snippets#passing-snippets-to-components)，因此实现表格的传值，我们只能如下写：

```html
<script>
  // Child.svelte
  export let columns = [];
  export let data = [];
</script>

<table >
  <thead>
    <tr>
    {#each columns as column}
      <th>{column.name}</th>
    {/each}
    </tr>
  </thead>
  <tbody>
    {#each data as row}
      <tr>
        <slot {row}></slot>
      </tr>
    {/each}
  </tbody>
</table>

<style>
  table, th {
    border: 1px solid black;
  }
  :global(td) {
    border: 1px solid black;
  }
</style>
```

```html
<script>
  // Father.svelte
  import Table from "./Child.svelte";

  let columns = [
    {
      key: "id",
      name: "id",
    },
    {
      key: "name",
      name: "姓名",
    },
    {
      key: "age",
      name: "年龄",
    },
  ];

  let data = [
    {
      id: 1,
      name: "张三",
      age: 18,
    },
    {
      id: 2,
      name: "李四",
      age: 19,
    },
  ];
</script>

<Table {data} {columns}>
  <svelte:fragment let:row>
    <td>{row.id}</td>
    <td>{row.name}</td>
    <td>{row.age}</td>
  </svelte:fragment>
</Table>

```
![](/images/svelte/08-4.png)

通常适用的速记规则：`let:item` 等效于`let:item={item}`，并且`<slot {item}>`等效于`<slot item={item}>`。

## `$$slots`
`$$slots`是一个对象，它的键是父级传递到组件中的插槽的名称。如果父级没有传入具有特定名称的插槽，那么该名称不会出现在`$$slots`中。 我们可以使用这一特性来判断父级是否有传入特定名称的插槽内容：
```html
{#if $$slots.header}
  <slot name="header"></slot>
{/if}
```

继续以上面的Modal组件为例，我们在组件内试着打印出`$$slots`： `console.log('$$slots', $$slots, $$props);`
![](/images/svelte/08-5.png)
我们可以看到，`$$slots`是一个对象，default可以表示默认的slot，其他key表示其他具名插槽。如果使用了对应的slot，对应的key的值便是true，反之则为false。因此，如果我们想像React和Vue那样劫持slots的内容并重新定义，那是不可能了。

比如Antd的Space组件，作用是把被其包裹的子元素间隔开。其实现核心就是对slot的内容添加子元素样式，这些样式能够添加间距。

Ant-Design的Space组件的[源码](https://github.com/ant-design/ant-design/blob/4.24.15/components/space/index.tsx)内容：
```javascript
const childNodes = toArray(children, { keepEmpty: true });

const nodes = childNodes.map((child, i) => {
  if (child !== null && child !== undefined) {
    latestIndex = i;
  }

  const key = (child && child.key) || `${itemClassName}-${i}`;

  return (
    <Item
      className={itemClassName}
      key={key}
      direction={direction}
      index={i}
      marginDirection={marginDirection}
      split={split}
      wrap={wrap}
    >
      {child}
    </Item>
  );
});
```

Ant-Design-Vue的Space组件的[源码](https://github.com/vueComponent/ant-design-vue/blob/4.1.2/components/space/index.tsx)内容：
```javascript
const children = slots.default?.();
const items = filterEmpty(children);
const len = items.length;

const itemClassName = `${prefixCls.value}-item`;
const horizontalSizeVal = horizontalSize.value;
const latestIndex = len - 1;
return (
  <div>
    {items.map((child, index) => {}
  </div>
)
```

那如果Svelte想要实现此类功能应该如何操作？我们留到后文《指令》中进行讲解。

## 小结

本章我们学习了：
- 插槽的概念。通过`<slot></slot>`可以接收外部传递的页面内容。
- 指定名称的插槽。在定义时通过`<slot name="x">`来指定具体名称的插槽，在使用时通过在html标签内添加`slot`属性（`<div slot="x">`）的形式来调用。
- slot的传值。通过prop属性将值传回父级,父级使用 `let:`指令将值暴露到slot模板。
- Svelte提供的`$$slots`内置属性---
title: Svelte从入门到精通——节点引用
description: 【入门篇】节点引用
---

即使当今的主流开发模式提倡的是数据驱动视图，然而我们仍旧无法完全摆脱对dom的操作，我们也不能摆脱。这里笔者可以随便举几个例子：input输入框的`focus`和`blur`方法的触发、使用`<input type="file" />`来自定义实现上传时的手动`click`等。

无论是在React还是在Vue中，都有提供对dom的引用的api操作，而这种对dom的引用通常称为Ref。那在Svelte中，我们要如何拿到我们的Ref呢？

## bind:this

在《数据与方法》一章，我们在使用双向绑定功能时，用到了`bind:value={value}`的方式。而如果想要访问真实的dom，同样需要使用到`bind`。

```javascript
bind:this={dom_node}
```

### dom
我们看一个例子：
```html
<script>
  let dialogDom;
  let dialogRef;

  const open1 = () => {
    dialogDom = document.querySelector('dialog');
    console.log('dom', [dialogDom]);
    if (dialogDom) {
      dialogDom.showModal();
    }
  }

  const open2 = () => {
    console.log('ref', [dialogRef]);
    if (dialogRef) {
      dialogRef.showModal();
    }
  }

  const close = () => {
    dialogDom && dialogDom.close();
    dialogRef && dialogRef.close();
  }
</script>

<button on:click={open1}>打开1</button>
<button on:click={open2}>打开2</button>
<dialog bind:this={dialogRef}>
  dialog content <span on:click={close}>close</span>
</dialog>
```
笔者用两种方式实现了打开dialog的逻辑。open1使用原生dom来操作，open2使用到了`bind:this`。这里笔者将`bind:this`绑定到正常的html标签dialog上，然后我们能够看到，通过`bind:this`得到的数据和使用原声dom api操作得到的数据并无差异。
![](/images/svelte/09-1.gif)

### 组件
`bind:this`除了能够绑定html标签上，也能够绑定到组件上。

### export
在某些特定场合下，我们可能希望直接操作子组件内的数据和方法。

假设我们有一个子组件：
```html
<script>
  let data = '测试bind:this数据';

  const func = () => {
    console.log('测试bind:this方法');
  }
</script>
```

此时我们外部引用这个组件，并打印出这个组件的实例
```html
<script>
  import Child from './Child.svelte';

  let ref;

  $: console.log('ref', ref);
</script>

<Child bind:this={ref} />
```

![](/images/svelte/09-2.png)
此时我们并不能拿到子组件的数据和方法。要想拿到子组件的数据和方法，我们需要使用到`export`。
```html
<script>
  export let data = '测试bind:this数据';

  export const func = () => {
    console.log('测试bind:this方法');
  }
</script>
```
![](/images/svelte/09-3.png)
我们可以看到，数据与方法都正常导出了。然而因为使用了`export`，原来的数据变成了一个prop属性，Svelte并不允许我们直接拿到这个属性。我们要么在`<svelte:options>`中做一些配置，要么就是我们在子组件内定义一个专门取数据的方法。
```html
<script>
// Child.svelte
  export let data = '测试bind:this数据';

  export const func = () => {
    console.log('测试bind:this方法');
  }
  
  export const getData = () => {
    return data;
  }
</script>
```

```html
<script>
  import Child from './Child.svelte';

  let ref;

  $: console.log('ref', ref);

  $: {
    if (ref) {
      let data = ref.getData();
      console.log('数据拿到了吗：', data);
    }
  }
</script>

<Child bind:this={ref} data={'98765'} />
```
![](/images/svelte/09-4.png)

我们以真实场景来举个例子。  
我们封装了一个倒计时组件，倒计时内部有启动倒计时的功能。而何时触发倒计时则由外部引用的页面决定：
```html
<script>
  // Countdown.svelte
  import { onDestroy, createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  export let countdown = 60;
  export let unit = 's';

  let timer = null;

  const clearTimer = () => {
    timer && clearInterval(timer);
  }

  const initTimer = () => {
    clearTimer();
    timer = window.setInterval(() => {
        countdown--;
        if (countdown < 1) {
          clearTimer();
          end();
        }
      }, 1000);
  }

  const end = () => {
    dispatch('end');
  }

  export const start = () => {
    initTimer();
  }

  onDestroy(() => {
    clearTimer();
  })
</script>

<span>{ countdown }{ unit }</span>
```
首先我们实现了一个Countdown组件，这个组件对外暴露了一个start方法，方便外层手动控制计时器的开始。

```html
<script>
  import Countdown from "./Countdown.svelte";

  let ref;

  const onCountdownEnd = () => {
    console.log("倒计时结束！");
  };

  const onCountdownStart = () => {
    if (ref) {
      ref.start();
    }
  };
</script>

<Countdown bind:this={ref} countdown={10} on:end={onCountdownEnd} />
<button on:click={onCountdownStart}>开始倒计时</button>
```
外层`bind:this`绑定到Countdown组件，在点击按钮时，调用倒计时组件实例的start方法。

![](/images/svelte/09-5.gif)

## 数组

当我们想在`{#each}`中使用`bind:this`时，使用数组来存储绑定的值。

```html
<script>
  let arr = ['red', 'blue', 'green', 'orange']
  let refArr = [];

  $: {
    console.log(refArr);
    refArr.forEach(li => {
      li.setAttribute('style', `color: ${li.innerText};`)
    })
  }
</script>

<ul>
{#each arr as item, index}
  <li bind:this={refArr[index]}>{item}</li>
{/each}
</ul>
```

![](/images/svelte/09-6.png)

## 小结

本章我们学习了：
- 使用`bind:this`绑定到html标签，用来获取真实DOM节点
- 使用`bind:this`绑定到组件上，用来获取组件实例
- 组件如何对外暴露自身方法
- 在循环列表中使用`bind:this`
---
title: Svelte从入门到精通——样式
description: 【入门篇】样式
---

### scoped

在`<style></style>`内编写的样式默认是scoped，组件内生效的。
```html
<!-- Child.svelte -->
<p class="txt">hello svelte</p>

<style>
  .txt {
    color: green;
  }
</style>
```

```html
<script>
// App.svelte
  import Child from './Child.svelte';
</script>

<p class="txt">hello 1</p>
<Child />

<p class="txt">
  hello 2
  <Child />
</p>

<style>
.txt {
  color: red;
}
</style>
```

![](/images/svelte/10-1.png)
在上述例子中，笔者编写了一个绿色字体的组件，可以看到，即使外部的字体都设置成了红色，也没有影响到组件内部的样式。
![](/images/svelte/10-4.png)
从编译后的html内容中可以看到，每个节点的样式class都添加了单独的s-xxx选择器。

### global

在一些情况下，我们需要让我们的样式不止在组件内生效，最常见的场景便是修改UI组件的样式。一个UI组件库通常有自己的固定样式，当我们引用了UI组件库后，往往需要重新修改原有样式以适配业务。

```html
<!-- Button.svelte -->
<button class="svelte-button">button</button>

<style>
  .svelte-button {
    border: 1px solid black;
    border-radius: 4px;
    padding: 4px 8px;
  }
</style>
```

```html
<script>
  // App.svelte
  import Button from './Button.svelte';
</script>

<Button />

<div class="button-wrapper">
<Button />
</div>

<style>
:global(.button-wrapper .svelte-button) {
  border: none;
  background-color: orange;
  border-radius: 8px;
  color: white;
}
</style>
```

![](/images/svelte/10-5.png)
我们设置了一个Button.svelte来作为UI组件的例子，当App.svelte正常引入这个组件时，展示的是其原有的样式，通过`:global()`我们能够正常覆盖组件内的样式。

## 预处理器

CSS可以用来修改网页样式和外观，但严格意义上讲，CSS并不是一种编程语言，无法使用它来进行编程。CSS不像其他编程语言一样能够进行复杂程序逻辑的操作，而且写起来很费事，代码难以组织和维护。CSS预处理器应运而生。

CSS预处理器的功能就是通过变量、嵌套、函数等逻辑特性，让CSS拥有一些可编程的特性，从而提高开发者的开发效率。

目前主流的CSS预处理器主要有Sass、Less、Stylus、PostCSS。

### Less
```bash
npm install svelte-preprocess-less less -D
```

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'
import { less } from 'svelte-preprocess-less';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [svelte({
    preprocess: {
      style: less()
    }
  })],
})
```

```less
// component.less
.wrap {
  header {
    color: aquamarine;
  }
  .content {
    font-size: 24px;
    font-weight: bold;
  }
}
```

```html
<!-- Component.svelte -->
<div class="wrap">
  <header>hello world</header>
  <div class="content">content</div>
</div>

<style lang="less">
@import "./component.less";
</style>
```
![](/images/svelte/10-2.png)

### Sass

```bash
npm install svelte-preprocess-sass sass -D
```

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'
import { sass } from 'svelte-preprocess-sass';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [svelte({
    preprocess: {
      style: sass()
    }
  })],
})
```

```html
<div class="wrap">
  <header>hello world</header>
  <div class="content">content</div>
</div>

<style lang="sass">
@import ./component.sass
</style>
```

```scss
// component.sass
.wrap 
  header 
    color: aquamarine
  .content 
    font-size: 24px
    font-weight: bold
```

### Stylus

```bash
npm install svelte-preprocess stylus -D
```

Stylus除了需要在vite.config.js中配置外，还需要在svelte.config.js中配置。
```javascript
// vite.config.js
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [svelte()],
})
```

```javascript
// svelte.config.js
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'
import * as sveltePreprocess from 'svelte-preprocess';

const { stylus } = sveltePreprocess.default;

export default {
  // Consult https://svelte.dev/docs#compile-time-svelte-preprocess
  // for more information about preprocessors
  preprocess: vitePreprocess({
    preprocess: [
      stylus()
    ]
  }),
}
```

```stylus
// component.styl
.wrap 
  header 
    color aquamarine
  .content 
    font-size 24px
    font-weight bold
```

```html
<div class="wrap">
  <header>hello world</header>
  <div class="content">content</div>
</div>

<style lang="stylus">
@import "./component.styl"
</style>
```
## 行内样式

### 表达式

我们可以在行内样式中，在`{}`内使用变量或表达式。
```html
<script>
  let color = 'gray'
</script>

color: <input bind:value={color} />

<div style="color: {color};">color</div>
```
![](/images/svelte/10-6.gif)

```html
<script>
  let color = "gray";
</script>

color: <input bind:value={color} />

<div style="color: {color}; {color === 'red' ? 'font-size: 32px;' : ''}">
  color
</div>
```

![](/images/svelte/10-7.gif)
在这个例子中，我们可以在`{}`内进行表达式的判断，从而实现动态加载一些样式。

### 指令

可以通过`style:property={value}`的形式来操作行内样式。
```html
<script>
  let color = "gray";
</script>

color: <input bind:value={color} />

<div
  style:color
  style:font-size={color === "red" ? '32px' : ''}>
  color
</div>
```
例子中的代码同样可以实现上图的效果。

遗憾的是，不同于React，我们无法往style属性中传入一个对象类型的值，Svelte目前不支持对象类型的样式值。我们可以使用一些转换的库如[style-object-to-css-string](https://www.npmjs.com/package/style-object-to-css-string)，也可以自己定义转换功能。

```javascript
export const styleToString = (style: Record<string, string | number>): string => {
  return Object.keys(style).reduce((str, key) => {
    const value = style[key];
    return str + `${key}: ${value};`;
  }, '');
}
```

```html
<script>
  let color = "red";
  $: style = {
    color: color,
    "font-size": "32px",
  };

  const styleToString = (style) => {
    return Object.keys(style).reduce((str, key) => {
      const value = style[key];
      return str + `${key}: ${value};`;
    }, "");
  };

  $: styleStr = styleToString(style);
</script>

color: <input bind:value={color} />

<div style={styleStr}>color</div>
```
![](/images/svelte/10-8.gif)

## class属性

### 简写

```html
<!-- 它们是等价的 -->
<div class="{active ? 'active' : ''}">...</div>
<div class:active={active}>...</div>

<!-- 简写 -->
<div class:active>...</div>

<!-- 可以包含多个class状态 -->
<div class:active class:inactive={!active}>...</div>
```

### 原子化
在Svelte中，同样可以使用一些流行的原子化CSS框架，诸如[Tailwind CSS](https://tailwindcss.com/)、[UniCSS](https://unocss.dev/)等。Svelte的诸多UI库，均选择了Tailwind等原子化框架来处理样式，比如：[shadcn-svelte](https://www.shadcn-svelte.com/)、[melt-ui](https://melt-ui.com/)。

## 变量
#### css变量

style中的样式跟随变量更改
```html
<script>
  let color = "red";
</script>

文案颜色：<input bind:value={color} />
<span class="text" style="--color: {color}">hello world</span>


<style>
  .text {
    color: var(--color);
    border: 1px solid var(--color);
    padding: 3px;
  }
</style>
```

![](/images/svelte/10-3.gif)
CSS 变量会破坏 Svelte 组件局部作用域的特性。
### CSS-in-Js

同样，我们可以使用一些cssinjs库和Svelte结合使用。以[Emotion](https://emotion.sh/docs/introduction)为例：
```html
<script>
  import { css } from '@emotion/css';

  let color = 'black';

  $: style = css`
    width: 100px;
    padding: 8px;
    border: 1px solid #eee;
    font-size: 24px;
    border-radius: 4px;
    color: ${color};
    &:hover {
      box-shadow: 5px 10px 20px ${color};
    }
  `;
  
</script>

<select bind:value={color}>
  <option value="black">black</option>
  <option value="red">red</option>
  <option value="green">green</option>
</select>
color: {color}
<div class={style}>
  Css in js
</div>
```

![](/images/svelte/10-9.gif)

## 小结

本章我们学习了：
- 在Svelte文件中使用CSS样式，`<style></style>`标签内的样式默认是组件内生效的
- 通过`:global()`在`<style>`标签内定义全局样式
- 在Svelte中使用CSS预处理器，比如：Less、Sass、Stylus等
- Svelte中行内样式的值是一个字符串，如果要使用对象类型来传递，需要自己定义转换方法
- `style:property={value}`指令可以操作行内样式
- Svelte中clss样式属性的简写形式
- 如何通过变量的形式来控制css样式更改


---
title: Svelte从入门到精通——状态管理
description: 【进阶篇】状态管理
---

当业务逻辑简单时，我们可以把所有变量都放在各自的组件或页面内。然而真实的开发情况是，我们的业务逻辑会越来越复杂，页面所承载的数据，亦或者页面与页面之间公用的状态等会变得越来越庞大。此时如何处理和维护系统的状态将变得尤为关键。

## svelte/store

React 的 Redux，或者 Vue 的 Vuex，Pinia。而Svelte内部直接提供了`svelte/store`来管理状态。

`svelte/store`导出了三个方法`writable`、`readable`和`derived`。

### 可写状态 writable

writable的使用如下：
```typescript
function writable<T>(
  value?: T | undefined,
  start?: StartStopNotifier<T> | undefined
): Writable<T>;
```
`writable`的第一个参数表示数据的初始值。第二个参数是一个方法，这个方法内部可以返回一个方法。

```typescript
export type StartStopNotifier<T> = (
  set: (value: T) => void,
  update: (fn: Updater<T>) => void
) => void | (() => void);
```

当一个store是一个`writable`store（可写状态）时，这个store除了有`subscribe`方法外，还具有`set`和`update`方法。

例子1：
```javascript
// store.js
import { writable } from 'svelte/store';
export const count = writable(0);
```

```html
<script>
  // App.svelte
  import { count } from './store';

  count.subscribe(c => {
    console.log('最新值：', c);
  })

  const onSet = () => {
    count.set(1);
  }

  const onUpdate = () => {
    count.update(c => c + 1);
  }
</script>

<button on:click={onSet}>置为1</button>
<button on:click={onUpdate}>加1</button>
```

![](/images/svelte/11-1.gif)

如果我们直接写`{count}`，页面上如下展示：  
![](/images/svelte/11-2.png)

很明显，count已经不是简单的变量。尝试把count`$: console.log('count', count)`打印出来。  
![](/images/svelte/11-3.png)  
此时的count是一个对象，内部有set、subscribe、update方法。

#### 订阅更新
我们在页面中要如何使用`writable`store？  
一个取巧的方式是，我们在页面内部声明一个变量，然后在subscribe监听到状态变化时，将最新的更改赋值给我们声明的变量。

```html
<script>
let _count;

const unsubscribe = count.subscribe(c => {
  _count = c;
});
</script>

{_count}
```


#### 取消订阅
仍旧使用例子1的代码逻辑，我们把原本在App.svelte的逻辑移入到Child.svelte，然后引入Child.svelte：
```html
<script>
  import Child from './Child.svelte';
  import { count } from './store';
  
  let countValue = 0;

  count.subscribe(value => {
    countValue = value;
  })

  const onUpdate = () => {
    count.update(c => c + 1);
  }
</script>

{#if countValue < 5}
  <Child />
{/if}

<button on:click={onUpdate}>father update</button>
```

![](/images/svelte/11-4.gif)

可以看到App.svelte和Child.svelte内都能更新count。而当Child.svelte因为不满足if条件而被销毁之后，内部的`subscribe`仍在执行，这显然是不符合期望的。试想一下，如果我们有成千上万个有显示隐藏功能的组件都进行了`subscribe`。每当这些组件销毁时，这些监听事件仍被保留，久而久之，将会出现内存溢出的风险。因此，每当我们执行了`subscribe`后，记得在合适的时机进行销毁。
`subscribe`执行后返回一个方法，这个方法变用来取消订阅。

修改Child.svelte的代码
```html
<script>
  import { onDestroy } from 'svelte';
  import { count } from './store';

  const unsubscribe = count.subscribe(c => {
    console.log('最新值：', c);
  })

  const onSet = () => {
    count.set(1);
  }

  const onUpdate = () => {
    count.update(c => c + 1);
  }

  onDestroy(unsubscribe);
</script>

<button on:click={onSet}>置为1</button>
<button on:click={onUpdate}>加1</button>
```
![](/images/svelte/11-5.gif)

#### 第二个参数
开头我们已经介绍了`writable`的两个传参的含义，现在我们来演示一下第二个参数的使用。第二个参数接受的是一个方法。这个方法接收两个参数`set`和`update`。

##### set

```html
<script>
  import { count } from './store';

  count.subscribe(val => {
    console.log('count赋值', val);
  })
</script>
```

```javascript
import { writable } from 'svelte/store';

export const count = writable(1 ,(set, update) => {
  set(100);
});
```

![](/images/svelte/11-6.gif)
相当于在初始化数据时调用了set。

##### update

```javascript
import { writable } from 'svelte/store';

export const count = writable(1 ,(set, update) => {
  update(value => value + 100);
});
```

![](/images/svelte/11-7.gif)  
相当于在初始化数据时调用了update。

##### return () => void
```javascript
// store.js
import { writable } from 'svelte/store';

export const count = writable(1 ,(set, update) => {
  console.log('writable init');
  return () => {
    console.log('unsubscribe');
  }
});
```

```html
<script>
// App.svelte
  import { count } from './store';

  const unsubscribe = count.subscribe(val => {
    console.log('count赋值', val);
  });
</script>

<button on:click={unsubscribe}>unsubscribe</button>
```

![](/images/svelte/11-8.gif)

### 可读状态 readable

```typescript
function readable<T>(
  value?: T | undefined,
  start?: StartStopNotifier<T> | undefined
): Readable<T>;
```

用来设置一些无法从外部更改的状态。
```javascript
import { readable } from 'svelte/store'

export const count = readable(0);
```

```html
<script>
  import { count } from './store';

  count.subscribe(value => {
    console.log('readable count subscribe', value);
  });

  console.log('store', count);
</script>
```
![](/images/svelte/11-10.png)  
我们将`readable`store打印出来后，可以看到同样是一个对象，然而这个对象内只有`subscribe`方法。可读状态的第二个参数的功能和可写状态一样，这个参数是一个用于数据更新的方法，我们虽然不能从外部更改状态，但我们可以在这个方法内部调用`set`或者`update`来更新数据；同样执行了`subscribe`方法后得到一个用于取消订阅的方法。

```javascript
// store.js
import { readable } from 'svelte/store'

export const count = readable(0, (set, update) => {
  let interval = null;

  setInterval(() => {
    update(val => val + 2);
  }, 1000);

  return () => {
    clearInterval(interval);
    console.log('stop!!!');
  }
});
```

```html
<script>
// App.svelte
  import { count } from './store';

  let _count;

  const stop = count.subscribe(value => {
    console.log('count', value);
    _count = value;
  });

</script>

<button on:click={stop}>stop</button>
{_count}
```

![](/images/svelte/11-11.gif)

### 派生状态 derived

#### 单一状态派生
如果读者接触过React或Vue，那可以把`derived`看做是React的`useMemo`、Vue的`computed`。简单的来说，就是将一种状态转换计算成另一种状态。比如我们可以把1变成2，把猫变成狗……只要是我们想改，就能在原来状态不改动的情况下，派生出另一种新状态，而且这个新状态每次都会在你原来状态更新时，根据设定好的逻辑进行更新。
举个例子吧：
```javascript
// store.js
import { writable, derived } from 'svelte/store'

export const count = writable(0);

export const double = derived(count, (value) => {
  console.log('value params', value);
  return value * 2;
});
```

```html
<script>
  // App.svelte
  import { count, double } from './store';

  double.subscribe(val => {
    console.log('double', val);
  });

  console.log('derived store', double);
</script>

<button on:click={() => count.update(val => val + 1)}>add</button>
```

![](/images/svelte/11-12.gif)
我们可以看到，`derived`store也是一个可读状态的store。对外只有`subscribe`属性。

看一下类型定义吧：
```typescript
function derived<S extends Stores, T>(
  stores: S,
  fn: (
    values: StoresValues<S>,
    set: (value: T) => void,
    update: (fn: Updater<T>) => void
  ) => Unsubscriber | void,
  initial_value?: T | undefined
): Readable<T>;
```

```typescript
function derived<S extends Stores, T>(
  stores: S,
  fn: (values: StoresValues<S>) => T,
  initial_value?: T | undefined
): Readable<T>;
```
也就是说`derived`接收两个或三个参数。第一个参数是我们声明的store，第二个参数是一个方法，方法的第一个参数是store的值，我们从上图的打印结果便可以看出来，'value params'打印出来的是普通的值，剩余的`set`和`update`参数老生常谈了，用来给数据更新的方法。

#### 多个状态派生
我们如何从多个不同的store中派生出独有的状态？很简单，derived的第一个参数接收一个数组，然后第二个参数方法的参数里用数组的形式对值进行解构。
还是举个例子比较直观：

```javascript
import { writable, derived } from 'svelte/store'

export const children = writable([
  {
    id: 1,
    name: '小明',
  }, {
    id: 2,
    name: '小红',
  }, {
    id: 3,
    name: '小刚',
  }, {
    id: 4,
    name: '小丽',
  }
]);

export const todos = writable([2, 3, 4]);

export const status = derived([children, todos], ([c, t], set) => {
  const newChildren = c.map(item => {
    if (t.includes(item.id)) {
      return {
        ...item,
        status: 'todo'
      }
    }
    return {
      ...item,
      status: 'done'
    }
  });
  set(newChildren);
});
```

```html
<script>
  import { status } from './store';

  let list = [];

  status.subscribe(val => {
    list = val;
  })
</script>

<ul>
  {#each list as item}
    <li>{item.name}: {item.status}</li>
  {/each}
</ul>
```

![](/images/svelte/11-13.png)  
在这个例子中，我们有两个store，一个专门用来存储姓名信息，另一个则记录哪些人的状态是待办状态。通过派生，我们能够得到一个新的有完整状态数据的数据。

## 自动订阅

在介绍可写状态和可读状态时，我们了解了如何使用store和取消订阅store的更新。然而每次需要手动地执行赋值更新操作和时刻关注取消订阅的行为实在过于繁琐，如果读者跟着操作了上述的所有例子，会发现笔者要在页面上更新数据时，都放在了subscribe数据里进行赋值更新，这是笔者特意为之。
为了处理这种繁琐的操作，Svelte提供了一种快捷的方式来处理这一问题：每当引用store时，都可以通过在store变量前面加上`$`字符来访问store在组件内部的值，并且在适当的时机自动取消订阅。

```javascript
import { writable } from 'svelte/store';

export const count = writable(0);
```

```html
<script>
  import { count } from './store';
</script>

<button on:click={() => count.update(value => value + 1)}>add</button>
{$count}
```

![](/images/svelte/11-14.gif)

我们需要注意的是，这里的`$`的运用和`$: 语句或表达式`的运用是两个不同的概念。笔者贴心提示：为了防止带`$`的变量和正常变量搞混，我们最好将我们声明的store变量用固定格式表示，比如：
```javascript
import { writable } from 'svelte/store';

export const countStore = writable(0);
```

```html
<script>
  import { countStore } from './store';
</script>

<button on:click={() => countStore.update(value => value + 1)}>add</button>
{$countStore}
```

这样每当我们遇到xxxStore格式的变量时，我们便能直接使用`$store`的快捷方式，也不容易和页面上其他变量搞混。

## 自定义store

只要一个对象能够正确地实现subscribe方法，它即是一个store。除了之外，怎样都行。

首先我们使用`writable`来封装我们的store：
```javascript
// store.js
import { writable } from 'svelte/store';

const createCountStore = () => {
  const { subscribe, update } = writable(0);

  return {
    subscribe,
    add: () => update(v => v + 1),
    sub: () => update(v => v - 1),
  }
}

export const countStore = createCountStore();
```

```html
<script>
  import { countStore } from './store';
</script>

<button on:click={countStore.add}>add</button>
<button on:click={countStore.sub}>sub</button>
count: {$countStore}
```

![](/images/svelte/11-15.gif)

接下来，我们直接自定义实现store：
```javascript
// store.js
class Store {
  constructor(initialValue = null) {
    this.value = initialValue;
    this.callbacks = [];
  }
  subscribe(callback) {
    callback(this.value);
    this.callbacks.push(callback);
    return () => this.unsubscribe(callback)
  }

  unsubscribe(callback) {
    this.callbacks = this.callbacks.filter(cb => cb !== callback);
  }

  set(value) {
    this.value = value;

    for (const callback of this.callbacks) {
      callback(this.value);
    }
  }

  update(fn) {
    this.value = fn(this.value);

    for (const callback of this.callbacks) {
      callback(this.value);
    }
  }
}

export const store = new Store(0);
```

```html
<script>
  import { store } from './store';

  const onAdd = () => {
    store.update(val => val + 1);
  }

  const onReset = () => {
    store.set(0);
  }
</script>

<button on:click={onAdd}>add</button>
<button on:click={onReset}>reset</button>
count: {$store}
```

![](/images/svelte/11-16.gif)

## 第三方库

### RxJS
[RxJS](https://rxjs.dev/)是一个使用`Observables`进行响应式编程（reactive programming）的库，可以更轻松地编写异步或基于回调的代码。
RxJS使用[Observables](https://rxjs.dev/guide/observable)声明的对象拥有`subscribe`方法，而Svelte的store同样拥有`subscribe`方法，这使得它非常适合与RxJS集成。简而言之，我们可以利用整个RxJS生态系统和API来操作Svelte的数据流。

```bash
npm install rxjs
```

```javascript
// store.js
import { readable } from 'svelte/store';

export default readable({x:0, y:0}, (set) => {
	document.body.addEventListener("mousemove", move);
	
	function move(event) {
		set({
			x: event.clientX,
			y: event.clientY,
		});
	}
	
	return () => {
		document.body.removeEventListener("mousemove", move);
	}
});
```

```html
<script>
  import { fromEvent, Observable, zip } from "rxjs";
  import { map, pluck } from "rxjs/operators";

  import mousePositionStore from "./store";

  const mousePosition = fromEvent(document, "mousemove").pipe(
    map((event) => ({ x: event.clientX, y: event.clientY }))
  );

  function toObservable(store) {
    let unsub;
    const obs = new Observable((observer) => {
      unsub = store.subscribe((value) => observer.next(value));
      return () => {
        unsub();
      };
    });
    return obs;
  }

  const x$ = toObservable(mousePositionStore).pipe(pluck("x"));
  const y$ = toObservable(mousePositionStore).pipe(pluck("y"));
  const sumOfXAnadY = zip(x$, y$).pipe(map(([x, y]) => x + y));

</script>

{JSON.stringify($mousePosition)}
{$sumOfXAnadY}

<style>
  :global(body) {
    width: 100vw;
    height: 100vh;
  }
</style>
```
通过自定义的`toObservable`方法，将svelte/store转成`Observable`对象，之后便能正常调用RxJS的api。

![](/images/svelte/11-17.gif)

### Immer
[Immer](https://immerjs.github.io/immer/)是一个`immutable`库，核心实现是利用ES6的proxy实现了 js的不可变数据结构，简单易用、体量小巧，能够很好地满足开发者对JS不可变数据结构的需求。

```bash
npm install immer
```

```javascript
import { writable } from "svelte/store";
import { produce } from "immer";

const immerStore = (value) => {
  const store = writable(value);

  function set(new_value) {
    if (new_value !== value) {
      store.set((value = new_value));
    }
  }

  return {
    set,
    update: (fn) => set(produce(value, fn)),
    subscribe: store.subscribe,
  };
};

export const store = immerStore({ visible: true, count: 0 });
```

```html
<svelte:options immutable={true} />

<script>
  import { store } from "./store";

  function toggleVisibility(isVisible) {
    store.update(($state) => {
      $state.visible = isVisible;
    });
  }
  function changeCount(count) {
    store.update(($state) => {
      $state.count += count;
    });
  }

</script>

<div class="buttons">
  <button on:click={() => toggleVisibility(true)}>Show</button>
  <button on:click={() => toggleVisibility(false)}>Hide</button>
</div>
<div class="buttons">
  <button on:click={() => changeCount(1)}>+</button>
  <button on:click={() => changeCount(-1)}>-</button>
</div>

count: {$store.count}
{#if $store.visible}
  <p>Hello world</p>
{/if}

<style>
  button {
    width: 80px;
    height: 35px;
    text-align: center;
  }
</style>
```

![](/images/svelte/11-18.gif)

### XState

[XState](https://xstate.js.org/)是一个轻量级状态管理库，用来描述、控制各种状态。严格意义上说，XState才是真正的状态管理工具，开发者需要通过状态切换去控制数据的变化。
 
```bash
npm i xstate @xstate/svelte
```

笔者使用的`@xstate/svelte`版本："^3.0.2"

```html
<script>
  import { useMachine, useSelector } from '@xstate/svelte';
  import { countMachine } from './store';
  
  const { send, actorRef } = useMachine(countMachine);

  const state = useSelector(actorRef, (selector) => {
    return selector.context;
  });
</script>


<button on:click={() => send({ type: 'ADD' })}>
  ADD
</button>
<button on:click={() => send({ type: 'SUB' })}>
  SUB
</button>

{$state.count}
```

```javascript
import { createMachine, assign } from "xstate";

export const countMachine = createMachine({
  id: "counter",
  context: {
    count: 0
  },
  initial: 'active',
  states: {
    active: {
      on: {
        ADD: {
          actions: assign({
            count: ({ context }) => context.count + 1
          })
        },
        SUB: {
          actions: assign({
            count: ({ context }) => context.count - 1
          })
        }
      }
    }
  },
});
```
![](/images/svelte/11-9.gif)

## 小结

本章我们学习了：
- `svelte/store`的三个方法`writable`、`readable`、`derived`的使用。
- store值上`subscribe`、`set`、`update`方法的区别。
- 当我们使用store的`subscribe`订阅了更新后，在组件销毁时要及时取消订阅
- 使用`$store`的形式帮助我们快捷方便地自动订阅更新和取消订阅
- 如何用自定义的代码来模拟实现store
- `svelte/store`和第三方库如Rxjs、Immer、XState等的结合使用
- `readonly`和`get`在本章没有演示，感兴趣的读者可自行了解。---
title: Svelte从入门到精通——跨组件传值
description: 【进阶篇】跨组件传值
---

在《组件与属性》一章中，我们了解了父子组件之间的传值通信方式。然而这在正常的开发中远远不够，我们可能会遇到在最顶部的组件的状态传递给最里层的组件，最常见的需求便是系统主题颜色的切换。如果使用父子传值的方式来层层传递，显然过于累赘。这里，我们期望数据能够从一个组件中直接传递到另一个组件当中，不管这个组件在哪。Svelte为我们提供了`setContext`和`getContext`来帮助我们实现这一能力。

## context="module"
在了解`setContext`和`getContext`之前，我们来了解一下`context="module"`。

```html
<script context="module">
  console.log('context module');
</script>

<script>
  console.log('log');
</script>

<div>context module</div>
```

我们定义了一个组件，内容如上。我们再定义两个页面，分别引用这个组件。再定义一个页面，引用这两个页面和这一个组件。结构如下：
```text
App.svelte
  Page1.svelte
    Context.svelte
  Page2.svelte
    Context.svelte
  Context.svelte
```
![](/images/svelte/12-1.png)
可以看到，`context="module"`内的内容只执行了一次。因为`context="module"`的script的内容只会在组件第一次执行的时候运行，而不会在组件每次被引用时执行。
我们可以在这个模块中导出一些通用常量或通用方法，但是要注意，切勿使用`export default`，因为`export default`的永远是组件本身。同时定义在`context="module"`里的变量不是响应性的。

重新修改上述例子：
```html
<script context="module">
  // Context.svelte
  console.log('context module');
  let count = 0;

  export function setCount(val) {
    count = val;
    console.log('setCount called', count);
  }
</script>

<script>
  console.log('log');

</script>

<div>context module {count}</div>
```

```html
<script>
// Page1.svelte or Page2.svelte
  import Context, { setCount } from "./Context.svelte";
</script>

<button on:click={() => setCount(2)}>page 1 setCount</button> <Context />
```

```html
<script>
// App.svelte
  import Page1 from './Page1.svelte';
  import Page2 from './Page2.svelte';
  import Context, {setCount} from './Context.svelte';
</script>

<Page1 />
<Page2 />
<button on:click={() => setCount(10)}>app page setCount</button><Context />
```

![](/images/svelte/12-2.gif)  
可以看到，虽然count有被更新，但页面是不会更新的。

## context

Svelte提供了`setContext`和`getContext`来实现跨层级的组件传值能力。其中`setContext`用于存储需要跨组件传值的数据，`getContext`则用于获取对应的数据。

### setContext

```typescript
function setContext<T>(key: any, context: T): T;
```
`setContext`接收两个参数，第一个参数key可以使用任何类型的值作为键，第二个参数则是准备用于传递的数据。

```html
<script>
  // Father.svelte
  import { setContext } from 'svelte';
  import Child from './Child.svelte';

  export const numContext = setContext(1, 1);
  export const strContext = setContext('svelte', 1);
  export const boolContext = setContext(false, 1);
  export const objContext = setContext({}, 1);
  export const funcContext = setContext(function() {}, 1);
  export const symbolContext = setContext(Symbol(), 1);
</script>

<Child />
```

```html
<script>
  // Child.svelte
  import GrandSon from "./GrandSon.svelte";
</script>

<GrandSon />
```

```html
<script>
  // GrandSon.svelte
  import { getContext } from 'svelte';

  export const numContextValue = getContext(1);
  export const strContextValue = getContext('svelte');
  export const boolContextValue = getContext(false);
  export const objContextValue = getContext({});
  export const funcContextValue = getContext(function() {});
  export const symbolContextValue = getContext(Symbol());
</script>

<div>孙组件</div>
<ul>
  <li>number key: {numContextValue}</li>
  <li>string key: {strContextValue}</li>
  <li>boolean key: {boolContextValue}</li>
  <li>object key: {objContextValue}</li>
  <li>function key: {funcContextValue}</li>
  <li>symbol key: {symbolContextValue}</li>
</ul>
```

![](/images/svelte/12-3.png)  
然而我们得到却是，用对象、方法和`Symbol`来声明的key没有拿到值。这是为什么呢？  
如果接触过javascript的基本类型和引用类型的读者，马上便能想到：`{}`相当于重新声明了一个对象，`function() {}`的声明亦是如此，虽然他们看上去一样，但早已“物是人非”。而`Symbol`则是由于它的独特性，用来声明一个独一无二的值。

![](/images/svelte/12-4.png)

### getContext
```typescript
function getContext<T>(key: any): T;
```

如何让对象、方法、`Symbol`类型的key也生效呢？对于这些定义好了就不再改变的值，我们可以使用到开篇讲解的`context="module"`了。
修改代码逻辑：
```html
<script context="module">
  // App.svelte
  export let objKey = {};
  export let funcKey = function() {};
  export let symbolKey = Symbol();
</script>

<script>
  import { setContext } from 'svelte';
  import Child from './Child.svelte';

  export const numContext = setContext(1, 1);
  export const strContext = setContext('svelte', 1);
  export const boolContext = setContext(false, 1);
  export const objContext = setContext(objKey, 1);
  export const funcContext = setContext(funcKey, 1);
  export const symbolContext = setContext(symbolKey, 1);
</script>

<Child />
```

```html
<script>
  // GrandSon.svelte
  import { objKey, funcKey, symbolKey } from './App.svelte';
  import { getContext } from 'svelte';

  export const numContextValue = getContext(1);
  export const strContextValue = getContext('svelte');
  export const boolContextValue = getContext(false);
  export const objContextValue = getContext(objKey);
  export const funcContextValue = getContext(funcKey);
  export const symbolContextValue = getContext(symbolKey);
</script>

<div>孙组件</div>
<ul>
  <li>number key: {numContextValue}</li>
  <li>string key: {strContextValue}</li>
  <li>boolean key: {boolContextValue}</li>
  <li>object key: {objContextValue}</li>
  <li>function key: {funcContextValue}</li>
  <li>symbol key: {symbolContextValue}</li>
</ul>
```
![](/images/svelte/12-5.png)

### 响应性
context本身并不具有响应性。如果我们需要让在context中的值具有响应性，我们需要将store传递到context中。

接下来笔者将演示一个结合多个知识点的例子：
```html
<script context="module">
  // App.svelte
  export let ColorContextKey = Symbol();
</script>

<script>
  import { setContext } from 'svelte';
  import { colorStore } from './store';
  import Child from './Child.svelte';

  setContext(ColorContextKey, colorStore); // 传值是一个store
</script>

<Child />

切换颜色
<select bind:value={$colorStore}>
  <option value="gray">灰色</option>
  <option value="red">红色</option>
  <option value="yellow">黄色</option>
  <option value="orange">橙色</option>
</select>
```

```html
<script>
  // Child.svelte
  import Rect from './Rect.svelte';
  import Circle from './Circle.svelte';
</script>

<section>
  <h2>方形组件</h2>
  <Rect />
</section>
<section>
  <h2>圆形组件</h2>
  <Circle />
</section>
```

```html
<script>
  // Rect.svelte
  import { getContext } from 'svelte';
  import { ColorContextKey } from './App.svelte';

  let colorStore = getContext(ColorContextKey);
  $: style = `background-color: ${$colorStore}`;
</script>

<div class="rect" {style}></div>

<style>
  .rect {
    width: 100px;
    height: 100px;
  }
</style>
```

```html
<script>
  // Circle.svelte
  import { getContext } from 'svelte';
  import { ColorContextKey } from './App.svelte';

  let colorStore = getContext(ColorContextKey);
  $: style = `background-color: ${$colorStore}`;
</script>

<div class="circle" {style}></div>

<style>
  .circle {
    width: 100px;
    height: 100px;
    border-radius: 50%;
  }
</style>
```
我们的App.svelte中具有控制组件切换颜色的方法，每个组件接收context的store值，监听store的变换，然后更改组件的行内样式。

![](/images/svelte/12-6.gif)
这个例子里，我们使用了`getContext`、`setContext`、`$:`、`context="module"`、属性赋值简写等知识点。

## 小结

本章我们学习了：
- `context="module"`的作用
- 使用Svelte提供的`setContext`和`getContext`帮助我们实现跨层级传静态值的能力。再结合`svelte/store`使用，可以传递动态变量。
---
title: Svelte从入门到精通——动画
description: 【进阶篇】动画
---

好看的动画往往能给页面带来锦上添花的效果，不仅能提升用户体验，还能增强页面美观度。流畅丝滑的动效背后，除了开发时的灵感迸发，也需要强有力的数学知识的支持。Svelte中集成了多个服务于动画效果的方法：
- `svelte/motion`
- `svelte/easing`
- `svelte/transition`
- `svelte/animation`


## Motion

Motion指运动效果，`svelte/motion`导出了两个方法`tweened`和`spring`。使用这两个方法得到的值是一个可写状态的store。
  
### Tweened

Tweened即补间动画。补间（动画）（来自 [in-between](https://en.wikipedia.org/wiki/Inbetweening)）是一个概念，允许用户以平滑的方式更改对象的属性。我们只需告诉它哪些属性要更改，当补间结束运行时它们应该具有哪些最终值，以及这需要多长时间，补间引擎将负责计算从起始点到结束点的值。补间动画的状态会在固定的时间间隔内不断更新其值。

比如在我们设置css时，我们设置了元素的起点和终点，而至于过程是怎么运动的，则由电脑来决定。
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        width: 100px;
        height: 100px;
        border: 1px solid orange;
        transition: all 1s ease-in-out;
      }

      .move {
        transform: translate(100px, 100px);
      }
    </style>
  </head>
  <body>
    <button>move</button>
    <div class="box"></div>
    
    <script>
      let button = document.querySelector('button');
      let boxRef = document.querySelector(".box");
      
      button.addEventListener('click', onMove);

      function onMove() {
        if (boxRef) {
          boxRef.classList.add("move");
        } 
      };
    </script>
  </body>
</html>
```

![](/images/svelte/13-1.gif)  
我们只设置了开头和结尾的位置，以及开头运动到结尾需要1s，期间的运动过程则交由底层处理。这种设置方式不管是在设置ppt动画，制作视频剪辑中都非常常见。

笔者先演示一个不带动画的例子：
```html
<script>
  import { writable } from "svelte/store";

  const progress = writable(0);
</script>

<progress value={$progress}></progress>

{#each [0, 0.25, 0.5, 0.75, 1] as p}
  <button on:click={() => ($progress = p)}>
    {p * 100}%
  </button>
{/each}

<style>
  progress {
    display: block;
    width: 100%;
  }
</style>
```

![](/images/svelte/13-2.gif)

当我们使用了补间动画后：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const progress = tweened(0, {
		duration: 300,
		easing: cubicOut
	});
</script>

<progress value={$progress}></progress>

{#each [0, 0.25, 0.5, 0.75, 1] as p}
  <button on:click={() => ($progress = p)}>
    {p * 100}%
  </button>
{/each}

<style>
  progress {
    display: block;
    width: 100%;
  }
</style>
```
因为返回值是一个store，我们可以像正常使用store一样使用`$store`。

![](/images/svelte/13-3.gif)

看下`tweened`的接收参数：
```typescript
function tweened<T>(
  value?: T | undefined,
  defaults?: TweenedOptions<T> | undefined
): Tweened<T>;
```
第一个参数接收一个初始值，第二个参数稍微复杂，是一个对象，能够接收以下参数：
- delay：补间延迟多少毫秒之后开始
- duration：补间效果的持续时间（以毫秒为单位）
- easing：在下一节中详细讲解
- interpolate：一个自定义的(starting, target) => t => value函数，用于在任意值之间进行插值。starting是起始值，target是目标值，t是0到1的数值，value是返回结果。

#### interpolate

interpolate是“插值”的意思，默认情况下，Svelte将在数字、日期以及形状相同的数组和对象之间进行插值（只要它们仅包含数字和日期或其他有效的数组和对象）。如果我们想要插值颜色字符串或变换矩阵，需要我们自己提供自定义插值器。

比如，我们将数组进行转换：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const arr = tweened([1, 2, 3, 4, 5], {
		duration: 500,
		easing: cubicOut
	});
</script>

<button on:click={() => $arr = [6, 7, 8, 9, 10]}>change</button>

{#each $arr as item}
  <div>{item}</div>
{/each}
```
  
![](/images/svelte/13-4.gif)  
这里的gif图由于帧率问题，只看出了几次变化，然而我们真实的页面改动频率则高得多。

再比如，如果我们需要进行颜色改变的补间动画，会使用到[d3-interpolate](https://d3js.org/d3-interpolate)：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicInOut } from 'svelte/easing';
  import { interpolate } from "d3-interpolate";

  let colors = ['red', 'blue', 'green', 'pink'];
  let color = tweened('red', {
    duration: 1000,
    easing: cubicInOut,
    interpolate: interpolate,
  });

  const changeColor = (c) => {
    $color = c;
  }
</script>

{#each colors as color}
  <button on:click={() => changeColor(color)}>{color}</button>  
{/each}
<h2 style="color: {$color}">{$color}</h2>
```

![](/images/svelte/13-5.gif)

interpolate的要求必须是`(a, b) => t => value`格式的函数，我们简单看下各参数的意义：
```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const value = tweened(0, {
		duration: 500,
		easing: cubicOut,
    interpolate: (a, b) => {
      console.log('a,b', a, b)
      return (t) => {
        console.log('t', t);
        return t;
      }
    }
	});
</script>

<button on:click={() => $value = 100}>change</button>
<h1>{$value}</h1>
```
![](/images/svelte/13-6.gif)
从打印的结果中，我们可以推断出，a是初始值，b是下一次更改的值，t是百分率，关键就在于t。
通过t的变化，我们可以丝滑地改动我们的变化值，当最终值无法超过b。

```diff
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from 'svelte/easing';

	const value = tweened(0, {
		duration: 500,
		easing: cubicOut,
    interpolate: (a, b) => {
      console.log('a,b', a, b)
      return (t) => {
        console.log('t', t);
-       return t;
+       return (b - a) * t;
      }
    }
	});
</script>

<button on:click={() => $value = 100}>change</button>
<h1>{$value}</h1>
```
![](/images/svelte/13-7.gif)

感兴趣的读者可以阅读下[interpolation](https://paulbourke.net/miscellaneous/interpolation/)。

#### tween.js

我们可以使用其他补间动画库如[tween.js](https://github.com/tweenjs/tween.js/tree/main)来完成的补间动画。

```html
<script>
  import { tweened } from "svelte/motion";
  import { cubicOut } from "svelte/easing";

  const size = tweened(1, {
    duration: 400,
    easing: cubicOut,
  });

  const scale1 = () => {
    $size += 1;
  };
</script>

<button on:click={scale1}> scale </button>
<div class="box" style="transform: scale({$size}); transform-origin: 0 0"></div>

<style>
  .box {
    width: 100px;
    height: 100px;
    background: red;
    border-radius: 50%;
    margin-bottom: 100px;
  }
</style>
```
![](/images/svelte/13-8.gif)  
这是一个正常使用Svelte的tween的例子，如果我们使用tween.js来实现，则需要：
```html
<script>
  import * as TWEEN from "@tweenjs/tween.js";
  
  let size2 = 1;
  let size2Tweened = size2;

  const scale2 = () => {
    let oldSize2 = size2;
    size2 += 1;
    new TWEEN.Tween({
      value: oldSize2,
    })
      .to({ value: size2 }, 400)
      .easing(TWEEN.Easing.Cubic.Out)
      .start().onUpdate(({value}) => {
        size2Tweened = value;
      });
  };

  animate();

  function animate(time) {
    TWEEN.update(time);
    requestAnimationFrame(animate);
  }
</script>

<button on:click={scale2}> scale2 </button>
<div
  class="box"
  style="transform: scale({size2Tweened}); transform-origin: 0 0"
></div>
```

### Spring

Spring弹性动画可以让UI交互的效果更接近我们的日常生活，比起像补间动画那样程序式地平滑改动，弹性动画可以运用弹性的物理特性，来让物体运动表现得更为自然生动。

spring方法的参数如下：
```typescript
function spring<T = any>(
  value?: T | undefined,
  opts?: SpringOpts | undefined
): Spring<T>;
```

同样参数value是初始值，opts是一个对象，该对象有以下属性：
- `stiffness`：表示刚度，其值介于0和1之间，默认是0.15，值越高表示弹簧越紧，从起始值到目标值的速度更快。
- `damping`：表示阻尼，其值介于0和1之间，默认是0.8，值越低表示弹跳阻尼越小，弹跳效果更明显。
- `precision`：表示精度，弹跳被认为处于静止状态的阈值，越低则越精确。

`tweened()`和`spring()`都有着与store相同的`set()`、`update()`方法，实际上，`tweened()`和`spring()`就是在《状态管理》章节中介绍过的custom store。

#### stifiness

```html
<script>
  import { spring } from 'svelte/motion';

  let springStore1 = spring(0, {
    stiffness: 0.15 // 默认
  });
  let springStore2 = spring(0, {
    stiffness: 0.5
  })
  let springStore3 = spring(0, {
    stiffness: 0.8
  })

  const change = () => {
    $springStore1 += 500;
    $springStore2 += 500;
    $springStore3 += 500;
  }

  $: style1 = `transform:translateX(${$springStore1}px)`;
  $: style2 = `transform:translateX(${$springStore2}px)`;
  $: style3 = `transform:translateX(${$springStore3}px)`;
</script>

<button on:click={change}>move</button>
<div class="ball red" style={style1}></div>
<div class="ball blue" style={style2}></div>
<div class="ball green" style={style3}></div>

<style>
  .ball {
    width: 50px;
    height: 50px;
    border-radius: 50%;
  }
  .red {
    background: tomato;
  }
  .blue {
    background: aqua;
  }
  .green {
    background: greenyellow;
  }
</style>
```
![stifiness](/images/svelte/13-30.gif)
第一个小球的刚度是默认的0.15，最慢到达终点，第三个小球的刚度最大，最快到达终点。

#### damping

将上一个例子的代码进行稍微改动
```javascript
let springStore1 = spring(0, {
  damping: 0.8 // 默认
});
let springStore2 = spring(0, {
  damping: 0.5
})
let springStore3 = spring(0, {
  damping: 0.2
})
```
![damping](/images/svelte/13-31.gif)  
第三个的阻尼最小，晃动最明显。

#### precision

```javascript
let springStore1 = spring(0, {
  precision: 0.01, // 默认
  damping: 0.2
});
let springStore2 = spring(0, {
  precision: 10,
  damping: 0.2
});
let springStore3 = spring(0, {
  precision: 100,
  damping: 0.2
});
```

![precision](/images/svelte/13-32.gif)  
当我们设置的精度越大时，弹簧的晃动效果越快进入到平稳状态。

## Easing

在CSS中，我们通常会设置诸如`transition: all 1s ease`、`animation: animationEffect 0.5s ease` 等来实现过渡或者动画效果，而在`svelte/motion`的`tweened`方法中，我们也接触到了一个参数`easing`，在这一小节，我们来了解一下“计时函数”（timing-function）。

CSS 中的 `<timing-function>`是一个（数学）函数，它被用来指定物体随着时间的推移，从一个值转换到另一个值时速度。 它描述了过渡或动画将如何在其持续时间的一个周期内进行。timing-function也称为[easing-function](https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function)。

计时函数通常作为[transition-timing-function](https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function)属性和[animation-timing-function](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function)属性的值来使用。

在CSS中支持使用3种方式来定义计时函数：
- 使用预定义的关键字
- 使用步进函数
- 使用cubic-bezier函数（三次贝塞尔曲线函数）

```text
<timing-function> = ease | linear | ease-in | ease-out | ease-in-out |
step-start | step-end | steps(<integer>[, [ start | end ] ]?) |
cubic-bezier(<number>, <number>, <number>, <number>)
```

也就是说我们设置效果时可以这样：
```css
transition: all 1s ease;
transition: all 1s steps();
transition: all 1s cubic-bezier()
```

### cubic-bezier

我们可以自定义三次贝塞尔曲线来创建自定义缓动效果甚至弹跳效果。感兴趣的读者可研读[贝塞尔曲线](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)的实现。

#### 预定义关键字

CSS中的预定义关键字的timing-function有：`ease | linear | ease-in | ease-out | ease-in-out`，其实它们都是贝塞尔曲线的特定实现。
```css
ease: cubic-bezier(0.25, 0.1, 0.25, 1.0)
linear: cubic-bezier(0.0, 0.0, 1.0, 1.0)
ease-in: cubic-bezier(0.42, 0, 1.0, 1.0)
ease-out: cubic-bezier(0, 0, 0.58, 1.0)
ease-in-out: cubic-bezier(0.42, 0, 0.58, 1.0)
```

```html
<script>
  let animating = false;
  const startMove = () => {
    animating = true;
  }
</script>

<button on:click={startMove}>animate</button>
<div class="ball red-ball" class:ease={animating}></div>
<div class="ball red-ball" class:ease-cubic={animating}></div>
<div class="ball green-ball" class:linear={animating}></div>
<div class="ball green-ball" class:linear-cubic={animating}></div>

<style>
  .ball {
    width: 50px;
    height: 50px;
    border-radius: 50%;
  }
  .red-ball {
    background-color: red;
  }
  .green-ball {
    background-color: aquamarine;
  }

  .ease {
    animation: moveEffect 2s ease;
    animation-iteration-count: infinite;
  }
  .ease-cubic {
    animation: moveEffect 2s cubic-bezier(0.25, 0.1, 0.25, 1.0);
    animation-iteration-count: infinite;
  }
  .linear {
    animation: moveEffect 2s linear;
    animation-iteration-count: infinite;
  }
  .linear-cubic {
    animation: moveEffect 2s cubic-bezier(0.0, 0.0, 1.0, 1.0);
    animation-iteration-count: infinite;
  }

  @keyframes moveEffect {
    0% {
      transform: translateX(0);
    }
    50% {
      transform: translateX(200px);
    }
    100% {
      transform: translateX(0);
    }
  }
</style>
```

![](/images/svelte/13-9.gif)
#### 工具

我们可以在[easings.net]( https://easings.net/)中查看关键字和贝塞尔曲线之间的转换。

比如我们选择[easeOutCirc](https://easings.net/#easeOutCirc)：
![](/images/svelte/13-33.png)

它对应的公式如下：
```javascript
function easeOutCirc(x: number): number {
  return Math.sqrt(1 - Math.pow(x - 1, 2));
}
```

再看`packages/svelte/src/runtime/easing/index.js`中的：
```javascript
export function circOut(t) {
	return Math.sqrt(1 - --t * t);
}
```
发现和easing.net上的实现无异。

除了easing.net，网络上有大量方便的贝塞尔曲线工具网站，比如[cubic-bezier.com](https://cubic-bezier.com/#.17,.67,.83,.67)和[ceaser](https://matthewlein.com/tools/ceaser)等，读者可自行探索。

### svelte/easing
在Svelte中，`svelte/easing`中实现了大量的缓动效果：
![](/images/svelte/13-10.png)

![alt text](/images/svelte/13-34.png)
我们查看源码，可以看到缓动函数的实现是复用了[eases](https://github.com/mattdesl/eases)这个库，而这个库的灵感则来自[Robert Penner's easing equations](http://robertpenner.com/easing/)和[glsl-easings](https://github.com/glslify/glsl-easings)。

## Transition

### svelte/transition

`svelte/transition`顾名思义，用来处理过渡效果，它导出了以下函数：
- fade
- blur
- fly
- slide
- scale
- draw
- crossfade

`svelte/transition`导出的方法可以结合`transition:fn`指令进行使用使用。

#### fade
`fade`的类型定义如下：
```typescript
function fade(
	node: Element,
	{ delay, duration, easing }?: FadeParams | undefined
): TransitionConfig;
```

演示例子：
```html
<script>
  import { fade } from "svelte/transition";
  import { cubicInOut } from "svelte/easing";

  let show = true;
</script>

<button on:click={() => (show = !show)}>toggle</button>

{#if show}
  <div
    class="ball"
    transition:fade={{
      easing: cubicInOut,
      duration: 1000,
    }}
  ></div>
{/if}

<style>
  .ball {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: tomato;
  }
</style>
```

![](/images/svelte/13-12.gif)

fade是通过修改元素节点的opacity透明度来实现动画效果。
![](/images/svelte/13-11.png)
我们在使用`transition`指令时，也可以直接不传参数`<div transition:fade></div>`，因为方法内部提供了默认值。如`fade`方法的`delay`默认0，`duration`默认400ms，`easing`默认使用`linear`。
#### blur
`blur`方法的类型定义：
```typescript
function blur(
	node: Element,
	{
		delay,
		duration,
		easing,
		amount,
		opacity
	}?: BlurParams | undefined
): TransitionConfig;
```

- opacity：透明度开始显示或透明度准备结束的那个节点的值。比如我们设置了opacity为0.5，那动画就会直接从0.5到1开始和从1到0.5结束，0到0.5这个区间的变化不存在缓动效果。
- amount：可以理解为blur的模糊程度，默认是5，值越大越模糊。

```html
<script>
  import { blur } from "svelte/transition";
  import { cubicInOut } from "svelte/easing";

  let show = true;
</script>

<button on:click={() => (show = !show)}>toggle</button>

{#if show}
  <div
    class="ball"
    transition:blur={{
      easing: cubicInOut,
      duration: 1000,
    }}
  ></div>
{/if}
```

![](/images/svelte/13-13.gif)

当我们设置了`amount`和`opacity`之后：
```html
{#if show}
  <div
    class="ball"
    transition:blur={{
      easing: cubicInOut,
      duration: 1000,
      amount: 10,
      opacity: 0.5,
    }}
  ></div>
{/if}
```

![](/images/svelte/13-14.gif)
`blur`方法在切换透明度的同时添加一个blur滤镜。
![](/images/svelte/13-15.png)

#### fly
`fly`方法的类型定义如下：
```typescript
function fly(
	node: Element,
	{
		delay,
		duration,
		easing,
		x,
		y,
		opacity
	}?: FlyParams | undefined
): TransitionConfig
```

- opacity：在`blur`中已进行过阐释
- x：元素在水平方向移动的距离。x正数表示元素向右平移。
- y：元素在垂直方向移动的距离。y正数表示元素向下平移。

`fly`方法在设置元素节点的透明度动画的同时，还能控制元素的移动。

```html
{#if show}
  <div
    class="ball"
    transition:fly={{
      easing: cubicInOut,
      duration: 1000,
      x: 200,
      y: 200
    }}
  ></div>
{/if}
```

![](/images/svelte/13-16.gif)

动画效果除了设置opacity，还设置了transform:translate()
![](/images/svelte/13-17.png)

#### slide
`slide`方法的类型定义如下：
```typescript
function slide(
	node: Element,
	{
		delay,
		duration,
		easing,
		axis
	}?: SlideParams | undefined
): TransitionConfig;
```

- axis：接收`x`或`y`作为值，默认`y`。设置从哪个方向滑动。

```html
{#if show}
  <div
    class="ball"
    transition:slide={{
      easing: cubicInOut,
      duration: 1000
    }}
  ></div>
{/if}
```

默认表现：
![](/images/svelte/13-18.gif)

```diff
{#if show}
  <div
    class="ball"
    transition:slide={{
      easing: cubicInOut,
      duration: 1000,
+      axis: 'x'
    }}
  ></div>
{/if}
```
设置成`x`方向：
![](/images/svelte/13-19.gif)

`slide`除了设置opacity，还伴随设置宽高来实现动画效果。
![](/images/svelte/13-20.png)
这也解释了为什么当元素逐渐消失时，如果是垂直方向是从上到下，水平方向是从右到左进行变化。
#### scale
`scale`方法类型定义如下：
```typescript
function scale(
	node: Element,
	{
		delay,
		duration,
		easing,
		start,
		opacity
	}?: ScaleParams | undefined
): TransitionConfig;
```

- start：和opacity的设置作用相似，用于设置一个值，从这个值到1之间存在过渡效果，从0到这个值之间不存在过渡效果。

```html
<script>
  import { scale } from "svelte/transition";
  import { cubicInOut } from "svelte/easing";

  let show = true;
</script>

<button on:click={() => (show = !show)}>toggle</button>


{#if show}
  <div
    class="ball"
    transition:scale={{
      easing: cubicInOut,
      duration: 1000,
    }}
  ></div>
{/if}
```

![](/images/svelte/13-21.gif)

`scale`方法除了设置opacity，还伴随设置`transform:scale()`
![](/images/svelte/13-22.png)
#### draw
专门用来画svg的动画方法，`draw`方法类型定义如下：
```html
<script>
  import { draw } from "svelte/transition";
  import { cubicInOut } from "svelte/easing";

  let show = true;
</script>

<button on:click={() => (show = !show)}>toggle</button>

<svg viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
	{#if show}
		<path
			transition:draw={{ duration: 5000, delay: 500, easing: cubicInOut }}
			d="M25 1 L32 18 L50 18 L36 29 L40 46 L25 36 L10 46 L14 29 L1 18 L18 18 Z"
			fill="none"
			stroke="tomato"
			stroke-width="1px"
			stroke-linejoin="round"
		/>
	{/if}
</svg>
```

![](/images/svelte/13-23.gif)

#### crossfade
不一一讲解了，感兴趣的读者自行探索。

### 指令
`svelte/transition`导出的方法同样可以和`in:fn`和`out:fn`指令结合使用。`in:fn`、`out:fn`和`transition:fn`的区别在于，它细分了过渡的发生时间点。在一个过渡效果的生命周期里，我们把它分为in和out两种时期。
![](/images/svelte/13-24.png)
当元素从显示到隐藏的阶段，我们称其为out，而当元素从隐藏到显示的过渡，我们称其为in。

```html
<script>
  import { scale, fly } from "svelte/transition";
  import { cubicInOut } from "svelte/easing";

  let show = true;
</script>

<button on:click={() => (show = !show)}>toggle</button>


{#if show}
  <div
    class="ball"
    in:scale={{
      easing: cubicInOut
    }}
    out:fly={{
      x: 200,
      y: 200,
      easing: cubicInOut
    }}
  ></div>
{/if}
```

当小球要消失时，我们使用了`out:fly`效果，而当小球要显现出来时，我们使用了`in:scale`。
![](/images/svelte/13-25.gif)
`in`、`out`和`transition`指令一样，可以直接使用`in:fn`、`out:fn`而不传参数。

### 自定义过渡 

自定义过渡方法的api：
```javascript
transition = (node: HTMLElement, params: any) => {
  delay?: number,
  duration?: number,
  easing?: (t: number) => number,
  css?: (t: number, u: number) => string,
  tick?: (t: number, u: number) => void
}
```

比如我们实现一个彩虹颜色变化的过渡效果：
```html
<script>
  import { cubicInOut } from "svelte/easing";

  let show = false;

  function rainbow(node) {
    const colors = [
      "rgba(255, 0, 0, 1)",
      "rgba(255, 154, 0, 1)",
      "rgba(208, 222, 33, 1)",
      "rgba(79, 220, 74, 1)",
      "rgba(63, 218, 216, 1)",
      "rgba(47, 201, 226, 1)",
      "rgba(28, 127, 238, 1)",
      "rgba(95, 21, 242, 1)",
      "rgba(186, 12, 248, 1)",
      "rgba(251, 7, 217, 1)",
      "rgba(255, 0, 0, 1)",
    ];
    return {
      duration: 3500,
      easing: cubicInOut,
      css: (t, v) => {
        return `
          background: ${colors[((t * 10) | 0) - 1]}
        `;
      },
    };
  }
</script>

<button
  on:click={() => {
    show = !show;
  }}>toggle</button
>

{#if show}
  <div class="rainbow-box" transition:rainbow></div>
{/if}

<style>
  .rainbow-box {
    width: 80vw;
    height: 200px;
    border-radius: 5px;
    border: 1px solid black;
  }
</style>
```

数组中的颜色如下：
![](/images/svelte/13-26.png)
我们实现一个彩虹渐变的过渡效果：
![](/images/svelte/13-27.gif)

### 过渡事件

我们可以监听以下过渡效果的事件：
- introstart：进入效果开始
- introend：进入效果结束
- outrostart：退出效果开始
- outroend：退出效果结束

```html
<script>
  import { scale, fly } from "svelte/transition";
  import { cubicInOut } from "svelte/easing";

  let show = true;

  const onIntroStart = () => {
    console.log("intro start");
  };
  const onIntroEnd = () => {
    console.log("intro end");
  };
  const onOutroStart = () => {
    console.log("outro start");
  };
  const onOutroEnd = () => {
    console.log("outro end");
  };
</script>

<button on:click={() => (show = !show)}>toggle</button>

{#if show}
  <div
    class="ball"
    in:scale={{
      easing: cubicInOut,
      duration: 2000,
    }}
    out:fly={{
      x: 200,
      y: 200,
      duration: 2000,
      easing: cubicInOut,
    }}
    on:introstart={onIntroStart}
    on:introend={onIntroEnd}
    on:outrostart={onOutroStart}
    on:outroend={onOutroEnd}
  ></div>
{/if}
```

![](/images/svelte/13-28.gif)

我们在上述的各类演示中，已经知道`svelte/transition`其实是通过控制css的animation来实现过渡的，因此，我们还能通过对js的`animationstart`和`animationend`事件的监听，在动画的开始与结束时执行一些操作。

```html
<script>
  import { scale, fly } from "svelte/transition";
  import { cubicInOut } from "svelte/easing";

  let show = true;

  const onIntroStart = () => {
    console.log("intro start");
  };
  const onIntroEnd = () => {
    console.log("intro end");
  };
  const onOutroStart = () => {
    console.log("outro start");
  };
  const onOutroEnd = () => {
    console.log("outro end");
  };

  const start = () => {
    console.log("animation start");
  };
  const end = () => {
    console.log("animation end");
  };
</script>

<button on:click={() => (show = !show)}>toggle</button>

{#if show}
  <div
    class="ball"
    in:scale={{
      easing: cubicInOut,
      duration: 2000,
    }}
    out:fly={{
      x: 200,
      y: 200,
      duration: 2000,
      easing: cubicInOut,
    }}
    on:introstart={onIntroStart}
    on:introend={onIntroEnd}
    on:outrostart={onOutroStart}
    on:outroend={onOutroEnd}
    on:animationstart={start}
    on:animationend={end}
  ></div>
{/if}
```

![](/images/svelte/13-29.gif)
## Animation

目前`svelte/animation`中只导出了一个方法`flip`
  

## 小结

本章我们学习了：
- `svelte/motion`中导出的两种运动效果：tween补间和spring弹性。一些能提供相同效果的第三方库。
- css的timing-function、easing缓动函数和贝塞尔曲线
- Svelte中提供的各种过渡效果；为过渡效果服务的各种指令`transition:fn`、`in:fn`、`out:fn`；如何自定义过渡效果。
- 监听过渡事件
- 题外话，[robertpenner](http://robertpenner.com/easing/)这个网站提供了很多关于动画实现的细节，感兴趣的读者可以自行探究。

---
title: Svelte从入门到精通——指令
description: 【进阶篇】指令
---

## 动作

`svelte/action`只是创建元素时调用的普通JavaScript函数，通过这个函数，我们能够拿到对元素本身的引用，因此我们可以通过js编程将任何行为附加到该元素。可以理解为在元素的生命周期内进行操作。

一个普通的action用法如下：
```javascript
use:action={parameters}
```

action动作即我们上述所说的js函数，它的定义如下：
```javascript
action = (node: HTMLElement, parameters: any) => {
  update?: (parameters: any) => void,
  destroy?: () => void
}
```
- node参数即元素的引用
- parameters参数即`={parameters}`的值。
- 方法返回一个对象，对象里有以下属性：
  - `update`方法会在元素每次更新时都调用。
  - `destroy`方法在元素销毁时调用。

action只能在正常元素中使用，无法在组件中使用：
![](/images/svelte/14-1.png)

```html
<script>
  function greet(node, params) {
    console.log('hello', params);
  }
</script>

<div use:greet={'app页面'}>app</div>
```

![](/images/svelte/14-2.png)
笔者会为大家带来三个自定义action的演示：分别是`use:clickoutside`、`use:wave`和`use:space`。

#### clickOutside

顾名思义，就是实现在绑定的DOM外事件点击监听的方法。这种功能常见于一些UI弹窗组件中，需要在点击弹窗外部时，关闭弹窗。

```javascript
export const clickOutside = (node: HTMLElement, callback: () => void) => {
  const handleClick = (event: MouseEvent) => {
    if (!event?.target) return;

    if (
      node &&
      !node.contains(event.target as Node) &&
      !event.defaultPrevented
    ) {
      callback();
    }
  };

  document.addEventListener("click", handleClick, true);

  return {
    destroy() {
      document.removeEventListener("click", handleClick, true);
    },
  };
};
```
在document中绑定监听事件，判断`node.contains(event.target)`如果触发事件的对象不是当前绑定的对象，则执行回调。
如果你没有使用`Typescript`，可以把例子中的类型定义给删除。

```html
<script>
  import { clickOutside } from './action';

  const onClickOutside = () => {
    console.log('点击外面');
  }
</script>

<main>
  <div id="box" use:clickOutside={onClickOutside}></div>
</main>

<style>
  main {
    width: 100px;
    height: 100px;
    background: #eeeeee;
    margin: 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #box {
    width: 30px;
    height: 30px;
    background: salmon;
    line-height: 30px;
    text-align: center;
  }
</style>
```

![](14-3.gif)
当我们点击红色区域时，不会打印任何信息，点击红色区域以外，打印出信息。

#### wave

如果读者使用过Antd组件，那在对一些组件诸如Button组件进行点击时，会发现会泛起一层波浪效果的动效：
![](/images/svelte/14-4.gif)

接下来，我们就来实现这个效果：
```javascript
export function wave(ele) {
  let clickWaveTimeoutId;
  let styleForPesudo;

  function getAttributeName() {
    return 'ant-click-animating-without-extra-node';
  }

  function _onClick(node, waveColor) {
    const attributeName = getAttributeName();
    node.removeAttribute(attributeName);
    node.setAttribute(attributeName, 'true');

    styleForPesudo = styleForPesudo || document.createElement('style');
    if (waveColor) {
      styleForPesudo.innerHTML =
        `[ant-click-animating-without-extra-node]:after { border-color: ${waveColor}; }`;
      if (!document.body.contains(styleForPesudo)) {
        document.body.appendChild(styleForPesudo);
      }
    }
    node.addEventListener('animationend', onTransitionEnd);
  }

  function bindAnimationEvent(node) {

    const onClick = (e) => {
      resetEffect(node);
      const waveColor =
        getComputedStyle(node).getPropertyValue('border-top-color') || // Firefox Compatible
        getComputedStyle(node).getPropertyValue('border-color') ||
        getComputedStyle(node).getPropertyValue('background-color');
      clickWaveTimeoutId = window.setTimeout(() => _onClick(node, waveColor), 0);
    };

    node.addEventListener('click', onClick, true);

    return {
      cancel: () => {
        node.removeEventListener('click', onClick, true);
      },
    };
  }

  function resetEffect(node) {
    const attributeName = getAttributeName();
    node.removeAttribute(attributeName);
    removeExtraStyleNode();

    node.removeEventListener('animationend', onTransitionEnd);
  }

  function onTransitionEnd(e) {
    if (!e || e.animationName !== 'fadeEffect') {
      return;
    }
    resetEffect(e.target);
  }

  function removeExtraStyleNode() {
    if (styleForPesudo) {
      styleForPesudo.innerHTML = '';
    }
  }

  bindAnimationEvent(ele);

  return {
    destroy() {
      if (clickWaveTimeoutId) {
        clearTimeout(clickWaveTimeoutId);
      }
    }
  }
}
```

因为Svelte组件内的style是scoped限制的，我们将以下样式代码放到全局：
```css
:root {
  --theme-color: purple;
}

[ant-click-animating-without-extra-node="true"] {
  position: relative;
}

[ant-click-animating-without-extra-node="true"]::after {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  display: block;
  border-radius: inherit;
  box-shadow: 0 0 0 0 var(--theme-color);
  opacity: 0.2;
  animation: fadeEffect 2s cubic-bezier(0.08, 0.82, 0.17, 1),
    waveEffect 0.4s cubic-bezier(0.08, 0.82, 0.17, 1);
  animation-fill-mode: forwards;
  content: "";
  pointer-events: none;
}

@keyframes waveEffect {
  100% {
    box-shadow: 0 0 0 var(--theme-color);
    box-shadow: 0 0 0 6px var(--theme-color);
  }
}

@keyframes fadeEffect {
  100% {
    opacity: 0;
  }
}
```

简单讲解下实现思路：
- 当调用`use:wave`进入到我们的action，执行bindAnimationEvent方法，该方法则是实现波浪动效的入口方法。
- 在bindAnimationEvent方法内，对当前绑定的元素进行点击事件的绑定。
- 当元素进行点击时，先给元素添加`ant-click-animating-without-extra-node`属性，之后再给添加了`ant-click-animating-without-extra-node`属性的元素添加伪类。
- 当添加了伪类后，伪类的样式生效，内部有fadeEffect和waveEffect两种动画，fadeEffect用于设置透明度，waveEffect则是最关键的动画，设置了两种box-shadow。
- 动画结束后，清除`ant-click-animating-without-extra-node`属性，同时移除伪类。

测试一下我们的自定义action：
```html
<script>
  import { wave } from "./action";
</script>

<button use:wave>按钮</button>

<style>
  button {
    width: 100px;
    height: 30px;
  }
</style>
```

![](14-5.gif)

这样我们在不改动原有组件逻辑的情况下，便可以通过使用`use:wave`来添加点击波浪的效果。因此，use非常适合用于拓展一些组件、甚至是第三方库的功能。

这种效果的实现源码，感兴趣的读者可以参考[motion/other.less](https://github.com/ant-design/ant-design/blob/3.26.20/components/style/core/motion/other.less)和[wave](https://github.com/ant-design/ant-design/blob/3.26.20/components/_util/wave.tsx)。

#### space

在前面介绍《插槽》的章节中，我们了解到，在Svelte中并不能劫持`$$slots`来二次定义插槽的内容，那我们便可以使用指令的形式来完成这一操作。
```javascript
// action.js
export function space(node: HTMLElement, spaceClasses: string) {
  const wrap = () => {
    node.childNodes.forEach((element) => {
      if (!element) {
        return;
      }

      if (
        element.nodeType === 3 &&
        (!element.nodeValue || /^\s+$/.test(element.nodeValue))
      ) {
        return;
      }

      if (element.parentNode) {
        const wrapItem = document.createElement("div");

        wrapItem.className = spaceClasses;

        element.parentNode.insertBefore(wrapItem, element);

        wrapItem.appendChild(element);
      }
    });
  };

  wrap();

  return {
    destroy: wrap,
  };
}
```

之后我们在Space组件中使用space的action：
```html
<script>
// Space.svelte
  import { space } from "./action"
  let spaceChildClass = "ant-space-item";

  let spaceClass = "ant-space";
</script>

<div use:space={spaceChildClass} class={spaceClass}>
  <slot />
</div>

<style>
  .ant-space {
    display: flex;
  }
  :global(.ant-space .ant-space-item){
    margin-right: 4px;
  }
  :global(.ant-space-item:last-child) {
    margin-right: 0;
  }
</style>
```

在App中测试一下：
```html
<script>
  import Space from './Space.svelte';
</script>

<Space>
  <div>item1</div>
  <h2>item2</h2>
  <span>item3</span>
</Space>
```
![](/images/svelte/14-6.png)
## 其他

除了使用use来实现自定义的动作，Svelte还支持其他指令。如在介绍数据与dom引用时的`bind:`，在动画章节介绍的`transition:`、`in:`、`out:`、`animate:`以及在样式章节介绍的`style:`。

## 小结

本章我们学习了：
- 什么是action，如何自定义action方法；通过`use:action`的方式来使用自定义action
- 用具体案例演示了实际开发中action的作用
---
title: Svelte从入门到精通——特定标签
description: 【进阶篇】特定标签
---

一些特殊的标签，在平时的开发中比较少遇到。但在特定的场合，却又能发挥大用处。本章中，我们将了解以下标签：
- `<svelte:self>`
- `<svelte:component>`
- `<svelte:element>`
- `<svelte:window>`
- `<svelte:head>`
- `<svelte:fragment>`
- `<svelte:options>`

## 调用自身

`<svelte:self>`表示组件可以调用自己。这让人非常容易联想到，凡是涉及到树形结构的组件，都能使用这个标签。
```html
<script>
  // App.svelte
  import Folder from "./Folder.svelte";
  let data = [
    {
      name: "1.txt",
    },
    {
      name: "folder1",
      files: [
        {
          name: "2.png",
        },
        {
          name: "folder2",
          files: [
            {
              name: "3.doc",
            },
          ],
        },
      ],
    },
    {
      name: "3.pdf",
    },
  ];
</script>

<Folder {data} name={'Home'}/>
```

```html
<script>
// Folder.svelte
  export let data = [];
  export let name = '';
</script>

<p>{name}</p>
<ul>
  {#each data as item}
    <li>
      {#if item.files && item.files.length}
        <svelte:self data={item.files} name={item.name} />
      {:else}
        {item.name}
      {/if}
    </li>
  {/each}
</ul>

<style>
  ul {
    padding: 0.2em 0 0 0.5em;
    margin: 0 0 0 0.5em;
    list-style: none;
    border-left: 1px solid #eee;
  }

  li {
    padding: 0.2em 0;
  }
</style>
```
![](/images/svelte/15-1.png)
使用这个标签时，需要注意终止条件的判断，否则很可能造成无限递归调用。


## 动态渲染

### component

`<svelte:component>`用于动态渲染组件，可以看成是策略模式的简单使用。比如我们要设计一个组件，这个组件有不同的状态，然后我们根据不同的状态展示不同的icon。
正常情况下，我们可能会写出以下代码：
```html
{#if type === 'success'}
{:else if type === 'warning'}
{:else if type === 'error'}
{:else}
{/if}
```
这种面条式的状态判断好处是直观，但一旦我们的状态多起来，代码会变得非常冗长。

看下`<svelte:component>`的使用：
```html
<script>
  import SuccessIcon from "./icon/SuccessIcon.svelte";
  import InfoIcon from "./icon/InfoIcon.svelte";
  import WarningIcon from "./icon/WarningIcon.svelte";
  import ErrorIcon from "./icon/ErrorIcon.svelte";

  $: icon = {
    success: SuccessIcon,
    info: InfoIcon,
    warning: WarningIcon,
    error: ErrorIcon,
  }[type];
</script>

<svelte:component this={icon} />
```
这是我们的一个Icon组件，能够根据传递的type参数来显示不同的icon。所有状态及对应状态的映射内容收拢在一个对象里，根据状态的不同直接取对应状态的内容返回。
![](/images/svelte/15-2.png)

### element

`<svelte:element>`的功能和`<svelte:component>`很像，只是`component`是针对自定义的组件，而`element`是针对内建的html元素。

我们同样可以动态指定`element`：
```html
<script>
  let htmlType = 'div';
</script>

<select bind:value={htmlType}>
  <option value="div">div</option>
  <option value="h2">h2</option>
  <option value="button">button</option>
</select>

<svelte:element this={htmlType}>text</svelte:element>
```

![](/images/svelte/15-14.gif)
但需要注意的是，动态绑定的元素不能够使用`bind:value`。

当我们使用静态指定时，能够正常使用`bind:value`：
```html
<svelte:element this="input" bind:value={text} />
```
![](/images/svelte/15-15.gif)
而当我们使用动态指定时，`bind:value`失效
![](/images/svelte/15-17.png)


同时需要注意的是，如果我们动态指定的元素是自闭合标签，并且在`<svelte:element>`内有其他内容，内容不会展示。
```html
<script>
  let type = "input";
</script>

<select bind:value={type}>
  <option value="input">input</option>
  <option value="div">div</option>
</select>
<svelte:element this={type}>text</svelte:element>
```

![](/images/svelte/15-16.gif)


## BOM & DOM
### window
使用`<svelte:window>`来对window对象进行监听。
```html
<svelte:window on:event={handler} />
```

也可以使用bind对window对象进行属性绑定，只是支持绑定的属性有限：`innerWidth`、`innerHeight`、`outerWidth`、`outerHeight`、 `scrollX`、 `scrollY`、`online` 、`devicePixelRatio`。
比如我们可以：
```html
<svelte:window bind:scrollY={y}>
```

我们注意官网的一段提示：
> Note that the page will not be scrolled to the initial value to avoid accessibility issues. Only subsequent changes to the bound variable of `scrollX` and `scrollY` will cause scrolling. However, if the scrolling behaviour is desired, call `scrollTo()` in `onMount()`.

举个例子试验一下：
```html
<script>
  let y = 600;

  $: console.log('scrolly', y);
</script>

<svelte:window bind:scrollY={y} />

<div class="box red">red</div>
<div class="box green">green</div>
<button on:click={() => {y = 400}}>change</button>

<style>
  .box {
    width: 500px;
  }
  .red {
    height: 500px;
    background-color: red;
  }
  .green {
    height: 1000px;
    background-color: green;
  }
</style>
```

![](/images/svelte/15-3.gif)
当我们初次设置成400后，因为页面在最顶部，此时scrollY为0。初始的设置并没有生效，等我们滑到底部时，点击按钮成功让页面滚动到400px的位置。

与`<svelte:window>`类似的标签还有`<svelte:document>`和`<svelte:body>`，显而易见，这两个标签分别操作document和document.body。

### head
```javascript
<svelte:head>
```
往`<head>`标签中添加`<script>`、`<link>`、`<title>`和`<meta>`等元素。

![](/images/svelte/15-4.png)

操作window对象或document对象的这几个标签`<svelte:window>`、`<svelte:document>`、`<svelte:body>`、`<svelte:head>`，都只能在代码顶层中进行添加。不像`<svelte:self>`和`<svelte:component>`等标签可以在循环判断或条件判断中嵌套添加。

## fragment

在一些场景中，我们希望我们的页面下可以放置多个并排层级的元素，比如：
```javascript
<section>模块一</section>
<section>模块二</section>
```

然而现实却是我们会遇到框架的限制提示。

在Vue 2.x中：
![](/images/svelte/15-5.png)

在React中：
![](/images/svelte/15-6.png)
为了符合框架的要求，我们不得不用一个毫无意义的标签来包裹他们，以符合框架中只能返回一个顶级标签的需求：
```javascript
<div>
  <section>模块一</section>
  <section>模块二</section>
</div>
```
在Vue和React中，都提供了一种称为Fragment的组件来解决此类问题。Fragment是一个虚拟组件，它可以将组件功能绑定到一个单一的元素中，而不需要创建一个多余的DOM节点

虽然Svelte的html的标签填写非常灵活，可以直接写成：
```html
<script></script>

<section>模块一</section>
<section>模块二</section>

<style></style>
```

但在某些场景下，仍旧需要类似Fragment的功能支持。就比如下面这个例子：
```html
<!-- Child.svelte -->
<div>
  <header>
    <slot name="header">头部</slot>
  </header>
  <main>
    <slot>内容</slot>
  </main>
  <footer>
    <slot name="footer">底部</slot>
  </footer>
</div>

<style>
  footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
</style>
```

```html
<script>
 import Child from "./Child.svelte";
</script>

<Child>
  <div slot="footer">
    <div>底部左边</div>
    <div>底部右边</div>
  </div>
</Child>
```

![](/images/svelte/15-7.png)

我们原本在组件内容实现了底部内容的flex布局，然而因为我们在外部，需要一个标签来设置`slot="footer"`而导致需要对从外部传的内容进行一层包裹。导致原本期望的flex布局并不生效。一种解决方式是我们在自己外部自己再手动实现flex布局，另一种方式便是使用`<svelte:fragment>`标签。

```html
<Child>
  <svelte:fragment slot="footer">
    <div>底部左边</div>
    <div>底部右边</div>
  </svelte:fragment>
</Child>
```

![](/images/svelte/15-8.png)
可以看到`<svelte:fragment>`不会被当成实际标签编译展示到页面上。

## 编译

`<svelte:options>`为我们提供了自定义编译功能的能力，使用方式如下：
```html
<svelte:options option={value} />
```

可能会使用到的option参数有：
- immutable
- accessors
- namespace
- customElement

在大多数情况下，我们并不需要使用到这个标签，除非有深层次的定制。更多参数详见[compiler](https://svelte.dev/docs/svelte-compiler#types)。

### immutable

```html
<script>
let obj = {
  name: 'hello'
}
</script>
<input bind:value={obj.name} />
name: {obj.name}
```

![](/images/svelte/15-9.gif)

当我们添加`<svelte:options immutable={true} />`时，我们的对象将变成不可变对象：
```html
<svelte:options immutable={true} />
<script>
let obj = {
  name: 'hello'
}
</script>
<input bind:value={obj.name} />
name: {obj.name}
```
![](/images/svelte/15-10.gif)
可以看到，对象数据没有改变。
### accessors

如果我们配置accessors为true，编译器会为组件的props创建getters和setters。如果没配置，默认是false， 编译器只会为只读的导出数据（如const，class，function）创建getters。如果我们配置了 `customElement: true` ，accessors默认为`true`。

上面这段话有点让人费解，我们直接看例子：
```html
<script>
// Child.svelte
  let age = 18;
  export let name = 'Svelte';

  export function getAge() {
    console.log(age);
  }
</script>

<button on:click={getAge}>{name}</button>
```

```html
<script>
// App.svelte
  import Child from './Child.svelte';

  let childRef;

  function onClick() {
    console.log(childRef);
    console.log(childRef.name);
    console.log(childRef.getAge());
  }
</script>

<button on:click={onClick}>Get Child</button>
<Child bind:this={childRef} />
```
首先我们定义了一个子组件，对外导出name属性和getAge方法，然后我们在父组件中引用，并试图通过ref直接调用子组件的name和getAge。在《dom引用》章节，我们曾试验过直接调用子组件实例的数据和方法，答案很明显，我们无法直接使用childRef.name。
![](/images/svelte/15-11.png)

我们直接查看Child.svelte编译后的结果，发现只有getAge方法提供了getter。
```javascript
/* Child.svelte generated by Svelte v4.2.12 */

let age = 18;

function getAge() {
	console.log(age);
}

class Child extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { name: 0, getAge: 1 });
	}

	get getAge() {
		return getAge;
	}
}

export default Child;
```

而当我们开启了`accessors={true}`后，Child.svelte的编译结果为：
```javascript
/* Child.svelte generated by Svelte v4.2.12 */
let age = 18;

function getAge() {
	console.log(age);
}

class Child extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { name: 0, getAge: 1 });
	}

	get name() {
		return this.$$.ctx[0];
	}

	set name(name) {
		this.$$set({ name });
		flush();
	}

	get getAge() {
		return getAge;
	}
}

export default Child;
```
Child.svelte的name提供了getter和setter。重新执行页面内容：
![](/images/svelte/15-12.png)
可以看到内容都被正确打印出来。
我们甚至可以直接`childRef.name = 'xxx';`来操作子组件的值。

### customElement

customElement支持我们使用自定义标签。
我们先自定义一个标签：
```html
<!-- Custom.svelte -->
<svelte:options customElement="my-element" />

<script>
  export let name = 'world'
</script>

<h1>hello {name}</h1>

<style>
  h1 {
    color: orange;
  }
</style>
```

然后修改我们的vite.config.js：
```javascript
import { defineConfig } from "vite";
import { svelte } from "@sveltejs/vite-plugin-svelte";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    svelte({
      compilerOptions: {
        customElement: true,
      },
    }),
  ],
});
```

在main.js中引入组件，这样我们就无需在其他组件中反复导入：
```javascript
// main.js
import './app.css'
import App from './App.svelte'
import './Custom.svelte';

const app = new App({
  target: document.getElementById('app'),
})

export default app
```

最后在App.svlete中测试一下：
```html
<script>
  let name = 'svelte';
</script>

<input bind:value={name} />
<my-element {name} />
```

![](/images/svelte/15-13.gif)

customElement除了支持传入一个字符串，还支持传入对象。
```html
<svelte:options
  customElement={{
	tag: 'xxx',
	shadow: 'xxx',
	props: {},
	extend: (customElementConstructor) => {}
/>
```

## 小结

本章我们学习了：
- Svelte内置的一些特殊标签：`<svelte:slef>`能使组件调用自身；`<svelte:component>`和`<svelte:element>`能进行动态渲染；`<svelte:fragment>`能提供一个专门用于包裹多个子节点的功能标签；`<svelte:options>`可以修改Svelte的编译能力；还有一些操作DOM和Window的标签等

---
title: 手绘风格
description: 各种资源
---

# 手绘风格

## 字体

小赖字体：https://github.com/lxgw/kose-font

## ui

https://wiredjs.com/
https://github.com/rough-stuff/rough-notation

## icon

https://www.flaticon.com/free-icons/hand-drawn

## 图表

https://github.com/jwilber/roughViz

## 图片

https://www.openpeeps.com/前期备考

备考思路：软件设计师教程第五版 + 十二个txt。无脑记笔记
软件设计师一共十二个章节，我建立了十二个txt文件。每一章都是分开记笔记。这也有助于后面快速查找考点。会有人问，这样盲目记笔记会不会浪费时间？
不会，为什么不会?继续看
这一部分，不需要背笔记，只需要看着教程，把自己认为重要的知识点无脑记下来就行，主要是过一遍教程，针对大的知识点有一个脸熟就行。

过来人技巧：
第八章算法设计与分析，要记的东西很少，因为它是算法题目，只是了解有几种算法题型就行了，放到后面再看。

第十一章标准化和软件知识产权基础知识，这一章完全可以不看，里面全是什么法律条文。而且这一章考试只考一道题，即使你不看教程这一题也能做出来。所以，这一章可以不看。

第十二章软件系统分析与设计，这一章也可以不看，因为这一章主要概述可下午的几种题型，记笔记没啥用。

其他的几章按部就班的过一遍，记下笔记。这样时间就节省了很多了。




- 计算机系统知识
- 程序语言基础知识
- 操作系统知识
- 系统开发和运行
- 网络基础知识
- 多媒体知识
- 数据库技术
- 数据结构
- 算法设计与分析
- 面向对象技术
- 软件知识产权
- 计算机英文
---
title: 过渡效果
description: html api
---

view-transition-name

document.startViewTransition

::view-transition-old
::view-transition-new

https://blog.csdn.net/xgangzai/article/details/134131242
https://juejin.cn/post/7389651944253587491---
title: Svelte从入门到精通——模板语法之其他
description: 【进阶篇】模板语法之其他
---

## await

在列表展示时，为了提升用户体验，我们在数据请求的过程中，往往会使用一些loading toast来提示用户我们正在请求，等到请求完成后便会隐藏loading提示而展示我们请求成功的数据。

```html
{#await expression}...{:then name}...{:catch name}...{/await}
```

我们演示一个例子：
```html
<script>
  const myFetch = () => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        let data = [{
          value: 'hello'
        }, {
          value: 'svelte'
        }];
        resolve(data);
      }, 2000)
    })
  }
</script>

{#await myFetch()}
  <div>loading...</div>
{:then data} 
  {#each data as item}
    <div>{item.value}</div>
  {/each}
{/await}
```

![](/images/svelte/16-1.gif)

`{:catch}`用于展示当接口报错时的页面内容。我们演示一个接口报错的例子：
```html
<script>
 const myFetch = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const error = new Error('接口出错！');
      reject(error);
    }, 2000)
  })
 }
</script>

{#await myFetch()}
  <div>loading...</div>
{:then data} 
  {#each data as item}
    <div>{item.value}</div>
  {/each}
{:catch error}
  <div>页面出错：{error.message}</div>
{/await}
```

![](/images/svelte/16-2.gif)

### Suspense
在React和Vue中，有一种称为Suspense的能力：[React Suspense](https://react.dev/reference/react/Suspense)、[Vue Suspense](https://vuejs.org/guide/built-ins/suspense.html)。这种能力允许开发者在页面中异步加载组件，这在一些性能优化的场合中非常有用。

我们演示下如何用`{#await}`实现Suspense的能力：
```html
<script>
  // App.svelte
  let lazyComponent;
  let count = 0;

  function lazyload() {
    lazyComponent = import("./LazyLoad.svelte");
  }
</script>

<button on:click={lazyload}>Load</button>
<button on:click={() => count++}>Add</button>

{#if lazyComponent}
  {#await lazyComponent then { default: LazyComponent }}
    <LazyComponent {count} />
  {/await}
{/if}
```

```html
<script>
  // LazyLoad.svelte
  export let count;
</script>
<div>这是一个用于异步加载的组件 {count}</div>
```
![](/images/svelte/16-3.gif)

## html

`{@html}`允许我们直接渲染出html字符串内容，这在一些富文本应用中非常常见，正常写法如下：
```javascript
{@html expression}
```

```html
<script>
  let htmlContent = `<h1>hello svelte</h1>`
</script>

{@html htmlContent}
```

### XSS
Svelte不会在注入HTML之前转义表达式。如果数据来源不受信任，则必须对其进行转义，否则将用户暴露于XSS漏洞之中。

举个例子：
```html
<script>
  const htmlContent = '<img src="http://www.xxx.com" onerror="alert(1)">';
</script>

{@html htmlContent}
```

![](/images/svelte/16-4.png)

![](/images/svelte/16-5.png)

我们可以使用一些XSS防御库如[xss](https://www.npmjs.com/package/xss)和[DOMPurify](https://github.com/cure53/DOMPurify)等来对一些脚本内容进行转义。

```html
<script>
  import xss from "xss";

  const htmlContent = '<img src="http://www.xxx.com" onerror="alert(1)">';

  const filterContent = xss(htmlContent);
</script>

{@html filterContent}
```

![](/images/svelte/16-6.png)

## key

```html
{#key expression}
```

> Key blocks destroy and recreate their contents when the value of an expression changes.This is useful if you want an element to play its transition whenever a value changes instead of only when the element enters or leaves the DOM.

说实话，笔者认为这个名字存在很大的误导性。 这个标签的真实作用是：当我们想看到一个元素因为状态变化而产生渐变效果时，我们可以用上这个语法。

```html
<script>
  import { slide } from "svelte/transition";

  let second = 60;

  let timer;

  const startCountDown = () => {
    stopCountDown();
    timer = setInterval(() => {
      if (second <= 0 && timer) {
        clearInterval(timer);
        return;
      }
      second--;
    }, 1000);
  };

  const stopCountDown = () => {
    if (timer) {
      clearInterval(timer);
    }
  };

  $: strArr = String(second).split("");
</script>

<button on:click={startCountDown}>开始倒计时</button>
<button on:click={stopCountDown}>停止倒计时</button>

<div class="num-list">
  {#each strArr as item}
    {#key item}
      <div class="num" in:slide={{duration: 1000}}>
        {item}
      </div>
    {/key}
  {/each}
</div>

<style>
  .num-list {
    display: flex;
  }
  .num {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100px;
    height: 150px;
    background: black;
    border-radius: 12px;
    color: white;
    font-size: 48px;
    margin-right: 10px;
  }
</style>
```

![](/images/svelte/16-7.gif)  
在这个例子中，我们针对每个变动的数字，添加了slide的过渡效果。当数字变化时，过渡效果便会生效，数字不变化时，则没有过渡效果。

## debug
顾名思义，可以用来调试。当我们打开调试控制台时，会在我们的变量更改时执行断点调试。
```html
{@debug variables}
```

```html
<script>
  let count = 0;
  $:double = count * 2;
</script>

{@debug double}
<button on:click={() => count++}>add</button>
count: {count}
```

当我们不打开控制台时，页面正常运行，不会打断点影响整体交互流程。
![](/images/svelte/16-8.gif)

当打开控制台时，会出现调试断点，且当我们改变变量的值时，debug会再次被唤醒：
![](/images/svelte/16-9.gif)

`{@debug}`接收固定格式的变量：
```html
<!-- 正确 -->
{@debug user}
{@debug user1, user2, user3}

<!-- 错误 -->
{@debug user.firstname}
{@debug myArray[0]}
{@debug !isReady}
{@debug typeof user === 'object'}
```

那如果我们想调试类似user.name格式的内容呢？一个取巧的方式是把它付给一个变量：
```html
<script>
  let obj = {
    name: 'hello'
  }

  const onChange = () => {
    const str = '' + Math.random();
    obj = {
      ...obj,
      name: str,
    }
  }

  $: name = obj.name;
</script>

{@debug name}
<button on:click={onChange}>change</button>
name: {name}
```
![](/images/svelte/16-10.gif)

## 小结

本章我们学习了：
- Svelte中一些特殊的模板语法。使用`{#await}{:then}{:catch}{/await}`能完成资源请求；使用`{@html}`能插入html字符串内容；使用`{#key}`能在元素元素内容进行更改时进行动画效果展示；使用`{#debug}`能进行开发调试等
- 标签`{@const}`没有讲解，留给读者自行探究。---
title: Svelte从入门到精通——TodoList之页面布局
description: 【实战篇】TodoList之页面布局
---

## 搭建环境

首先使用vite搭建项目。
```bash
npm create vite@latest svelte-todolist -- --template svelte
```

安装tailwind，这一步读者可自行选择自己喜欢的样式工具。

```bash
npm install -D tailwindcss postcss autoprefixer
```

```bash
npx tailwindcss init -p
```

删除lib/Counter.svelte，清空App.svelte的内容，清空app.css的内容。

将tailwind的基本内容添加进app.css：
```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

修改`tailwind.config.js`的内容
```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./src/**/*.{html,js,svelte}"],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

然后我们往App.svelte里添加一行内容
```html
<div class="text-rose-400">app</div>
```
如无意外，相信读者朋友们能在页面上看到玫瑰色的app字样。


从[dribble](https://dribbble.com/shots/12342455-ToDo-List-042-DailyUI)上获取灵感，挑选了一些好看的颜色。在`tailwind.config.js`上配置：
```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./src/**/*.{html,js,svelte}"],
  theme: {
    extend: {
      colors: {
        'color1': '#FDEEE1',
        'color2': '#E62737',
        'color3': '#FF7171',
        'color4': '#FFADA8',
      }
    },
  },
  plugins: [],
}
```

## 数据结构

首先我们需要确定待办列表的一个待办项的数据结构，目前笔者定义如下：
```typescript
interface Todo {
	id: number,
	text: string,
	done: boolean,
}
```

## 布局
![布局](/images/svelte/17-1.png)
我们将页面分成三部分，笔者在这里用不同的颜色进行了标注。分别是输入框、Tab切换以及待办列表展示。
整体使用flex布局。

## 基本框架
在App.svelte中
```html
<script>
  let divClass =
    "flex flex-col w-[500px] h-[700px] overflow-hidden rounded-lg mx-auto p-4 bg-black";
</script>

<div class={divClass}></div>
```
在页面上，看到一个居中的暖色块。

### 输入框
新建一个Input.svelte文件，内容如下
```html
<script>
  let inputClass = "flex-1 h-full border rounded-lg mr-4 px-4 caret-color2 focus:outline-color2";
  let buttonClass = "w-[100px] h-full rounded-lg flex items-center justify-center bg-color2 text-white flex-shrink-0 hover:cursor-pointer"
</script>

<div class="flex h-12">
  <input
    type="text"
    class={inputClass}
  />
  <button
    class={buttonClass}>Add</button
  >
</div>
```

然后我们在App.svelte中引入该组件
```html
<script>
  import Input from './Input.svelte';

  let divClass =
    "flex flex-col w-[500px] h-[700px] overflow-hidden rounded-lg mx-auto p-4 bg-color1";
</script>

<div class={divClass}>
  <Input />
</div>
```

此时相信读者们能够看到以下内容：
![](/images/svelte/17-2.png)

### Tabs

新建Tabs.svelte组件，添加内容：
```html
<script>
  let tabsClass = "grid grid-cols-3 gap-4 h-12 my-4";
  let tabClass =
    "h-12 flex items-center justify-center hover:cursor-pointer rounded-lg";
</script>

<div class={tabsClass}>
  <button class={tabClass}>Todo</button>
  <button class={tabClass}>Done</button>
  <button class={tabClass}>All</button>
</div>
```
App.svelte中引入该组件后，页面展示如下：
![](/images/svelte/17-3.png)

继续完善Tabs.svelte的内容：
```html
<script>
  let tabsClass = "grid grid-cols-3 gap-4 h-12 my-4";
  let tabClass =
    "h-12 flex items-center justify-center hover:cursor-pointer rounded-lg";

  let currentTab = 'todo'; // todo | done | all

  const changeTab = (tab) => currentTab = tab;
</script>

<div class={tabsClass}>
  <button class={tabClass} on:click={() => changeTab('todo')}>Todo</button>
  <button class={tabClass} on:click={() => changeTab('done')}>Done</button>
  <button class={tabClass} on:click={() => changeTab('all')}>All</button>
</div>
<div class="flex-1 overflow-auto">
  <slot>{currentTab}</slot>
</div>
```
笔者设置了currentTab变量，用来记录当前激活的是哪个tab，为三个tab按钮绑定更新tab的事件，然后添加了slot，用于待办列表的展示

### 列表

首先我们实现Item.svelte内的展示：
```html
<script>
  export let index = 0;
  export let name = "";
  export let done = false;

  let divClass =
    "flex items-center bg-white rounded-lg h-12 px-4 mb-4";
  let indexClass = "w-12 text-left flex-shrink-0";
  let nameClass = "flex-1 overflow-hidden text-ellipsis";
  let checkboxWrapClass = "w-12 flex-shrink-0 flex justify-end items-center";
</script>

<div class={divClass}>
  <span class={indexClass}>{index}</span>
  <span class={nameClass}>{name}</span>
  <span class={checkboxWrapClass}>
    <input
      type="checkbox"
      checked={done}
    />
  </span>
</div>

<style>
  input[type="checkbox"] {
    appearance: none;
    background-color: #fff;
    margin: 0;
    font: inherit;
    width: 1.15em;
    height: 1.15em;
    border: 0.15em solid currentColor;
    border-radius: 0.15em;
    transform: translateY(-0.075em);
    display: grid;
    place-content: center;
  }

  input[type="checkbox"]::before {
    content: "";
    width: 0.65em;
    height: 0.65em;
    transform: scale(0);
    transition: 120ms transform ease-in-out;
    box-shadow: inset 1em 1em #E62737;
  }

  input[type="checkbox"]:checked::before {
    transform: scale(1);
  }
</style>
```
待办项Item.svelte接收三个prop：index、name和done。
这里我们用自己的style重写了checkbox的样式，使其看上去更符合我们页面的主题。

接着我们实现List.svelte的内容：
```html
<script>
  import Item from './Item.svelte';

  let list = [{
    id: 1,
    text: 'hello',
    done: false
  }, {
    id: 2,
    text: 'world',
    done: true
  }];
</script>

{#each list as {text, done}, i}
  <Item index={i} name={text} done={done} />
  {:else}
    No data
{/each}
```
这里我们mock了两个待办项的假数据，一个状态未完成，另一个状态已完成。
最后，我们在App.svelte中引用List.svelte并使用它。

```html
<script>
  import Input from './Input.svelte';
  import Tabs from './Tabs.svelte';
  import List from './List.svelte';

  let divClass =
    "flex flex-col w-[500px] h-[700px] overflow-hidden rounded-lg mx-auto p-4 bg-color1";
</script>

<div class={divClass}>
  <Input />
  <Tabs>
    <List />
  </Tabs>
</div>
```

至此，页面上能够看见我们最开始设计的布局结构。
![](/images/svelte/17-4.png)

当然，此时的页面功能仍不完整，比如无法添加待办项、Tab切换没有样式、待办项勾选后没有放置到对应的Tab栏等等。在下一章，我们将完善剩余的功能。

## 小结

本章我们完成了：
- TodoList项目环境的搭建
- TailwindCss的使用
- 一个待办项基本的数据结构
- 页面布局的定义和初步实现---
title: Svelte从入门到精通——Alert组件之动画
description: 【实战篇】Alert组件之动画
---

## 动画

当我们点击关闭Alert组件时，会出现一段向上关闭的动画。我们使用`svelte/easing`配合`transition`指令来实现相似的动画。

```javascript
<script>
  import { circInOut } from "svelte/easing";

  function slideUp(node, { duration = 300 }) {
    return {
      duration,
      css: (t, u) => {
        const data = circInOut(t);
        return `
          transform: scaleY(${data});
          transform-origin: 0% 0%;
          opacity: ${data};
        `
      },
    };
  }
</script>
```

然后修改html内容：
```html
{#if !closed}
	<div class={alertCls} transition:slideUp on:outroend={animationEnd}>
	...
{/if}
```

添加最后一个api事件afterClose：
```javascript
const animationEnd = () => {
    dispatch("afterClose");
};
```

在App.svelte中试验一下
```html
<script>
  import Alert from "./Alert.svelte";
  import SvelteIcon from "./icon/SvelteIcon.svelte";

  const onClose = () => {
    console.log('onClose');
  }

  const afterClose = () => {
    console.log('afterClose');
  }
</script>

<Alert
  message="Success Tips"
  type="success"
  showIcon
  closable
  on:close={onClose}
  on:afterClose={afterClose}
>
  <SvelteIcon slot="icon" />
</Alert>
<br />
<Alert
  message="Info Tips"
  showIcon
  closable
/>
```
![](/images/svelte/21-1.gif)

## 完整代码

最后附上完整代码：
```html
<script>
  import { createEventDispatcher } from "svelte";
  import { circInOut } from "svelte/easing";
  import classNames from "classnames";
  import SuccessIcon from "./icon/SuccessIcon.svelte";
  import InfoIcon from "./icon/InfoIcon.svelte";
  import WarningIcon from "./icon/WarningIcon.svelte";
  import ErrorIcon from "./icon/ErrorIcon.svelte";
  import CloseIcon from "./icon/CloseIcon.svelte";

  export let type = "info"; // info | success | warning | error
  export let showIcon = false;
  export let banner = false;
  export let closable = undefined;
  export let closeText = undefined;
  export let message = undefined;
  export let description = undefined;

  function getPropsSlot(slots, props, prop = "default") {
    if (props && props[prop]) {
      return props[prop];
    }
    if (slots && slots[prop]) {
      return slots[prop];
    }
    return null;
  }

  function slideUp(node, { duration = 300 }) {
    return {
      duration,
      css: (t, u) => {
        const data = circInOut(t);
        return `
          transform: scaleY(${data});
          transform-origin: 0% 0%;
          opacity: ${data};
        `;
      },
    };
  }

  const dispatch = createEventDispatcher();
  const slots = $$slots;
  const props = $$props;

  let prefixCls = "ant-alert";
  let closed = false;
  let iconTheme = "filled";

  // banner模式默认有 Icon
  showIcon = banner && showIcon === false ? true : showIcon;
  // banner模式默认为警告
  type = banner && type === "info" ? "warning" : type;

  const closeTextData = getPropsSlot(slots, props, "closeText");
  const messageData = getPropsSlot(slots, props, "message");
  const descriptionData = getPropsSlot(slots, props, "description");
  const hasCloseTextSlot = !!slots?.closeText;
  const hasMessageSlot = !!slots?.message;
  const hasDescriptionSlot = !!slots?.description;
  const hasIconSlot = !!slots?.icon;

  if (closeTextData) {
    closable = true;
  }

  if (!!descriptionData) {
    iconTheme = "outlined";
  }

  $: alertCls = classNames(prefixCls, {
    [`${prefixCls}-${type}`]: true,
    [`${prefixCls}-no-icon`]: !showIcon,
    [`${prefixCls}-banner`]: banner,
    [`${prefixCls}-closable`]: closable,
    [`${prefixCls}-with-description`]: !!descriptionData,
  });

  $: icon = {
    success: SuccessIcon,
    info: InfoIcon,
    warning: WarningIcon,
    error: ErrorIcon,
  }[type];

  const handleClose = (e) => {
    closed = true;
    dispatch("close", e);
  };

  const animationEnd = () => {
    dispatch("afterClose");
  };
</script>

{#if !closed}
  <div class={alertCls} transition:slideUp on:outroend={animationEnd}>
    {#if showIcon}
      {#if hasIconSlot}
        <slot name="icon" />
      {:else}
        <i class={`anticon ${prefixCls}-icon`}>
          <svelte:component this={icon} theme={iconTheme} />
        </i>
      {/if}
    {/if}
    <div class={`${prefixCls}-content`}>
      {#if messageData}
        {#if hasMessageSlot}
          <slot name="message" />
        {:else}
          <span class={`${prefixCls}-message`}>{message}</span>
        {/if}
      {/if}
      {#if descriptionData}
        {#if hasDescriptionSlot}
          <slot name="description" />
        {:else}
          <span class={`${prefixCls}-description`}>{description}</span>
        {/if}
      {/if}
    </div>
    {#if closable}
      <a
        href={""}
        on:click|preventDefault={handleClose}
        class={`${prefixCls}-close-icon`}
        role="button"
        tabindex="0"
      >
        {#if hasCloseTextSlot}
          <slot name="closeText" />
        {:else if closeTextData}
          {closeText}
        {:else}
          <i class={`anticon anticon-close ${prefixCls}-icon`}>
            <CloseIcon />
          </i>
        {/if}
      </a>
    {/if}
  </div>
{/if}

<style lang="less">
  @import "./alert.less";
</style>
```

## 小结

本章我们完成了：
- `transition:fn`指令的使用
- 自定义过渡效果
- 完整的代码演示---
title: Svelte从入门到精通——Alert组件之简单传值
description: 【实战篇】Alert组件之简单传值
---

也许实现一个TodoList项目没有过瘾，这里笔者为大家带来第二个实战内容：使用Svelte来实现[Antd](https://ant-design.antgroup.com/index-cn)的其中一个组件。

这里笔者挑选的Antd组件是Alert组件
![](/images/svelte/19-1.png)

我们先来看下一个Alert组件对外支持的Api有哪些？

笔者选择了3.X版本的Antd的[Alert](https://3x.ant.design/components/alert-cn/)组件作为演示内容。
![](/images/svelte/19-2.png)

## 安装依赖

```bash
npm create vite@latest svelte-antd-alert -- --template svelte
```

这次我们选择的Less作为样式预处理器：
```bash
npm install svelte-preprocess-less less -D
```

修改`vite.config.js`的配置：
```javascript
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'
import { less } from 'svelte-preprocess-less';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [svelte({
    preprocess: {
      style: less()
    }
  })],
})
```

```bash
npm install classnames
```

## 样式
alert.less内容如下：
```less
@alert-prefix-cls: 'ant-alert';
@margin-xs: 4px;
@font-size-base: 14px;

@alert-success-bg-color: #f6ffed;
@alert-success-border-color: #b7eb8f;
@alert-success-icon-color: #52c41a;
@alert-info-bg-color: #e6f7ff;
@alert-info-border-color: #91d5ff;
@alert-info-icon-color: #1890ff;
@alert-warning-bg-color: #fffbe6;
@alert-warning-border-color: #ffe58f;
@alert-warning-icon-color: #faad14;
@alert-error-bg-color: #fff1f0;
@alert-error-border-color: #ffa39e;
@alert-error-icon-color: #f5222d;
@alert-close-color: rgba(0,0,0,.45);
@alert-close-hover-color: rgba(0,0,0,.75);

@alert-with-description-padding: 15px;
@alert-with-description-no-icon-padding-vertical: 7px;
@alert-with-description-padding-vertical: 11px;
@alert-with-description-icon-size: 20px;

@border-width-base: 1px;
@border-style-base: solid;
@border-radius-base: 2px;

@font-size-sm: 12px;
@font-size-lg: 16px;
@iconfont-css-prefix: anticon;
@alert-message-color: rgba(0, 0, 0, .85);

.@{alert-prefix-cls} {

  position: relative;
  display: flex;
  align-items: center;
  padding: 8px 15px;
  word-wrap: break-word;
  border-radius: @border-radius-base;

  &-content {
    flex: 1;
    min-width: 0;
  }

  &-icon {
    margin-right: @margin-xs;
  }

  &-description {
    display: none;
    font-size: @font-size-base;
    line-height: @font-size-base + 8px;
  }

  &-success {
    background-color: @alert-success-bg-color;
    border: @border-width-base @border-style-base @alert-success-border-color;
    .@{alert-prefix-cls}-icon {
      color: @alert-success-icon-color;
    }
  }

  &-info {
    background-color: @alert-info-bg-color;
    border: @border-width-base @border-style-base @alert-info-border-color;
    .@{alert-prefix-cls}-icon {
      color: @alert-info-icon-color;
    }
  }

  &-warning {
    background-color: @alert-warning-bg-color;
    border: @border-width-base @border-style-base @alert-warning-border-color;
    .@{alert-prefix-cls}-icon {
      color: @alert-warning-icon-color;
    }
  }

  &-error {
    background-color: @alert-error-bg-color;
    border: @border-width-base @border-style-base @alert-error-border-color;

    .@{alert-prefix-cls}-icon {
      color: @alert-error-icon-color;
    }

    .@{alert-prefix-cls}-description > pre {
      margin: 0;
      padding: 0;
    }
  }

  &-action {
    margin-left: @margin-xs;
  }

  &-close-icon {
    margin-left: @margin-xs;
    padding: 0;
    overflow: hidden;
    font-size: @font-size-sm;
    line-height: @font-size-sm;
    background-color: transparent;
    border: none;
    outline: none;
    cursor: pointer;
    text-decoration: none;
	  color: @alert-close-color;

    .@{iconfont-css-prefix}-close {
      color: @alert-close-color;
      transition: color 0.3s;

      &:hover {
        color: @alert-close-hover-color;
      }
    }
  }

  &-close-text {
    color: @alert-close-color;
    transition: color 0.3s;
    cursor: pointer;

    &:hover {
      color: @alert-close-hover-color;
    }
  }

  &-with-description {
    align-items: flex-start;
    padding: @alert-with-description-padding;
  }

  &-with-description&-no-icon {
    padding: @alert-with-description-no-icon-padding-vertical 15px;
  }

  &-with-description &-icon {
    margin-right: @alert-with-description-padding-vertical;
    font-size: @alert-with-description-icon-size;
  }

  &-with-description &-message {
    display: block;
    margin-bottom: 4px;
    color: @alert-message-color;
    font-size: @font-size-lg;
  }

  &-message {
    color: @alert-message-color;
  }

  &-with-description &-description {
    display: block;
  }

  &-banner {
    margin-bottom: 0;
    border: 0;
    border-radius: 0;
  }
}

.@{iconfont-css-prefix} {
  display: inline-block;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
}
```

## api

在本章，我们先实现banner、closable、showIcon和type这几个传参的功能，因为这几个参数只单是接收参数，没有和slot的联动。

Alert.svelte初始内容如下：
```html
<script>  
  let prefixCls = 'ant-alert';

  $: alertCls = '';
</script>

<div class={alertCls}>
  <div class={`${prefixCls}-content`}>
    <slot></slot>
  </div>
</div>

<style lang="less">
  @import './alert.less';
</style>
```

### type

```html
<script>
  import classNames from 'classnames';

  export let type = 'info'; // info | success | warning | error

  let prefixCls = 'ant-alert';

  $: alertCls = classNames(prefixCls, {
    [`${prefixCls}-${type}`]: true,
  });
</script>

<div class={alertCls}>
  <div class={`${prefixCls}-content`}>
    <slot></slot>
  </div>
</div>

<style lang="less">
  @import './alert.less';
</style>
```

在App.svelte中
```html
<script>
  import Alert from './Alert.svelte';
</script>

<Alert>info</Alert>
<Alert type="success">alert</Alert>
<Alert type="warning">warning</Alert>
<Alert type="error">error</Alert>
```
可以看到页面内容：
![](/images/svelte/19-3.png)

### showIcon

![](/images/svelte/19-4.png)

然后再添加icon相关的svelte组件

SuccessIcon.svelte：
```html
<svg
  viewBox="64 64 896 896"
  focusable="false"
  class=""
  data-icon="check-circle"
  width="1em"
  height="1em"
  fill="currentColor"
  aria-hidden="true"
  ><path
    d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 0 1-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z"
  ></path></svg>
```

InfoIcon.svelte：
```html
<svg
  viewBox="64 64 896 896"
  focusable="false"
  class=""
  data-icon="info-circle"
  width="1em"
  height="1em"
  fill="currentColor"
  aria-hidden="true"
  ><path
    d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 0 1 0-96 48.01 48.01 0 0 1 0 96z"
  ></path></svg>
```

WarningIcon.svelte：
```html
<svg
  viewBox="64 64 896 896"
  focusable="false"
  class=""
  data-icon="exclamation-circle"
  width="1em"
  height="1em"
  fill="currentColor"
  aria-hidden="true"
  ><path
    d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 0 1 0-96 48.01 48.01 0 0 1 0 96z"
  ></path></svg>
```

ErrorIcon.svelte：
```html
<svg
  viewBox="64 64 896 896"
  focusable="false"
  class=""
  data-icon="close-circle"
  width="1em"
  height="1em"
  fill="currentColor"
  aria-hidden="true"
  ><path
    d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 0 1-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z"
  ></path></svg>
```

在Alert.svelte中，引入icon组件
```html
<script>
  import SuccessIcon from './icon/SuccessIcon.svelte';
  import InfoIcon from './icon/InfoIcon.svelte';
  import WarningIcon from './icon/WarningIcon.svelte';
  import ErrorIcon from './icon/ErrorIcon.svelte';
</script>
```

设置showIcon属性
```javascript
export let showIcon = false;
```

设置样式
```javascript
$: alertCls = classNames(prefixCls, {
  [`${prefixCls}-${type}`]: true,
  [`${prefixCls}-no-icon`]: !showIcon,
});
```

设置当前的icon类型
```javascript
$: icon = {
  'success': SuccessIcon,
  'info': InfoIcon,
  'warning': WarningIcon,
  'error': ErrorIcon
}[type];
```

添加html逻辑
```html
<div class={alertCls}>
  <div class={`${prefixCls}-content`}>
    {#if showIcon}
      <i class={`anticon ${prefixCls}-icon`}>
        <svelte:component this={icon} />
      </i>
    {/if}
    <slot></slot>
  </div>
</div>
```

现在我们来测试下showIcon属性是否生效，在App.svelte中
```html
<script>
  import Alert from './Alert.svelte';
</script>

<Alert showIcon={true}>info</Alert>
<Alert type="success" showIcon={true}>alert</Alert>
<Alert type="warning" showIcon={true}>warning</Alert>
<Alert type="error" showIcon={true}>error</Alert>
```

![](/images/svelte/19-5.png)

### banner
页面顶部通告形式，默认有图标且`type` 为 'warning'。

showIcon在`banner` 模式下默认值为 true

```javascript
export let banner = false;
```

联动
```javascript
// banner模式默认有 Icon
showIcon = banner && showIcon === false ? true : showIcon;
// banner模式默认为警告
type = banner && type === 'info' ? 'warning' : type;
```

样式
```javascript
$: alertCls = classNames(prefixCls, {
  [`${prefixCls}-${type}`]: true,
  [`${prefixCls}-no-icon`]: !showIcon,
  [`${prefixCls}-banner`]: banner,
});
```

App.svelte
```html
<script>
  import Alert from "./Alert.svelte";
</script>

<Alert banner>Warning text</Alert>
<br />
<Alert banner
  >Very long warning text warning text text text text text text text</Alert
>
<br />
<Alert showIcon={false} banner>Warning text without icon</Alert>
<br />
<Alert type="error" banner>Error text</Alert>
```

内容如下：
![](/images/svelte/19-6.png)

### closable

首先我们需要添加一个关闭按钮的icon。

CloseIcon.svelte：
```html
<svg
  viewBox="64 64 896 896"
  focusable="false"
  class=""
  data-icon="close"
  width="1em"
  height="1em"
  fill="currentColor"
  aria-hidden="true"
  ><path
    d="M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 0 0 203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z"
  ></path></svg>
```

```javascript
import CloseIcon from "./icon/CloseIcon.svelte";
```

```javascript
export let closable = undefined;
```

```javascript
$: alertCls = classNames(prefixCls, {
    [`${prefixCls}-${type}`]: true,
    [`${prefixCls}-no-icon`]: !showIcon,
    [`${prefixCls}-banner`]: banner,
    [`${prefixCls}-closable`]: closable,
});
```

添加关闭按钮的html内容
```html
  <div class={alertCls}>
    <div class={`${prefixCls}-content`}>
      {#if showIcon}
        <i class={`anticon ${prefixCls}-icon`}>
          <svelte:component this={icon} />
        </i>
      {/if}
      <slot />
    </div>
    {#if closable}
      <a
        href={""}
        on:click|preventDefault={handleClose}
        class={`${prefixCls}-close-icon`}
        role="button"
        tabindex="0"
      >
        <i class={`anticon anticon-close ${prefixCls}-icon`}>
          <CloseIcon />
        </i>
      </a>
    {/if}
  </div>
```

### onClose

实现点击关闭：
```html
<script>
	import { createEventDispatcher } from "svelte";
	
	const dispatch = createEventDispatcher();
	let closed = false;
	...

	const handleClose = (e) => {
		closed = true;
		dispatch("close", e);
	};
</script>

{#if !closed}
	<div class={alertCls}>
		...
	</div>
{/if}
```

我们在App.svelte中试验一下
```html
<script>
  import Alert from "./Alert.svelte";

  const onClose = (e) => {
    console.log('onClose', e);
  }
</script>

<Alert closable on:close={onClose}>text</Alert>
<br />
<Alert type="success" closable>text</Alert>
<br />
```

![](/images/svelte/19-7.gif)

## 小结

本章我们完成了：
- Alert组件项目的环境搭建
- 预处理器Less的使用
- 通过`$`和`classnames`实现动态class
- `<svelte:component>`动态加载标签组件爱你
- 在Svelte中定义和使用svg
---
title: Svelte从入门到精通——TODOLIST之数据交互
description: 【实战篇】TODOLIST之数据交互
---

## 状态管理

安装tailwind-merge
```bash
npm install tailwind-merge -D
```
tailwind-merge是一个类似于classnames的工具。


新建store.js，用来管理我们的数据
```javascript
import { writable } from 'svelte/store';

export const tab = writable('todo'); // todo | done | all
```
我们修改Tabs.svelte
```html
<script>
  import { twMerge } from "tailwind-merge";
  import { tab } from "./store";
  let tabsClass = "grid grid-cols-3 gap-4 h-12 my-4";
  let tabClass =
    "h-12 flex items-center justify-center hover:cursor-pointer rounded-lg";
  let tabActiveClass = "bg-color2 text-white"

  const changeTab = (t) => tab.set(t);
</script>

<div class={tabsClass}>
  <button
    class={twMerge(tabClass, $tab === "todo" && tabActiveClass)}
    on:click={() => changeTab("todo")}>Todo</button
  >
  <button
    class={twMerge(tabClass, $tab === "done" && tabActiveClass)}
    on:click={() => changeTab("done")}>Done</button
  >
  <button
    class={twMerge(tabClass, $tab === "all" && tabActiveClass)}
    on:click={() => changeTab("all")}>All</button
  >
</div>
<div class="flex-1 overflow-auto">
  <slot></slot>
</div>
```
主要的逻辑修改就是，判断当前激活的是哪个tab，然后添加active样式，页面此时如下：
![active style](/images/svelte/18-1.png)
当点击其中一个tab时，能够看到tab样式的变化。

在store.js中添加待办项列表的数据：
```javascript
import { writable, derived } from 'svelte/store';

export const tab = writable('todo'); // todo | done | all
export const list = writable([]);

export const todoList = derived([list], ([$list]) => {
  return $list.filter(item => !item.done);
});

export const doneList = derived([list], ([$list]) => {
  return $list.filter(item => item.done);
});
```

修改List.svelte
```html
<script>
  import Item from './Item.svelte';
  import { tab, list, todoList, doneList } from './store';

  let currentList = [];

  $: {
    switch($tab) {
      case 'all': currentList = $list;
        break;
      case 'done': currentList = $doneList;
        break;
      default: 
        currentList = $todoList;
    }
  };
  
</script>

{#each currentList as {text, done}, i}
  <Item index={i} name={text} done={done} />
  {:else}
    No data
{/each}
```

然后我们开始为输入框添加事件，当点击按钮时，添加待办项：
```html
<script>
  import { list } from './store';

  let inputClass = "flex-1 h-full border rounded-lg mr-4 px-4 caret-color2 focus:outline-color2";
  let buttonClass = "w-[100px] h-full rounded-lg flex items-center justify-center bg-color2 text-white flex-shrink-0 hover:cursor-pointer";

  let task = ''
  const addItem = () => {
    if (!task) {
      return;
    }
    const obj = {
      id: new Date().valueOf(),
      text: task,
      done: false,
    };
    $list = [...$list, obj];
  };
</script>

<div class="flex h-12">
  <input
    type="text"
    bind:value={task}
    class={inputClass}
  />
  <button
    class={buttonClass} on:click={addItem}>Add</button
  >
</div>
```

![Add Todo Item](/images/svelte/18-2.gif)

在我们点击勾选后，已完成的待办项仍留在Todo栏里。
完善Item的逻辑，从外部接收tab参数，用来修饰index的样式，然后是为checkbox绑定更新事件：
```html
<script>
  import { createEventDispatcher } from 'svelte';
  import { twMerge } from 'tailwind-merge';
  
  export let tab = 'todo';
  
  const dispatch = createEventDispatcher();

  let indexWrapClass = "w-12 h-12 flex items-center justify-center"
  $: indexClass = twMerge(
    "w-8 h-8 text-left flex-shrink-0 rounded-full text-color1 flex items-center justify-center",
    tab === 'todo' && 'bg-color3',
    tab === 'done' && 'bg-color2',
    tab === 'all' && 'bg-color4',
  );

  ...

  const changeDone = (e) => {
    dispatch("change", { checked: e.target.checked });
  };
</script>

<div class={divClass}>
  <span class={indexWrapClass}>
    <span class={indexClass}>{index}</span>
  </span>
  <span class={nameClass}>{name}</span>
  <span class={checkboxWrapClass}>
    <input
      type="checkbox"
      checked={done}
      on:change={changeDone}
    />
  </span>
</div>

<style>
...
</style>
```

接着是外层的list，为Item绑定事件，用于更新store里的数据。剩余的是一些边角料工作，将index设置成从1开始`index={i + 1}`，传递tab参数，数据为空时的empty居中样式等。
```html
<script>
  import Item from "./Item.svelte";
  import { tab, list, todoList, doneList } from "./store";

  ...

  const updateItem = (id, value) => {
    const newArr = $list.map((item) => {
      if (item.id === id) {
        return {
          ...item,
          done: value,
        };
      }
      return item;
    });
    $list = newArr;
  };
</script>

{#each currentList as { id, text, done }, i}
  <Item
    index={i + 1}
    name={text}
    {done}
    tab={$tab}
    on:change={({ detail: { checked } }) => updateItem(id, checked)}
  />
{:else}
  <div class="mt-20 text-center">No data</div>
{/each}
```
写到这里，读者们应该能正常地添加任务，设置任务状态，然而细心的你一定能够发现，当我们设置完成时，出现了一点小问题：
![Error](/images/svelte/18-3.gif)  

当我们在设置第一项已完成后，第一项能够正常移除，然后剩余的第二项变成第一项后，勾选状态却是已完成！这个时候就轮到key出场了。

```html
{#each currentList as { id, text, done }, i (id)}
```

接着我们将All栏的展示改成禁止点击，现在Item.svelte中：
```html
<script>
  ...
  
  export let disabled = false;

  ...
  
  $: nameClass = twMerge(
    "flex-1 overflow-hidden text-ellipsis",
    disabled && "opacity-65"
  );
</script>

<div class={divClass}>
  ...
  <input
    type="checkbox"
    checked={done}
    on:change={changeDone}
    {disabled}
  />
  ...
</div>

<style>
  ...

  input[type="checkbox"]:disabled::before {
    box-shadow: inset 1em 1em #FFADA8;
  }
</style>
```

然后在List.svelte中
```html
<Item
  ...
  disabled={$tab === 'all'}
/>
```
## 动画

在之前我们mock数据时，如果读者们点击过勾选框，应该能注意到有动画效果。然而经过上述的一系列改动，我们发现，当我们点击勾选后，已完成的数据马上被移到Done的Tab栏。

为了能够观察到动画效果，在List.svelte中，我们将数据更新做一个延迟
```javascript
const updateItem = (id, value) => {
  const newArr = $list.map((item) => {
    if (item.id === id) {
      return {
        ...item,
        done: value,
      };
    }
    return item;
  });
  setTimeout(() => {
    $list = newArr;
  }, 300);
};
```

接着我们为Item.svelte添加一些Svelte自带的动画效果
```html
<script>
  import { slide } from "svelte/transition";

  ...
</script>

<div class={divClass} transition:slide>
  ...
</div>

<style>
  ...
</style>
```

至此，我们已基本完成了一个功能完整的TodoList项目。

![End](/images/svelte/18-4.gif)

## 小结

本章我们完成了：
- 使用`svelte/store`进行状态管理
- 循环列表中key值的使用，防止不正常的渲染
- 为待办项的增加和减少添加动画---
title: Svelte从入门到精通——props
description: 【对比篇】props
---

UI组件库的一大特性便是组件化，我们除了在当前组件设置数据之外，绝大多时候，都需要把数据传递给其他组件使用。比如我们抽象了一些公共逻辑，写了一个公共组件，公共组件通过接收数据来展示不同的功能，而不同的页面在引用公共组件时，便需要向这个公共组件传递数据。那我们应该如何向不同组件传递数据，甚至传递方法呢？  

组件之间的通信包括了父组件向子组件传值，这里的传值可能包括了传递数据和传递方法，子组件消费父组件的数据和调用父组件的方法；也可能父组件直接使用子组件的数据和调用子组件的方法；甚至存在跨层级的组件之间的传值。

## React

### 传值
React由于使用的是jsx语法，写法非常灵活，定义一个继承React.Component的class或者写一个有html返回内容的function就是一个组件。

在父组件中，我们把定义好的数据和方法当做子组件的属性，以`key={value}`的形式进行传递。
```javascript
// Father.jsx
import Child from './Child';

export default function Page() {
  const [name] = useState("hello");
  const sayHello = () => {
    console.log("hello");
  };
  return (
    <Child name={name} sayHello={sayHello} />
  );
}
```

而在子组件中，通过props来接收从父组件传递过来的数据。
```javascript
// Child.jsx
export default function Child(props) {
  const { name, sayHello } = props;
  const onClickFunc = () => {
    sayHello();
  };
  return (
    <div>
      <span>name: {name}</span>
      <button onClick={onClickFunc}>
        调用父级方法
      </button>
    </div>
  );
}
```

在`class component`中的使用大同小异：
```javascript
import React from 'react';

class Child extends React.Component {
  constructor(props) {
    super(props)
  }
  render() {
    const { count } = this.props;
    return <div>子组件 {count}</div>
  }
}

export default class Father extends React.Component {
  constructor() {
    super();
    this.state = {
      count: 1
    };
  }
  render() {
    const {count} = this.state;
    return <Child count={count}></Child>
  }
}
```

React接收props需要考虑组件重复渲染的问题，为此，可以结合`memo()`、 `useMemo`、`useCallback`、`shouldComponentUpdate`等一系列优化的方法来使用。

### 类型限定
组件通过props接收外部传递的值，然而如果传递的值的类型不符合组件的要求，可能会导致组件内的逻辑错误，因此，限定props的传值类型是很有必要的。  

在React中，可以如下进行类型限定：

```javascript
/**
 * FUNCTIONAL COMPONENTS
 */
function ReactComponent(props) {
  // ...你的逻辑
}

ReactComponent.propTypes = {
  // ...prop的类型限定
}

/**
 * CLASS COMPONENTS: 方式1
 */
class ReactComponent extends React.Component {
  // ...你的逻辑
}

ReactComponent.propTypes = {
  // ...prop的类型限定
}

/**
 * CLASS COMPONENTS: 方式2
 */
class ReactComponent extends React.Component {
  // ...你的逻辑

  static propTypes = {
    // ...prop的类型限定
  }
}
```

另一种方式是使用[props-type](https://github.com/facebook/prop-types/tree/main)库。
```bash
npm install prop-types --save
```

```javascript
import React from 'react';
import PropTypes from 'prop-types';

class MyComponent extends React.Component {
  render() {
    // ... do things with the props
  }
}

MyComponent.propTypes = {
  // You can declare that a prop is a specific JS primitive. By default, these
  // are all optional.
  optionalArray: PropTypes.array,
  optionalBigInt: PropTypes.bigint,
  optionalBool: PropTypes.bool,
  optionalFunc: PropTypes.func,
  optionalNumber: PropTypes.number,
  optionalObject: PropTypes.object,
  optionalString: PropTypes.string,
  optionalSymbol: PropTypes.symbol,
  ...
}
```

## Vue

### 传值
Vue使用的是单文件的组织形式，在一个文件中，我们在template这种写html内容，然后分别在script标签内和style标签内定义组件的脚本和样式。

在Vue中，父组件将数据以`:key="value"`或`key="value"`的形式向子组件传值（传变量时使用`:key`，传常量时使用`key`）；以`@function="callback"`的形式来监听子组件派发的事件。

```html
<!-- Father.vue -->
<template>
  <Child :name="name" @sayHello="sayHello" />
</template>

<script setup>
  import { ref } from "vue";
  import Child from "./Child.vue";
  
  const name = ref("hello");
  const sayHello = () => {
    console.log("hello");
  };
</script>
```

在Vue 3.x中，子组件通过`defineProps([key])`接收对应的传值，通过`defineEmits(['function'])`的方式对外派发事件。
```html
<!-- Child.vue -->
<template>
  <div>
    <span>name: {{ name }}</span>
    <button @click="onClickFunc">
      调用父级方法
    </button>
  </div>
</template>

<script setup>
import { ref } from "vue";
const props = defineProps(["name"]);
const name = ref(props.name);

const emit = defineEmits(["sayHello"]);

const onClickFunc = () => {
  emit("sayHello");
};
</script>
```


以上例子在Vue 2.x中如下：
```html
<!-- Father.vue -->
<template>
  <Child :name="name" @sayHello="sayHello" />
</template>

<script>
import Child from "./Child.vue";

export default {
  data() {
    return {
      name: "hello",
    };
  },
  methods: {
    sayHello() {
      console.log("hello");
    },
  },
  components: {
    Child,
  },
};
</script>
```

子组件通过`props: {}`来接收数据，通过`this.$emit('function')`的方式来派发事件。
```html
<!-- Child.vue -->
<template>
  <div>
    <span>name: {{ name }}</span>
    <button @click="onClickFunc">
      调用父级方法
    </button>
  </div>
</template>

<script>
export default {
  props: {
    name,
  },
  methods: {
    onClickFunc() {
      this.$emit('sayHello');
    }
  }
}
</script>
```
### 类型限定

在Vue 3.x中，在`defineProps({ key: Type })`中定义：
```html
<!-- Child.svelte -->
<template>
  <div>子组件</div>
</template>

<script setup>
defineProps({
  str: String,
  num: Number,
  bool: Boolean,
  arr: Array,
  obj: Object,
  func: Function,
  promise: Promise,
});
</script>
```

```html
<!-- App.svelte -->
<template>
  <Child :str="str" :num="num" />
</template>

<script setup>
import { ref } from 'vue';
import Child from "./Child.vue";

let str = ref(1);
let num = ref(1);
</script>
```

在Vue 2.x中，通过`props: { key: Type }`的形式进行类型限定：
```html
<!-- Child.svelte -->
<template>
  <div>子组件</div>
</template>

<script>
export default {
  props: {
    str: String,
    num: Number,
    bool: Boolean,
    arr: Array,
    obj: Object,
    func: Function,
    promise: Promise,
  },
};
</script>
```

```html
<!-- App.svelte -->
<template>
  <Child :str="str" :num="num" />
</template>

<script>
import Child from "./Child.vue";

export default {
  data() {
    return {
      str: 1,
      num: 1,
    };
  },
  components: {
    Child,
  },
};
</script>
```

当我们传递了错误的类型时，可以看到控制台的警告信息。
![](/images/svelte/24-1.png)

## Svelte
Svelte同样使用的是sfc的形式。

Svelte在父组件中通过`on:[function]={callback}`的形式为子组件添加事件绑定，通过`key={value}`的形式传递。
```html
<script>
  import Child from './Child.svelte';
  let name = 'hello';

  const sayHello = () => {
    console.log('hello');
  }
</script>

<Child name={name} on:sayHello={sayHello} />
```

在子组件中，通过`export`的方式，将原本限定在组件内的变量，改为能够接受外部的传值。而调用父组件的则通过调用`createEventDispatcher`方法来创建一个对象，通过调用该对象来调用父组件的方法。如果需要传值，则通过`dispatch(方法名, 值)`的形式传递。

```html
<script>
  import { createEventDispatcher } from "svelte";
  const dispatch = createEventDispatcher();

  export let name;

  const onClickFunc = () => {
    dispatch("sayHello");
  };
</script>

<div>
  <span>name: {name}</span>
  <button on:click={onClickFunc}>
    调用父级方法
  </button>
</div>
```

在父组件传值的形式比较像React，子组件派发事件的形式比较像Vue。

### 类型限定

Svelte目前官方没有给出内置的props校验api，但强大的Typescript能够帮助我们完成这一功能。

## Typescript

[Typescript](https://www.typescriptlang.org/)是一种基于 JavaScript 构建的强类型编程语言。我们不仅能在Svelte中使用Typescript进行类型校验，在React、Vue中同样可以使用。

在React中，需要在`tsx`文件中使用Typescript。
```javascript
// Child.tsx
function MyButton({ title }: { title: string }) {
  return (
    <button>{title}</button>
  );
}
```

在Vue中，需要把`<script>`标签置为ts类型
```html
<script setup lang="ts">
interface Props {
  foo: string
  bar?: number
}

const props = defineProps<Props>()
</script>
```

在Svelte中，同样需要把`<script>`标签类型置为ts。
```html
<script lang="ts">
  export let name: string;
</script>
```

## 小结

本章我们对比了：
- React页面往组件传值使用`key={value}`的形式；组件接收外部的值通过`props`属性接收
- Vue页面往组件传值使用`:key="value"`或`key="value"`的形式；在`2.x`中组件接收外部的值通过`props: {}`来接收，在`3.x`中组件接收外部的值通过`defineProps([key])`的形式
- Svelte同样是通过`key={value}`的形式往组件内传值，而组件接收外部的值则通过`export let key`的形式
- React父子页面事件的沟通仍通过props传递实现
- Vue通过`@function="callback"`的形式监听子页面派发的事件，在`2.x`中子页面通过`this.$emit()`的方式派发事件，在`3.x`中子页面通过`defineEmits()`来派发事件
- Svelte中父页面通过`on:[function]={callback}`的形式监听子页面派发的事件，在子页面中则需借助`createEventDispatcher`来进行事件派发
- 三大框架对props传值类型的限定

---
title: Svelte从入门到精通——Alert组件之slot交互
description: 【实战篇】Alert组件之slot交互
---

## api
![](/images/svelte/19-2.png)  
接下来我们完成剩余的api，主要有afterClose回调、closeText、description、icon、message。

在Svelte中，我们不能像react那样直接把组件当成一个props来传递，因此对于一些既支持传数据又支持传组件的参数，我们的在Svelte的实现是既支持传值，又支持slot定义。然后在组件内容判断是否有slot值。
```javascript
function getPropsSlot(slots, props, prop = 'default') {
  if (props && props[prop]) {
    return props[prop];
  }
  if (slots && slots[prop]) {
    return slots[prop];
  }
  return null;
}
const slots = $$slots;
const props = $$props;
```

### closeText

```javascript
export let closeText = undefined;

const closeTextData = getPropsSlot(slots, props, 'closeText');
const hasCloseTextSlot = !!slots?.closeText;

if (closeTextData) {
  closable = true;
}
```

修改html的内容
```html
{#if closable}
  <a
    href={""}
    on:click|preventDefault={handleClose}
    class={`${prefixCls}-close-icon`}
    role="button"
    tabindex="0"
  >
    {#if hasCloseTextSlot}
      <slot name="closeText" />
    {:else if closeTextData}
      {closeText}
    {:else}
      <i class={`anticon anticon-close ${prefixCls}-icon`}>
        <CloseIcon />
      </i>
    {/if}
  </a>
{/if}
```

App.svelte中试验一下：
```html
<script>
  import Alert from "./Alert.svelte";
</script>

<Alert closeText="Close Text">Text</Alert>
<br />
<Alert type="success">
  Text
  <div slot="closeText">Close Text2</div>
</Alert>
<br />
```
![](/images/svelte/20-2.gif)

### message

```javascript
export let message = undefined;
const messageData = getPropsSlot(slots, props, 'message');
const hasMessageSlot = !!slots?.message;
```
修改我们最开始定义的slot
```html
<div class={`${prefixCls}-content`}>
	{#if showIcon}
	<i class={`anticon ${prefixCls}-icon`}>
	  <svelte:component this={icon} />
	</i>
	{/if}
	{#if messageData}
	  {#if hasMessageSlot}
		<slot name="message" />
	  {:else}
		<div class={`${prefixCls}-message`}>{message}</div>
	  {/if}
	{/if}
</div>
```

在App.svelte中试验一下：
```html
<script>
  import Alert from "./Alert.svelte";
</script>

<Alert closable message="message" />
<br />
<Alert type="success" closable>
  <div slot="message" style="color: red;">message2</div>
</Alert>
<br />
```

![](/images/svelte/20-3.png)

### description

```javascript
export let description = undefined;
const descriptionData = getPropsSlot(slots, props, 'description');
const hasDescriptionSlot = !!slots?.description;
```
在Antd的Alert组件中，当使用了description时，需要使用另一种样式的icon，为此我们需要重构下我们的icon组件，笔者这里只拿SuccessIcon作为例子，其他type的icon更改逻辑相同。

SuccessIcon.svelte：
```html
<script>
  export let theme = "filled";
</script>

{#if theme === "filled"}
  <svg
    viewBox="64 64 896 896"
    focusable="false"
    class=""
    data-icon="check-circle"
    width="1em"
    height="1em"
    fill="currentColor"
    aria-hidden="true"
    ><path
      d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 0 1-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z"
    ></path></svg
  >
{/if}
{#if theme === "outlined"}
  <svg
    viewBox="64 64 896 896"
    focusable="false"
    class=""
    data-icon="check-circle"
    width="1em"
    height="1em"
    fill="currentColor"
    aria-hidden="true"
    ><path
      d="M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0 0 51.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z"
    ></path><path
      d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
    ></path></svg
  >
{/if}
```

```javascript
let iconTheme = 'filled';

if (!!descriptionData) {
  iconTheme = 'outlined';
}
```

```javascript
$: alertCls = classNames(prefixCls, {
    [`${prefixCls}-${type}`]: true,
    [`${prefixCls}-no-icon`]: !showIcon,
    [`${prefixCls}-banner`]: banner,
    [`${prefixCls}-closable`]: closable,
    [`${prefixCls}-with-description`]: !!descriptionData,
});
```

在App.svelte中试验下
```html
<script>
  import Alert from "./Alert.svelte";
</script>

<Alert
  message="Success Tips"
  description="Detailed description and advice about successful copywriting."
  type="success"
  showIcon
/>
<br />
<Alert message="Infomation Tips" showIcon>
  <div slot="description">
    Additional description and information about copywriting.
  </div>
</Alert>
```

![](/images/svelte/20-4.png)

### icon
```javascript
const hasIconSlot = !!slots?.icon;
```

修改html内容
```html
{#if showIcon}
  {#if hasIconSlot}
	<slot name="icon" />
  {:else}
	<i class={`anticon ${prefixCls}-icon`}>
	  <svelte:component this={icon} theme={iconTheme} />
	</i>
  {/if}
{/if}
```

我们自定义一个Icon组件，笔者这里就不列出这部分代码了，读者朋友们可以自行定义。
在App.svelte中验证一下

```html
<script>
  import Alert from "./Alert.svelte";
  import SvelteIcon from "./icon/SvelteIcon.svelte";

</script>

<Alert
  message="Success Tips"
  type="success"
  showIcon
>
  <SvelteIcon slot="icon" />
</Alert>
```

![](/images/svelte/20-5.png)

我们还剩余一部分内容，那就是关闭时的动画，在下一章中进行讲解。

## 小结

本章我们完成了：
- `$$props`和`$$slots`的使用
- `<slot>`插槽的使用
---
title: Svelte从入门到精通——data
description: 【对比篇】data
---

经过了入门篇与进阶篇的学习，相信大家对Svelte都有了一定的了解。接下来我们将对比Svelte与React、Vue之间的语法差异，最后一次加强对Svelte的api的掌握程度。经过对比篇的学习之后，相信大家在脑海中都会形成“关于一个UI框架应该向使用者提供何种公共能力”的思维脑图。

从本篇开始，笔者会带领大家从多个维度认识和学习相同的功能在React、Vue和Svelte中是如何实现的。如果你已经是Vue或者React的老手，那可以跳过篇章或加强巩固；而如果你是其中一种框架的使用者想快速学习另外一种，或是毫无UI框架使用经验的新人，相信本篇章会大大提升你的学习速度。

## React

在React中，使用的是[jsx](https://legacy.reactjs.org/docs/introducing-jsx.html)的语法。
元素标签内使用变量的方式是把变量放置在`{}`单个花括号内。

### function component

在React中声明组件有两种方式，我们称之为`class component`和`function component`。
在16.8^的版本，推荐使用`function component`以及`hooks`。在`function component`中，使用`useState`来进行变量声明和更新。UI展示内容写在页面函数的`return`当中。

```javascript
const [value, setValue] = useState(null)
```

具体如下：
```javascript
import { useState } from "react";

export default function Page() {
  const [count] = useState(0);

  return (
    <div>变量：{count}</div>
  );
}
```

`useState`接收一个参数作为一个初始数据，返回一个数组，数组的第一个值表示变量，第二个值表示用于更新变量的方法。在上述例子中，我们只演示了变量的声明和使用，更新数据的方法，我们将在下一节进行展示。

### class component
而在16.8之前使用`class component`时，通过`this.state`来存储、获取数据，通过`setState`来进行数据更新。UI展示内容写在组件类的`render`方法的`return`当中。

```javascript
import React from 'react';

export default class Page extends React.Component {
  constructor() {
    super();
    this.state = {
      count: 0
    }
  }
  render() {
    const { count } = this.state;
    return (
      <div>
        count: {count}
      </div>
    )
  }
}
```

可以发现，如果我们使用`class component`，代码量比`function component`多了不少。

## Vue

Vue使用的是[sfc](https://cn.vuejs.org/guide/scaling-up/sfc)的文件组织方式。html、css、js分块管理。html内容写在`<template></template>`内，css写在`<style></style>`内，js写在`<script></script>`内。

在Vue中，元素标签内使用变量的方式是把变量放置在 `{{}}`双个花括号内。

### 3.x

```html
<template>
  <div>变量：{{ count }}</div>
</template>

<script setup>
import { ref, reactive} from 'vue';

const count = ref(0);
const obj = reactive({ a: 'b' });
console.log(count.value, obj);
</script>
```

在Vue 3.x的composition api中，可以通过`ref`或者`reactive`来声明变量。如果你掌握vue3，那在面试中大概率会问到`ref`和`reactive`的区别，简单概括就是，如果你想声明一个引用类型的响应式对象，那使用`reactive`。而如果想把一个简单类型的对象声明成响应式，那使用ref来声明定义。
使用`ref`定义的对象，要求我们在使用时需要通过 `.value`来取值。这点无疑加重了我们在使用时的心智负担。因为我们不是介绍Vue的专题文章，这里就简述了解即可，待感兴趣的读者深入探究。

### 2.x
在Vue 2.x中，变量声明在data()方法中，在data()方法中，我们返回一个对象，把需要定义的变量全部申明在这个对象里。而在生命周期或声明的方法里使用数据时，则需要用 `this.数据`的方式来使用。

```html
<template>
  <div></div>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    }
  },
  mounted() {
    console.log(this.count)
  }
}
</script>
```

### 双向绑定
在vue中，使用`v-model`来进行双向绑定。

```html
<template>
  <input type="text" v-model="message" />
</template>

<script>
export default {
  data() {
    return {
      message: ''
    };
  },
};
</script>
```

## Svelte

Svelte的文件内容同样使用sfc的组织方式。

Svelte元素标签中使用变量的方式和React相同，使用单个花括号的形式。当然以上这些框架内的mustache标签内使用的变量都是简单类型，如果是引用类型，那么需要使用者进行解构。

```html
<script>
  let count = 0;
  let arr = [];
  let obj = {a: 'a'};
</script>

<div>变量：{ count }</div>
<div>{ obj }</div> // 错误
<div>{ obj.a }</div> // 正确
```

可以看到，变量声明在Svelte中的声明相比其他两个库，写起来要简介不少，和我们平时直接使用js来声明变量无异。

### 双向绑定
在Svelte中，如果我们要使用双向绑定，则写法如下：

```html
<script>
  let message = '';
</script>

<input type="text" bind:value={message} />
```

## 小结

本章我们对比了：
- React在`function component`中可以通过`useState()`来声明和更新数据，而在`class component`中则通过`this.state`来实现。变量在`{}`单花括号中展示。
- Vue在`3.x`中通过`ref`和`reactive`来声明变量，在`2.x`中通过`data() { return {}}`来声明存储变量。变量在`{{}}`双花括号中展示。
- Svelte中像正常js般声明变量即可。变量也是在`{}`单花括号中展示。
- Vue的双向数据绑定使用`v-model`来实现
- Svelte的双向数据绑定使用`bind:`来实现。
---
title: Svelte从入门到精通——lifecycle
description: 【对比篇】lifecycle
---

组件都伴随着生命周期，一个组件通常都存在着创建、更新、销毁等这几个相同的生命周期，而不同的框架由于各自实现的不同，往往提供了除这些共同生命周期之外的一些差异化生命周期。

## React

![](/images/svelte/25-1.png) 
[图片来源](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

- `constructor`：一个构造器，里面可以接收一个父组件传来的props然后初始化state值。
- `static getDerivedStateFromProps`：取代了旧的`componentWillMount`、`componentWillReceiveProps`、`componentWillUpdate`这三个钩子。
- `render`：定义展示到页面上的html内容，render执行完后将内容渲染到浏览器上。
- `componentDidMount`：在组件挂载完毕后执行。
- `shouldComponentUpdate`：当更新state值的时候会执行这个函数，通常用做优化页面的手段。
- `getSnapshotBeforeUpdate`：这个钩子可获取到即将要更新的props和state。
- `componentDidUpdate`：组件更新完毕执行的钩子函数。
- `componentWillUnmount`：组件将要卸载时执行。

除此之外，还有`static getDerivedStateFromError`、`componentDidCatch`用来处理页面报错的钩子。老实说，笔者一直对react的生命周期感到头疼。

## Vue

![](/images/svelte/25-2.png)
[图片来源](https://vuejs.org/guide/essentials/lifecycle)

在Vue 2.x中，
- `beforeCreate`：实例化之后，数据的观测和事件的配置之前的时候调用。
- `created`：在实例创建完成后被立即同步调用。
- `beforeMount`：在挂载开始之前被调用。
- `mounted`：实例被挂载后调用。
- `beforeUpdate`：在数据发生改变后，DOM被更新之前调用。
- `updated`：由于数据更改导致的虚拟 DOM 重新渲染，在更新完后会调用该钩子。
- `beforeDestroy`：在实例销毁之前调用。
- `destroyed`：实例销毁后调用。

当为页面添加了keep-alive属性后，需要注意在`activated`和`deactivated`这两个生命钩子中进行一些操作。

在Vue3.x中：
- `onBeforeMount`：在挂载开始之前被调用。
- `onMounted`：组件挂载时调用。
- `onBeforeUpdate`：数据更新时调用。
- `onUpdated`：由于数据更新导致的虚拟 DOM 重新渲染，在更新之后会调用该钩子。
- `onBeforeUnmount`：在卸载组件实例之前调用。
- `onUnmounted`：卸载组件实例后调用。

同时也提供了在keep-alive时使用的生命周期钩子`onActivated`、`onDeactivated`和用于捕获页面错误的钩子`onErrorCaptured`。

## Svelte

![](/images/svelte/25-3.png)

- `onMount`：组件首次渲染到DOM后立即执行
- `beforeUpdate`：在DOM更新之前执行
- `afterUpdate`：数据同步到DOM之后执行
- `onDestroy`：组件销毁时执行
- `tick`：返回一个promise，让后续代码在下一次微任务中执行

## 小结

本章我们对比了：
- 三大框架的生命周期函数及流程图
- 框架对外提供的生命周期数量是否越多越好，仁者见仁。一方面，繁多的生命周期钩子可以让开发者更细致地控制组件；而另一方面，大量的生命周期钩子也提升了框架的学习曲线。---
title: Svelte从入门到精通——slot
description: 【对比篇】slot
---

## React

### 默认slot

在父组件中，在使用子组件时，直接在子组件标签内填充内容：
```javascript
// Father.jsx
import SlotContainer1 from './Child1'

export default function Page() {
  return (
    <SlotContainer1>hello world</SlotContainer1>
  );
}
```

在子组件中，通过props中的`children`属性来接收插槽内容。
```javascript
// Child1.jsx
export default function SlotContainer1(props) {
  const { children } = props;
  return <div>{children}</div>;
}
```
### 具名slot

在父组件中，除了在子组件标签内天加内容外，还可以通过props的形式来传递组件。
```javascript
// Father.jsx
import SlotContainer2 from './Child2';

export default function Page() {
  return (
    <SlotContainer2 header={<span>父组件header</span>} footer="父组件footer">
      hello world2
    </SlotContainer2>
  );
}
```

在子组件中，通过props除了接收到默认插槽内容children，还可以通过其他自定义属性来实现具名插槽。
```javascript
// Child2.jsx
export default function SlotContainer2(props) {
  const { header, footer, children } = props;
  return (
    <div>
      <header>{header}</header>
      <section>子组件原有内容</section>
      <section>{children}</section>
      <footer>{footer}</footer>
    </div>
  );
}
```

### slot传值

在实际业务开发中，当然不可能都是简单的直接在子组件内填充静态内容，往往涉及到组件内部希望往插槽的内容传递数据。最常见的例子就是表格组件，笔者这里举个伪代码的例子：
```javascript
<Table data={list}>
  <column slot="a">{item}</column>
</Table
```
在单元格中，往往需要自定义单元格内容，此时我们就需要从组件内接收到单元格的数据，然后再自定义slot的内容展示。

这里演示一种称为[Render Props](https://legacy.reactjs.org/docs/render-props.html)的实现方式：
```javascript
const Child = ({ children }) => (
  <div>
    {children({ message: 'Hello World' })}
  </div>
);

export default function Father() {
  return (
    <Child>
      {({ message }) => <p>{message}</p>}
    </Child>
  );
} 
```

## Vue

### 默认slot

同样是在子组件中直接插入内容：
```html
<!-- Father.vue -->
<template>
  <SlotContainer1>hello world</SlotContainer1>
</template>

<script setup>
import SlotContainer1 from "./Child1.vue";
</script>
```

子组件中，声明用于接收插槽内容的标签`<slot>`：
```html
<!-- Child1.vue -->
<template>
  <slot></slot>
</template>
```

### 具名slot

在页面中，除了往组件标签内插入默认内容外，还能通过`v-slot`标签来表示往具体名称的插槽中填值，`#name`的表示形式是`v-slot:name`的简写。

```html
<!-- Father.vue -->
<template>
  <SlotContainer2>
    hello world2
    <template v-slot:header>父组件header</template>
    <template #footer>父组件footer</template>
  </SlotContainer2>
</template>

<script setup>
import SlotContainer2 from "./Child2.vue";
</script>
```

在子组件中，要定义一个具名插槽，需要在`<slot>`标签中定义`name="value"`。
```html
<!-- Child2.vue -->
<template>
  <div>
    <header><slot name="header"></slot></header>
    <section>子组件原有内容</section>
    <slot></slot>
    <footer><slot name="footer"></slot></footer>
  </div>
</template>
```

### slot传值

在拥有插槽定义的组件内，像普通传参一样传值：
```html
<!-- Child.vue -->
<template>
  <slot message="Hello World"></slot>
</template>
```

在外部引用组件时，通过`v-slot="props"`接收组件内传递过来的值：
```html
<!-- Father.vue -->
<template>
  <Child v-slot="slotProps">{{ slotProps.message }}</Child>
</template>

<script setup>
import Child from "./Child.vue";
</script>
```

## Svelte

### 默认slot

在父组件中，同样是正常往组件标签内填充内容：
```html
<script>
// Father.svelte
  import SlotContainer1 from './Child1.svelte';
</script>

<SlotContainer1>
  hello world
</SlotContainer1>
```

子组件内，同样使用`<slot>`标签接收插槽内容：
```html
<!-- Child1.svelte -->
<slot></slot>
```

### 具名slot

通过`slot="name"`来标注往具体名称的插槽中填充内容：
```html
<script>
// Father.svelte
  import SlotContainer2 from './Child2.svelte';
</script>

<SlotContainer2>
  hello world2
  <span slot="header">父组件header</span>
  <span slot="footer">父组件footer</span>
</SlotContainer2>
```

在子组件中，同样为`<slot>`标签设置`name="name"`来添加具名插槽。
```html
<!-- Child2.svelte -->
<div>
  <header><slot name="header"></slot></header>
  <section>子组件原有内容</section>
  <slot></slot>
  <footer><slot name="footer"></slot></footer>
</div>
```

### slot传值

在拥有插槽定义的组件内，像普通传参一样传值：
```html
<!-- Child.svelte -->
<slot message={"Hello World"}></slot>
```

在外部引用组件时，通过`let:name={value}`的形式来接收组件内传递过来的值：
```html
<script>
// Father.svelte
  import Child from './Child.svelte';
</script>

<Child let:message={message}>
  {message}
</Child>
```

## 小结

本章我们对比了：
- React通过props上的children来接收插槽内容，通过render props的方式来进行插槽和组件间的传值
- Vue通过`<slot>`标签来完成插槽功能。通过`<slot name="x">`的形式来定义特定名称的插槽占位，然后外部通过`v-slot:name`或`#name`来向具名插槽填值。Vue的slot和组件间的传值通过`<slot message>`和`v-slot`来实现。
- Svelte同样通过`<slot>`标签来实现插槽。通过`<slot name="x">`的形式来定义特定名称的插槽占位，外部通过`slot="name"`来向具名插槽填值。Svelte的slot和组件间的传值通过`<slot xxx={}>`和`let:xxx={}`的形式来实现。
---
title: Svelte从入门到精通——reactivity
description: 【对比篇】reactivity
---

## 计算属性
所谓“计算属性”，是指某些变量依赖于其他变量而更新，当其依赖的变量更新时，这些计算属性才会执行更新。比如设置一个area为计算属性，它依赖于width和height两个变量，当width和height其中一个变量发生变化时，area也会响应式地进行自身的更新。

### React

```javascript
import { useState, useMemo } from "react";

export default function Page() {
  const [count, setCount] = useState(0);

  const doubleCount = useMemo(() => {
    return count * 2;
  }, [count]);

  const updateCount = () => {
    setCount(count + 1);
  };

  return (
    <section>
      <button onClick={updateCount}>+1</button>
      <span>
        {count}的2倍是：{doubleCount}
      </span>
    </section>
  );
}

```
React中可以使用`useMemo`这个hooks来实现计算属性。`useMemo(() => {}, [])`，在第二个数组中添加需要监听的依赖，执行useMemo得到一个计算属性。当数组中的变量发生更新，计算属性也会重新计算。

### Vue

在Vue 3.x的composition api中，使用`computed()`来实现计算属性：
```html
<template>
  <section>
    <button @click="updateCount">+1</button>
    <span>
      {{count}}的2倍是：{{doubleCount}}
    </span>
  </section>
</template>

<script setup>
import { ref, computed } from 'vue';

let count = ref(0);

let doubleCount = computed(() => {
  return count.value * 2
});

const updateCount = () => {
  count.value++;
}
</script>
```

在Vue 2.x的options api中，把计算属性统一放在`computed: {}`中：
```html
<template>
  <section>
    <button @click="updateCount">+1</button>
    <span> {{ count }}的2倍是：{{ doubleCount }} </span>
  </section>
</template>

<script>
export default {
  data() {
    return {
      count: 0,
    };
  },
  computed: {
    doubleCount() {
      return this.count * 2;
    },
  },
  methods: {
    updateCount() {
      this.count++;
    },
  },
};
</script>
```

### Svelte

```html
<script>
  let count = 0;

  $: doubleCount = count * 2;

  const updateCount = () => {
    count++;
  };
</script>

<section>
  <h1>第六章 —— computed</h1>
  <button on:click={updateCount}>+1</button>
  <span>
    {count}的2倍是：{doubleCount}
  </span>
</section>

```

Svelte中，把需要设置成计算属性的变量放入`$:`中。  

计算属性只是一种便捷的响应式地更改数据的方式，我们当然也可以在监听响应事件时对这些数据进行更改，只是那样就稍微有点多余了。下面和大家一起了解下响应事件。

## 响应事件

对于一些比较简单的变量，可以通过简单的表达式将它们转变为计算属性。然而有时，我们需要监听这些变量的改变，不是为了得到一个计算属性，而是想进行更为复杂的操作，那这时我们就需要有能够监听到变量改变就执行的方法，笔者暂时称其为响应事件。

### React

```javascript
import { useEffect, useState } from 'react';

export default function Page() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('count改变了');
  }, [count]);

  const updateCount = () => {
    setCount(count + 1);
  }

  return (
    <section>
      <button onClick={updateCount}>+1</button>
      <span>count: {count}</span>
    </section>
  )
}
```
在React中，`useEffect(() => {}, [])`有多种功能，当我们不在第二个数组参数里添加任何依赖时，它能够代替mount生命周期来调用，当我们在数组里添加变量时，`useEffect`会监听这些变量的更新，从而执行第一个参数里的函数逻辑。

### Vue

在Vue 3.x中，使用`watch()`监听依赖变更，从而执行相应回调：
```html
<template>
  <section>
    <button @click="updateCount">+1</button>
    <span>count: {{count}}</span>
  </section>
</template>

<script setup>
import { watch, ref } from "vue";

let count = ref(0);

const updateCount = () => {
  count.value++;
};

watch(
  () => count.value,
  () => {
    console.log("count改变了");
  }
);
</script>
```

在Vue 2.x中，使用`watch: {}`来监听变量的更新：
```html
<template>
  <section>
    <button @click="updateCount">+1</button>
    <span>count: {{ count }}</span>
  </section>
</template>

<script>
export default {
  data() {
    return {
      count: 0,
    };
  },
  watch: {
    count(value) {
      console.log("count改变了");
    },
  },
  methods: {
    updateCount() {
      this.count++;
    },
  },
};
</script>
```

### Svelte

```html
<script>
  let count = 0;
  let oldCount = count;
  
  $: if (count !== oldCount) {
    console.log('count改变了');
    oldCount = count;
  }

  const updateCount = () => {
    count++;
  }
</script>

<section>
  <button on:click={updateCount}>+1</button>
  <span>count: {count}</span>
</section>
```

在计算属性中我们提到，可以把一个变量放到`$:`中，通过在里面执行表达式而把这个变量转变成计算属性，其实我们也可以把这个变量放置在`$:`之外，然后在`$:`中监听变量更新来操作。
`$: area = width * height;`其实等价于：
```javascript
let area;
$: {
	area = width * height
}
```

不错，`$:`除了能执行简单的表达式，还能执行复杂的函数逻辑，如：
```javascript
$: if () {}

$: {}
```
我们要确保需要监听的变量在`$: {}`或`$: if()`内。

## 小结

本章我们对比了：
- React可以使用`useMemo`来实现计算属性，通过`useEffect`来实现监听变量后的操作。
- Vue通过`computed`来实现计算属性，通过`watch`来实现监听变量后的操作。
- Svelte通过`$`来实现计算属性，通过`$: {}`来实现监听变量的操作。---
title: Svelte从入门到精通——ref
description: 【对比篇】ref
---

ref主要用于获取组件实例或访问 DOM 节点,也可以用于组件间通信。

## React

React中使用ref的主要形式如下：
```javascript
import { useRef } from 'react';

export default function Page() {
  const ref = useRef();
  return <div ref={ref} />
}
```

### 元素标签

如果我们把ref绑定到html标签上，可以直接获取到DOM节点。
首先通过`useRef`声明变量（在React中，`useRef`还能用来存储不会触发重新渲染的值），这个变量是一个对象，当其有值时，需要通过`ref.current`来获取其中的值，比如下列例子中的`faterRef.current`：

```javascript
// Father.jsx
import { useRef, useEffect, useState } from "react";

export default function Page() {
  const fatherRef = useRef(null);
  const [className, setClassName] = useState("");

  useEffect(() => {
    if (fatherRef && fatherRef.current) {
      setClassName(fatherRef.current.className);
    }
  }, [fatherRef]);

  return (
    <section>
      <div ref={fatherRef} className="w-10 h-10 border"></div>
      <div>className is: {className}</div>
    </section>
  );
}
```

### 组件

如果把ref绑定到组件上，可以获取取件的实例。

在子组件中，我们定义了一个方法，如果我们希望把子组件的方法对外暴露，需要使用`useImperativeHandle`和`React.forwardRef`的方式。

```javascript
// Child.jsx
import React, { useImperativeHandle } from "react";

function _Child(props, ref) {
  const sayHello = () => {
    console.log("hello");
  };

  useImperativeHandle(ref, () => {
    return {
      sayHello
    }
  });

  return <div>子应用</div>;
}
export default React.forwardRef(_Child);
```

而在父组件中：
```javascript
import { useRef, useEffect, useState } from "react";
export default function Page() {
  const childRef = useRef(null);

  const sayHello = () => {
    if (childRef && childRef.current) {
      childRef.current.sayHello();
    }
  };

  return (
    <section>
      <button onClick={sayHello}>
        通过ref调用子应用方法
      </button>
      <Child ref={childRef} />
    </section>
  );
}
```

在`class component`中，使用`createRef`来创建ref对象：
```javascript
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}
```

## Vue

在Vue 3.x中，使用`ref()`来定义ref变量，通过`ref="ref"`来引用。
```html
<template>
  <div ref="ref" />
</template>

<script setup>
  import { ref } from 'vue';
  const ref = ref(null);
</script>
```
### 元素标签

同样参照React的例子，我们使用ref绑定到html标签上以获取DOM，然后通过DOM上的className属性能够得到绑定的节点的class类名：
```html
<template>
  <section>
    <div ref="fatherRef" class="w-10 h-10 border"></div>
    <div>className is: {{className}}</div>
  </section>
</template>

<script setup>
import { ref, watchEffect } from 'vue';

const fatherRef = ref(null);

let className = ref('');

watchEffect(() => {
  if (fatherRef.value) {
    className.value = fatherRef.value.className;
  }
});
</script>
```

### 组件

在子组件中，使用`defineExpose`来将子组件内部的方法暴露出去。
```html
<template>
  <div>子应用</div>
</template>

<script setup>
const sayHello = () => {
  console.log('hello')
}
defineExpose({
  sayHello
});
</script>
```

在父组件中，通过ref.value来引用子组件的方法：
```html
<template>
  <section>
    <button @click="sayHello">
      通过ref调用子应用方法
    </button>
    <Child ref="childRef" />
  </section>
</template>

<script setup>
import { ref, watchEffect } from 'vue';
import Child from './Child.vue';

const childRef = ref(null);

const sayHello = () => {
  if (childRef.value) {
    childRef.value.sayHello();
  }
}
</script>
```


如果是在Vue 2.x中，在使用了`ref="ref"`声明后，直接通过`this.$refs.ref`的形式来使用即可。
```html
<template>
  <div ref="divRef"></div>
</template>

<script>
export default {
  mounted() {
    console.log(this.$refs.divRef);
  }
}
</script>
```

## Svelte

在Svelte中，使用`bind:this`指令来实现ref功能，Svelte的ref对象不用像React要再多一层current和Vue多一层value来获取值。
### 元素标签

如果`bind:this`绑定到正常html标签上，可以直接获取到DOM节点，然后便能直接使用DOM节点上的属性。

```html
<script>
  let fatherRef;
  let className;

  $: {
    if (fatherRef) {
      className = fatherRef.className;
    }
  }
</script>

<section>
  <div bind:this={fatherRef} class="w-10 h-10 border"></div>
  <div>className is: {className}</div>
</section>
```

### 组件

在子组件中，使用`export`的方式导出组件内部的方法。
```html
<script>
  export const sayHello = () => {
    console.log('hello')
  }
</script>

<div>子应用</div>
```

在父组件中：
```html
<script>
  import Child from "./Child.svelte";

  let childRef;

  const sayHello = () => {
    if (childRef) {
      childRef.sayHello();
    }
  };
</script>

<section>
  <button on:click={sayHello}>
    通过ref调用子应用方法
  </button>
  <Child bind:this={childRef} />
</section>
```
如果想要父组件操作子组件的数据，需要对外`export`一个能够获取该数据的方法，而不是直接`export`数据。因为直接export数据在Svelte中是把该数据声明为一个对外的prop，亦或者像我们在《特定标签》中学习到的配置`<svelte:options>`的`accessors`属性为true。

## 小结

本章我们对比了：
- 框架的ref功能如果绑定到正常的html标签，可以获取DOM节点的引用，如果绑定到组件上，可以获取组件的实例
- React的`function component`中通过`useRef`来定义ref，通过`useImperativeHandle`来定义组件对外暴露的方法。在`class component`中使用`createRef`来定义ref。ref的具体值在ref.current上。
- 在Vue`3.x`中通过`ref()`来定义ref，通过`defineExpose()`来定义组件对外暴露的方法。在`2.x`中通过`this.$refs`来调用。
- Svelte通过`bind:this`来实现ref。组件内通过`export`来定义对外暴露的方法。
---
title: Svelte从入门到精通——库
description: 【源码篇】库
---

在正式解读源码之前，笔者会和读者朋友们一起了解一些npm库的功能作用，每一个都和我们接下来的源码解读息息相关。在阅读完本章后，相信读者们在接下来的源码讲解中，不至于遇到一个功能库而一头雾水。本章中，我们将了解以下功能库：
- [acorn](https://github.com/acornjs/acorn/tree/master/acorn)
- [periscopic](https://github.com/Rich-Harris/periscopic#readme)
- [estree-walker](https://github.com/Rich-Harris/estree-walker#readme)
- [escodegen](https://github.com/estools/escodegen)

## AST

在认识这些工具库之前，我们需要先了解一个概念：抽象语法树（Abstract Syntax Tree，AST）。这个概念非常重要，它是实现一个编译器的核心，后面介绍的各种库都是围绕这个核心概念服务的。

抽象语法树是以树形结构数据来表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。其拥有一套[约定的规范](https://github.com/estree/estree?tab=readme-ov-file)。

AST运用非常广泛：代码格式化、代码高亮、代码错误校验、代码转换等等，可以说，谁掌握了AST的使用，谁就掌握了前端代码编译的天下。

AST的生成通常涉及到两个步骤：词法分析、语法分析。

#### 词法分析

词法分析（Lexical analyzer）是由词法分析器来扫描源代码，将扫描出来的字符与Javascript关键字进行比较，生成一个个不可再分割的最小单元，这些单元被称为Token。

比如我们有一段代码：
```javascript
let str = 'svelte';
```
那么经过词法分析后，得到的是类似如下的一个数组：
```javascript
[
  { type: 'Keyword', value: 'let' },
  { type: 'Identifier', value: 'str' },
  { type: 'Punctuator', value: '=' },
  { type: 'String', value: '"svelte"' }
]
```

#### 语法分析

语法分析（Syntax analyzer）就是将词法分析阶段生成的Token转换为抽象语法树。

在[astexplorer](https://astexplorer.net/)中，我们能够试验各种ast工具对源码的抽象。

## acorn
如果读者此前没有听说过`acorn`，那有一个鼎鼎大名的库相信读者一定了解，那就是`webpack`。`webpack`底层将代码转换成抽象语法树时使用的便是`acorn`。使用`acorn`转换得到的返回值，是符合The ESTree Spec规范的对象。

除了`webpack`之外，`Rollup`和`Babel`的`@babel/parser`等工具都使用到了`acorn`。
市面上除了`acorn`外，还流行其他js解析器，如：[Esprima](https://esprima.org/)、[UglifyJS](https://lisperator.net/uglifyjs/)、[Shift](https://shift-ast.org/)等。

### parse
```javascript
acorn.parse(str, options)
```
str就是要解析的字符串内容，options是一个对象，其中只有ecmaVersion是必填的，用于指定指定要解析的 ECMAScript 版本。
```typescript
export interface Options {
  ecmaVersion: ecmaVersion
  sourceType?: "script" | "module"
  onInsertedSemicolon?: (lastTokEnd: number, lastTokEndLoc?: Position) => void
  onTrailingComma?: (lastTokEnd: number, lastTokEndLoc?: Position) => void
  allowReserved?: boolean | "never"
  allowReturnOutsideFunction?: boolean
  allowImportExportEverywhere?: boolean
  allowAwaitOutsideFunction?: boolean
  allowSuperOutsideMethod?: boolean
  allowHashBang?: boolean
  checkPrivateFields?: boolean
  locations?: boolean
  onToken?: ((token: Token) => void) | Token[]
  onComment?: ((
    isBlock: boolean, text: string, start: number, end: number, startLoc?: Position,
    endLoc?: Position
  ) => void) | Comment[]
  ranges?: boolean
  program?: Node
  sourceFile?: string
  directSourceFile?: string
  preserveParens?: boolean
}
```
目前我们只需大概了解参数即可，感兴趣的读者可阅读[acorn](https://github.com/acornjs/acorn/tree/master/acorn/)了解其他参数的功能。

```javascript
import * as acorn from "acorn";

let str = `let a = 0;
let b = 1;
let c = a + b;

a++;
window.e = 2;
f = 3;
`

const ast = acorn.parse(str, {
  ecmaVersion: 2023
});

console.log(ast);
```

![](/images/svelte/33-1.png)


我们在[AST Explorer](https://astexplorer.net/)中，得到的是同样的结果：
![](/images/svelte/33-2.png)

使用acorn解析之后得到的数据便是ast抽象语法树，树形结构的数据必然存在一个或多个叶子节点，在每个节点上，都有一个参数type来标记这个节点属于什么类型。我们了解一下在一个AST对象中的各种type的意义。

### type
#### Literal
Literal是字面量的意思，比如 `let str = 'svelte'`中`'svelte'`就是一个字符串字面量
![](/images/svelte/33-24.png)  

![](/images/svelte/33-23.png)

#### Identifier
Identifier指标识符，变量名、属性名、参数名等各种声明和引用的名字，都是Identifer。
```javascript
const str = 'world';

function greet(val) {
  console.log(val);
}

const foo = {
  bar: 'svelte'
}
```
就拿这一小段代码来说，它的Identifier类型节点就将近十个：
![](/images/svelte/33-3.png)

#### Statement
语句，一些常见的执行代码用此类型，比如：

`{}`是`BlockStatement`
![](/images/svelte/33-4.png)
`do {} while()`是`DoWhileStatement`
![](/images/svelte/33-5.png)
`debugger`是`DebuggerStatement`
![](/images/svelte/33-6.png)

`$:xxx`是`LabeledStatement`。Svelte中的反应性的监听，巧妙地运用了这个语句。
![](/images/svelte/33-7.png)
不再逐一展示。以下是常见语句：
```javascript
{} // BlockStatement

do {} while() // DoWhileStatement
while() {} // WhileStatement
for(let i = 0; i < n; i++){} // ForStatement
for(let i in obj){} // ForInStatement
for(let i of arr){} // ForOfStatement

debugger; // DebuggerStatement
throw Error(); // ThrowStatement
label: xxx // LabeledStatement
break; // BreakStatement
continue; // ContinueStatement
return; // ReturnStatement

if(true) {} // IfStatement
switch(true) {} // SwitchStatement

try {} catch(e) {} // TryStatement
...等等
```

#### Declaration
相比于Statement语句用来控制执行逻辑，Declaration声明语句将非空标识符绑定到常量、Class、变量、函数或导入导出当中。
![](/images/svelte/33-8.png)

![](/images/svelte/33-9.png)
![](/images/svelte/33-10.png)

```javascript
let a = ''; // VariableDeclaration
function a() {} // FunctionDeclaration
class A {} // ClassDeclaration
import a from 'a'; // ImportDeclaration
export default a = 1; // ExportDefaultDeclaration
...等等
```

#### Expression
Expression表达式，通过调用运算符或者函数来得到一个计算后的返回值。

```javascript
[1,2,3] // ArrayExpression                数组表达式
({a: ''}) // ObjectExpression             对象表达式
this; // ThisExpression                   this表达式

1 + 2 // BinaryExpression                 二元表达式
true ? '' : '' // ConditionalExpression   条件表达式
a++; // UpdateExpression                  更新表达式
-1 // UnaryExpression                     一元表达式

a = 1; // AssignmentExpression            赋值表达式
new a(); // NewExpression                 New表达式
a = function() {} // FunctionExpression   函数表达式
() => {} // ArrowFunctionExpression       箭头函数表达式
...等等
```

#### Program
正常情况下，最顶级的节点的type即是Program


还有Class、Modules、Directive、File、Comment等type不一一演示了。

### code-red
[code-red](https://github.com/Rich-Harris/code-red)是一个基于acorn二次封装的工具库。
我们看一下基本使用：
```javascript
import { x, b, print } from 'code-red';

const expression = x`i + j`;

const body = b`i + j`;
console.log('expression', expression);
console.log('body', body);

const hello = x`i`;
const world = x`j`;
const expression2 = x`${hello}+${world}`;

console.log('hello', hello);
console.log('world', world);
hello.name = 'abc';
world.name = 'efg';

console.log('code', print(expression2).code);
```
![alt text](/images/svelte/33-26.png)  

`x`方法内部是基于`acorn.parseExpressionAt()`的封装：
```javascript
export function x(strings, ...values) {
	const str = join(strings);

	/** @type {CommentWithLocation[]} */
	const comments = [];

	try {
		let expression =
			/** @type {Expression & { start: Number, end: number }} */ (
				acorn.parseExpressionAt(str, 0, acorn_opts(comments, str))
			);
		const match = /\S+/.exec(str.slice(expression.end));
		if (match) {
			throw new Error(`Unexpected token '${match[0]}'`);
		}

		expression = /** @type {Expression & { start: Number, end: number }} */ (
			inject(str, expression, values, comments)
		);

		return expression;
	} catch (err) {
		handle_error(str, err);
	}
}
```

`b`方法是基于`acorn.parse()`的封装：
```javascript
export function b(strings, ...values) {
	const str = join(strings);

	/** @type {CommentWithLocation[]} */
	const comments = [];

	try {
		let ast = /** @type {any} */ (acorn.parse(str, acorn_opts(comments, str)));

		ast = inject(str, ast, values, comments);

		return ast.body;
	} catch (err) {
		handle_error(str, err);
	}
}
```

## periscopic

从ast对象中分析出变量作用域。

```javascript
import { analyze } from 'periscopic';

const ast = acorn.parse(str, options);

const { map, globals, scope } = analyze(ast);
```

### analyze

`periscopic`导出一个方法`analyze`，调用此方法得到一个对象，该对象有以下属性：
- `map`：是一个WeakMap类型的对象（`WeakMap<Node, Scope>`）, 对象的keys是创建出scope的ast节点。
- `globals`：是一个Map类型的对象（`Map<string, Node>`），收集所有被引用的但没有被声明的Identifier，Identifier我们在acorn中已详细讲解。
- `scope`：程序中的顶级作用域，`Scope`类型

```javascript
import * as acorn from 'acorn';
import { analyze } from 'periscopic';

let a = `let a = 0;
window.b = 1;
function c() {
  let d = 2;
}
e = 3;
`;

const ast = acorn.parse(a, {
  ecmaVersion: 2023,
});

const { map, globals, scope } = analyze(ast);
console.log('map', map);
console.log('globals', globals);
console.log('scope', scope);
```

![](/images/svelte/33-11.png)
我们首先看下map的打印数据：
periscopic分析出两个创建了scope的节点。
![](/images/svelte/33-12.png)
![](/images/svelte/33-13.png)

globals中我们可以得知，`e`和`window`这两个变量我们没有进行声明而直接用了。
![](/images/svelte/33-14.png)

scope，top-level级别的作用域
![](/images/svelte/33-15.png)

#### Scope
 `Scope`类型的对象有以下参数:
- `scope.block`：如果scope是BlockStatement创建的，则是true，否则是false
- `scope.parent`：父级的Scope对象
- `scope.declarations`：一个Map类型对象（`Map<string, Node>` ），在当前scope中声明的所有变量，Node节点值是Declaration类型节点
- `scope.initialised_declarations`：一个Set类型对象（`Set<string>`），在当前scope中声明且初始化了的对象
- `scope.references`：一个Set类型对象（`Set<string>` ），在当前scope中的所有变量名

`Scope`类型对象有两个方法：
- `scope.has(name)`：如果`name`在当前作用域或祖先作用域中声明过，则返回`true`
- `scope.find_owner(name)`：返回声明`name`的`Scope`对象

我们以上述例子`const { map, globals, scope } = analyze(ast)`中返回的scope为例：
![](/images/svelte/33-16.png)
block：不是BlockStatement创建的，所以false
parent：没有父级作用域，所以null
declarations: 变量a和c是在当前作用域声明的
initialised_declarations: 变量a在当前作用域声明并且初始化
references: 当前作用域中的变量有a、window、c、d、e

### extract

periscopic还导出了两个方法`extract_identifiers`和`extract_names`用来提取特定值。

```javascript
import * as acorn from 'acorn';
import { extract_identifiers, extract_names } from 'periscopic';

let a = `let a = 0;
window.b = 1;
function c() {
  let d = 2;
}
e = 3;
`;

const ast = acorn.parse(a, {
  ecmaVersion: 2023,
});

const data = ast.body[2].id;
const identifiers = extract_identifiers(data);
const names = extract_names(data);
console.log('identifiers', identifiers);
console.log('names', names);
```

![](/images/svelte/33-17.png)

在控制台中输出：
![](/images/svelte/33-18.png)

## estree-walker

用来遍历ast对象。

```javascript
import { walk } from "estree-walker";

const ast = acorn.parse(str, options);

walk(ast, {
  enter(node, parent, prop, index) {
    // some code happens
  },
  leave(node, parent, prop, index) {
    // some code happens
  }
});
```

### enter / leave
enter方法：进入节点时调用
leave方法：离开遍历的节点时调用

- 在`enter`方法中，调用`this.skip()`可以阻止当前节点的子节点被遍历，或者阻止`leave`方法被调用
- 在`enter`或`leave`方法中调用`this.replace(new_node)`可以替换节点
- 在`enter`或`leave`方法中调用`this.remove`可以删除当前节点

具有相同作用的包还有：estraverse、acorn-walk等。

```javascript
import * as acorn from "acorn";
import { walk } from "estree-walker";

let a = `let a = 0;`;

let ast = acorn.parse(a, { ecmaVersion: 2023 });

walk(ast, {
  enter(node) {
    console.log('enter', node);
  },
  leave(node) {
    console.log('leave', node);
  }
})
```

![](/images/svelte/33-19.png)

![](/images/svelte/33-20.png)
我们对照着解析出来的ast对象来过一遍流程：
- 进入Program节点`enter Program`
- 进入VariableDeclaration节点`enter VariableDeclaration`
- 进入VariableDeclarator节点`enter VariableDeclarator`
- 进入Identifier节点`enter Identifier`，没有子节点了，回退到上一级父节点VariableDeclarator`leave Identifier`
- 进入Literal节点`enter Literal`，没有子节点了，回退到上一级父节点VariableDeclarator`leave Literal`
- VariableDeclarator的子节点已遍历完了，回退到上一级VariableDeclaration`leave VariableDeclarator`
- VariableDeclaration的子节点也遍历完了，继续回退到上一级`leave VariableDeclaration`
- 结束遍历`leave Program`

#### skip
`this.skip()`功能演示：
```javascript
let a = `let a = 0;`;

let ast = acorn.parse(a, { ecmaVersion: 2023 });

walk(ast, {
  enter(node) {
    console.log('enter', node);
    if (node.type == 'VariableDeclarator') {
      this.skip();
    }
  },
  leave(node) {
    console.log('leave', node);
  }
})
```
![](/images/svelte/33-21.png)

### replace
`this.replace()`方法演示：
比如我们想把`let a = 0;`改成`let a = 1;`，0对应的是`Literal`的节点
![](/images/svelte/33-25.png)

```javascript
import * as acorn from "acorn";
import { walk } from "estree-walker";
import { generate } from "escodegen";

let a = `let a = 0;`;

let ast = acorn.parse(a, { ecmaVersion: 2023 });

walk(ast, {
  enter(node) {
    console.log('enter', node);
    if (node.type === 'Literal') {
      this.replace({
        ...node,
        raw: '1',
        value: 1
      })
    }
  },
  leave(node) {
    console.log('leave', node);
  }
})

const str = generate(ast);
console.log('new str', str);
```
我们把原来节点的`raw`和`value`属性都改成1，然后调用`this.replace()`来替换。
![](/images/svelte/33-22.png)


## escodegen

用于把满足 Estree 标准的 AST 转换为 ESMAScript 代码
### generate
```javascript
escodegen.generate(AST[, options]);
```
options的详细参数见[escodegen options](https://github.com/estools/escodegen/wiki/API)

在estree-walk的最后一节演示中，我们已经使用了escodegen来展示它的功能。

## 小结

本章我们学习了：
- AST的基本概念
- acorn的使用，ast节点的不同type，基于acorn封装的code-red的使用
- periscopic的使用
- estree-walker的使用
- escodegen的使用

通过介绍这几个库，相信笔者已经发现，这些其实就是实现一个编译器所需要的几个功能：解析代码文件 -> 分析ast，ast转换 -> 生成新代码。---
title: Svelte从入门到精通——style
description: 【对比篇】style
---

## React

### 行内样式

在React中，行内样式需要以`style={styleObj}`的形式：
```javascript
export default function Page() {
  return <div style={{
    border: '2px solid black',
    backgroundColor: 'purple',
    color: 'white'
  }}>style</div>
}
```

![](/images/svelte/31-1.png)
在样式对象内，之前在行内样式中使用`-`连接的属性需要转成使用驼峰的形式，比如`font-size`要写成`fontSize`、`background-color`要写成`backgroundColor`等。

### 非行内样式
React的样式通常集中写在一个样式文件中，在jsx中只写js代码和长得像html的代码。

```javascript
// Child.jsx
import "./Child.css";

export default function Child() {
  return (
    <div className="color">子组件</div>
  );
}
```

当然，如果是使用cssinjs库，则能够直接在jsx文件或tsx文件中写样式。

### class属性

在React中，写样式class需要写在`className`中，对于`className`的传值，和其他传递属性无异，可以正常的执行js表达式。

### 模块化

我们使用[create-react-app](https://create-react-app.dev/)来创建一个React项目：
```bash
npx create-react-app react-test
```

我们创建一个子组件：
```javascript
// Child.jsx
import "./Child.css";
import styles from "./Child.module.css";

export default function Child() {
  return (
    <div>
      <div className="color">子组件</div>
      <div className={styles.color}>子组件 模块化样式</div>
    </div>
  );
}
```

```css
.color {
  color: red;
}
```

在页面中：
```javascript
import './App.css';
import Child from './Child';

function App() {
  return (
    <div>
      <div className="color">父组件</div>
      <Child />
    </div>
  );
}

export default App;
```

而在App.css中：
```css
.color {
  color: green;
}
```
![](/images/svelte/31-2.png)
我们可以看到，原本我们是想子组件的红色，父组件里的字体是绿色，然而现在都变成了红色。

在React中，要想实现样式模块化，通常有以下方式：
- module css
- BEM
- css-in-js
这里以前两种来举例。

#### module
在使用`create-react-app`创建的项目中，我们把样式文件名写成`xxx.module.css`的形式，然后以变量的形式引入。
将上述例子的Child.css改成Child.module.css，调整Child.jsx的逻辑：
```javascript
import styles from "./Child.module.css";

export default function Child() {
  return <div className={styles.color}>子组件 模块化样式</div>;
}
```

![](/images/svelte/31-3.png)
可以看到，子组件的color样式选择器已经被改动了。

#### BEM
[BEM](https://yandex.com/dev/bem/)风格规范指的是Block、Element、Modifier这三者的简称，这个规范将CSS拆分成块、元素、修饰符，根本作用是帮助开发者快速理解HTML与CSS之间的关系。我们可以根据不同的标签层级，使用约定好格式的类名，以此来到达维护css的目的。

我们并非严格地按照BEM规范来执行，而是以此规范为参考，为每个组件人工地添加一个唯一前缀，然后把组件的样式都限定在这个唯一的选择器内，实现其中的核心思想。

继续以上述Child.jsx为例，假如不使用module css，那我们修改我们的样式文件：
```css
.child-color {
  color: red;
}

.child-background {
  background: red;
}
```

然后修改我们的Child.jsx：
```javascript
import "./Child.css";

export default function Child() {
  return (
    <>
      <div className="child-color">子组件 模块化样式</div>
      <div className="child-background">子组件</div>
    </>
  );
}
```

从页面上看，同样可以达到样式模块化。
![](/images/svelte/31-4.png)

可能有些读者会质疑这种实现方式，不仅要每个class都要添加前缀，样式文件的选择器也复杂化了。那是因为现在我们还是用css来演示，如果我们结合样式预处理器，那操作则简化了很多。

为了演示方便，我们使用vite重新创建一个项目：
```bash
npm create vite@latest react-test-vite -- --template react
```

同时使用Less：
```bash
npm install -D less
```

修改Child.jsx内容：
```javascript
import './Child.less';

export default function Child () {
  return (<div className="child">
    <div className="color">子组件 样式模块化</div>
  </div>)
}
```

Child.less内容：
```css
.child {
  .color {
    color: red;
  }
}
```

![](/images/svelte/31-5.png)
因为我们为组件最外层添加了一层包裹，`.child .color`的优先级大于`.color`的优先级。

BEM规范同样能应用在Vue、Svelte等框架中，它的一个劣势是我们需要人工地确保各组件有唯一的前缀或唯一的用于包裹的选择器。

## Vue

### 行内样式

Vue的行内样式同样接收一个变量，以`:style="styleObject"`的形式：
```html
<template>
  <div :style="{ border: '1px solid black', fontSize: 16 }">hello world</div>
</template>
```

### 非行内样式

Vue的非行内样式写在`<style></style>`标签内，可以在该标签内写css内容，也可以在标签内引入样式文件。
```html
<template>
  <div></div>
</template>

<style>
  div {
    color: red;
  }
</style>
```

### class属性

Vue为开发者提供了大量便捷地操作class属性的方式。

#### 默认
```html
<div class="rounded"></div>
```

#### 动态class
```html
<script setup>
  import { ref } from 'vue';
  let colorClass = ref('red');
</script>

<template>
  <div>
    <select v-model="colorClass">
      <option value="red">red</option>
      <option value="green">green</option>
      <option value="blue">blue</option>
    </select>
    <div :class="colorClass">text</div>
  </div>
</template>

<style scoped>
.red {
  color: red;
}
.green {
  color: green;
}
.blue {
  color: blue;
}
</style>
```
![](/images/svelte/31-6.gif)

#### 表达式
```html
<div :class="isActive ? 'active' : ''"></div>
```

#### 数组形式
能够通过操作数组动态增删class：
```html
<script setup>
  import { reactive } from 'vue';

  const classArr = reactive(['class1', 'class2']);

  const addClass = () => {
    classArr.push('class3');
  }
</script>
<template>
  <div>
    <button @click="addClass">add class</button>
    <div :class="classArr">text</div>
  </div>
</template>

<style scoped>
.class1 {
  color: white;
}
.class2 {
  background: black;
}
.class3 {
  width: 100px;
  height: 100px;
}
</style>
```

![](/images/svelte/31-7.gif)

#### 对象形式
通过`key:value`的形式，当value为true时，key才生效。

```html
<script setup>
  import { ref } from 'vue';
  let isActive = ref(false);

  const toggle = () => {
    isActive.value = !isActive.value;
  }
</script>

<template>
  <div>
    <button @click="toggle">toggle</button>
    <div :class="{ active:isActive }">text</div>
  </div>
</template>

<style scoped>
.active {
  color: red;
}
</style>
```
![](/images/svelte/31-8.gif)

### 模块化

我们先看以下例子：
```html
<!-- Father.vue -->
<template>
  <div>
    <div class="style">father style</div>
    <Child />
  </div>
</template>

<script>
import Child from './Child.vue';
export default {
  components: {
    Child,
  }
}
</script>

<style>
  .style {
    color: red;
  }
</style>
```

```html
<template>
  <div class="style">style</div>
</template>

<script>
export default {}
</script>

<style>
  .style {
    color: green;
  }
</style>
```
我们原本期望子组件的颜色是绿色，然而得到的却是如下：
![](/images/svelte/31-9.png)

要想实现样式模块化，需要在`<style>`标签中添加`scoped`属性：
```diff
<template>
  <div class="style">style</div>
</template>

<script>
export default {}
</script>

- <style>
+ <style scoped>
  .style {
    color: green;
  }
</style>
```
![](/images/svelte/31-10.png)
可以看到，Vue是通过添加`data-v-xxx`属性的形式来实现模块化。

## Svelte

### 行内样式

在Svelte中，行内样式的书写和在正常html标签内写style样式一样，均是以字符串的形式。
```html
<div style="border: 2px solid black; background-color: purple; color: white;">style</div>
```

### 非行内样式
正常我们的样式都写在`<style></style>`标签中。

```html
<div></div>

<style>
  div {
    color: red;
  }
</style>
```

### class属性

#### 默认
Svelte中，正常写`class`，不用像React中一样使用`className`。
```html
<div class="rounded"></div>
```

#### 动态class
如果需要支持动态class，以`class={variable}`的形式：
```html
<script>
  let colorClass = 'red';
</script>

<select bind:value={colorClass}>
  <option value="red">red</option>
  <option value="blue">blue</option>
  <option value="green">green</option>
</select>
<div class={colorClass}>color</div>

<style>
  .red {
    color: red;
  }
  .blue {
    color: blue;
  }
  .green {
    color: green;
  }
</style>
```
![[31-11.gif]]

#### 表达式
```html
<script>
  let isActive = false;
  const toggle = () => {
    isActive = !isActive
  }
</script>

<button on:click={toggle}>toggle</button>
<div class={isActive ? 'active' : ''}>color</div>

<style>
  .active {
    color: red;
  }
</style>
```

![](/images/svelte/31-12.gif)

我们能够使用`class`指令来简化表达式的形式，对于`class={isActive ? 'active' : ''}`的写法，我们可以简写成：
```html
<div class:active={isActive}></div>
```

### 模块化

Svelte文件的`<style></style>`标签内的样式，默认启用了模块化特性。
```html
<div class="style">style</div>

<style>
  .style {
    color: red;
  }
</style>
```

![](/images/svelte/31-13.png)
翻看编译后的结果，发现我们的样式类型都带上了后缀。

## 小结

本章我们对比了：
- React的行内样式的写法、非行内样式的引入方式。React中写样式的`class`需要写成`className`。
- Vue的行内样式的写法、非行内样式的处理。Vue动态class的几种写法。
- Svelte的行内样式的写法、非行内样式的处理。class表达式的写法。
- 三大框架样式模块化的处理方式。
- 除了以上特性外，框架还可以结合诸如Tailwind等原子类库、Emotion等cssinjs库以及Less、Sass等样式预处理器来实现页面样式。

---
title: Svelte从入门到精通——位运算
description: 【源码篇】位运算
---

我们在解读源码时，会遇到一行这样的代码：
```javascript
component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31))
```

如果没有接触过位运算的读者，可能会对这行代码犯迷糊，因此，笔者准备花一章的时间来和大家一起了解“位运算”。

## 二进制编码
在了解位运算之前，我们需要首先了解下二进制编码方式。我们主要了解原码、反码和补码。

### 原码

**原码**：最高位表示正负、其他位表示数值。

假设我们有8位的二进制数，如果用原码来表示，最高位则用来表示正负，剩余7位用来表示二进制数：
```text
// +13
00001101

// -13 只有第一位不一样
10001101
```

使用原码来表示二进制数的优点是对开发者阅读友好，缺点是对计算机不友好，计算机无法直接用原码进行运算，否则可能会出错。

比如一个非常经典的问题：在数学运算中，`1 + (-1) = 0`这是毫无疑问的，而在二进制中，
```text
 00000001
+10000001
_________
 10000010
```
运算结果变成了-2，显然出错了。

### 反码

**反码**：反码是在原码的基础上，保留符号位，正数不变，负数的数值位全部“取反”。

如果我们把上述的`1+(-1)`问题用反码来解决：
```text
 00000001
+11111110
_________
 11111111
```
可以看到，得到的结果`11111111`是-0。理论上来说0和-0是一样的，但同一个数字有两种表示会让我们在开发时产生不必要的判断，补码则能解决这个问题。

### 补码
**补码**：补码是在反码的逻辑基础上进一步改动，符号位仍然不变，同样正数不改，而负数数值在原来的基础上`+1`。

```text
// 13原码、反码、补码
00001101

// -13原码
10001101

// -13反码
11110010

// -13补码
11110011
```

如果我们使用补码来进行计算：
```text
  00001101 (13)
+ 11110011 (-13)
________________
 100000000
```

多出来的一位会因为溢出被忽略掉，于是 `a + -a = 0` 仍然成立。这样设计之后`-0`就不存在了。
在计算机系统底层，数值一律用补码来表示和运算。

## 位运算

程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对数据在内存中的二进制位进行操作。
在Javascript中，位运算符是用来对二进制位进行操作的符号，可以将二进制位从低位到高位对齐后进行运算。

Javascript中所有的数字都是符合`IEEE-754`标准的`64`位双精度浮点类型，但做位运算时所有的运算数以及运算结果只会保留[32位](https://262.ecma-international.org/5.1/#sec-11.10)的整数。

Javascript中支持的位运算符有：`&`、`|`、`^`、`~`、`>`、`>>>`。

### 按位与 &

当两个位都是1时，结果为为1，否则为0：

```text
  00000000 00000000 00000000 00001101 (13)
& 00000000 00000000 00000000 00000110 (6)
_____________________________________
  00000000 00000000 00000000 00000100 (4)
```

比如我们可以用`&`来判断奇偶性。
```javascript
3 & 1 // 1
2 & 1 // 0
```
结果是1表示是奇数，结果是0则是偶数。
原理就是1的32为二进制是最低位为1，其他为为0的值，用来判断的数字X如果是奇数，最低位一定是1，两个1相与，一定是1，而X的其他位不管是1还是0，遇到0时都变成0。

### 按位或 |

两个位都是0时，结果为为0，否则为1：
```text
  00000000 00000000 00000000 00001101 (13)
| 00000000 00000000 00000000 00000110 (6)
_____________________________________
  00000000 00000000 00000000 00001111 (15)
```

### 按位异或 ^

两个位相同时，结果为0，否则为1。任何数和自身异或结果都为零，和零异或结果都是其本身。

```text
  00000000 00000000 00000000 00001101 (13)
^ 00000000 00000000 00000000 00000110 (6)
_____________________________________
  00000000 00000000 00000000 00001011 (11)
```

### 按位非 ~

按位原来是1变为0，0变为1。

```text
~ 00000000 00000000 00000000 00001101 (13)
_____________________________________
  11111111 11111111 11111111 11110010 补码
  11111111 11111111 11111111 11110001 反码
  10000000 00000000 00000000 00001110 原码 (-14)
```
首先我们将13转成补码，经过补码的按位非之后，我们得到另一组补码，将这组补码转成原码，再将得到的原码转成十进制数。我们能得到`~13 == -14`，我们可以在浏览器控制台上简单验证：  
![](/images/svelte/34-1.png)

### 左移 \<\<

把数值的二进制表示向左移位，移除的位会被遗弃，末尾补0。

```text
00000000 00000000 00000000 00001101 << 2
___________________________________
00000000 00000000 00000000 00110100 
```
这里仍然用13举例，`13 << 2`结果是52。左移一位表示乘以2，`13 << 2`相当于`13 * 2 * 2 == 52`。

### 右移 >>

把数值的二进制表示向右移位，末尾的位会被遗弃，前面缺失的位按符号位来补，符号位是1则补1，符号位是0则补0。

我们以-16为例：
```text
10000000 00000000 00000000 00010000 原码
11111111 11111111 11111111 11101111 反码
11111111 11111111 11111111 11110000 补码 >> 2
___________________________________
11111111 11111111 11111111 11111100 补码
11111111 11111111 11111111 11111011 反码
10000000 00000000 00000000 00000100 原码                            
```

补码用来计算，原码用来展示。`-16 >> 2 == -4`。

### 无符号右移 >>>

无符号右移，顾名思义就是右移的时候，不考虑符号位，前面统统补 `0`。
仍旧以-16为例：
```text
10000000 00000000 00000000 00010000 原码
11111111 11111111 11111111 11101111 反码
11111111 11111111 11111111 11110000 补码 >>> 2
___________________________________
00111111 11111111 11111111 11111100 正数补码、反码、原码相同
```
![](/images/svelte/34-3.png)

在Javascript中，使用`parseInt`和`Number.prototype.toString`能够进行进制之间的转换。

## `component.$$.dirty`

现在，我们终于能够结合位运算的知识来解读这段代码：
```javascript
component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31))
```

- `(i / 31) | 0`：这里是用数组下标`i`除以31，然后向下取整（数字和`| 0`进行运算有取整的效果）；
![](/images/svelte/34-2.png)  
`component.$$.dirty`变量是个数组，里面存放了多个32位整数，整数转成32位后，每个比特位用来表示组件中的变量是否发生变更。这里的32对应了前面所说的JS的位运算的运算数和运算结果只保留32位。即dirty数组里的一个整数能够记录32个变量的更新状态，如果组件中的变量超过了32个，则放到下一个整数中记录
  - 比如i=0,计算结果为0，第一个变量的状态放到第一个整数的最右边第一位。
  - i=1，计算结果为0，第二个变量的状态放到第一个整数的最右边第二位。
  - i=32，计算结果为1，第三十三个变量的状态放到第二个整数的最右边第一位，以此类推……
- `(1 << (i % 31))`：用`i`对`31`取模，然后做左移操作；
  - 比如i=0，计算结果为1\<\<0 => 01。
  - i=1，计算结果为1 \<\< 1 => 10。
  - i=32，计算结果为1\<\<1 => 10。
- `|=`：再和数组里的旧值进行按位或运算，更新数组。
  - 当i=0时这行代码就变成了`component.$$.dirty[0] |= 01`,由于dirty数组在前面已经被fill为0了，所以代码就变成了`component.$$.dirty[0] = 0 | 01` => `component.$$.dirty[0] = 01`。说明从右边数第一个变量被标记为dirty。
  - 同理当i=1时这行代码就变成了`component.$$.dirty[0] |= 10` =>`component.$$.dirty[0] = 0 | 10` => `component.$$.dirty[0] = 10`。说明从右边数第二个变量被标记为dirty。

## 小结

本章我们学习了：
- 二进制编码（原码、反码、补码）的概念
- 位运算的运用
- Svelte中`component.$$.dirty`代码的位运算运用---
title: Svelte从入门到精通——context
description: 【对比篇】context
---

我们在本章对比一下三大框架的跨组件传值能力。

## React

### function component
```javascript
// Father.jsx
import { createContext, useState, useEffect } from 'react';
import Child from './Child';
import './Father.css';

export const ThemeContext = createContext(null);

export default function Page() {
  const [ count, setCount ] = useState(0);
  const [theme, setTheme] = useState("dark");

  useEffect(() => {}, [theme])

  return (
    <ThemeContext.Provider
      value={{
        count,
        theme,
        setTheme,
      }}
    >
      <button onClick={() => setCount(count + 1)}>add</button> {count}
      <Child />
      <div className={`theme-content ${theme}`}>theme content</div>
    </ThemeContext.Provider>
  );
}
```
首先我们定义一个父组件，父组件内count变量用来测试在外层更改后，内层接收到的变量是否有更改，theme和setTheme变量用来测试传递到孙子组件的变量与方法是否生效。
在`function component`中，通过`createContext`创建得到一个对象`ThemeContext`，然后使用Context.Provider来包裹住需要接收到context数据的组件。
```css
/* Father.css */
.theme-content {
  width: 100px;
  height: 100px;
}
.dark {
  background-color: black;
  border: 1px solid black;
  color: white;
}
.light {
  background: white;
  color: black;
  border: 1px solid black;
}
```

在子组件中，只有引用孙子组件的逻辑：
```javascript
// Child.jsx
import GrandSon from './GrandSon';

export default function Child() {
  return <GrandSon />;
};
```

在孙子组件中，通过`useContext`来接收context数据：
```javascript
// GrandSon.jsx
import { useContext } from 'react';
import { ThemeContext } from './Father';

const GrandSon = () => {
  const { count, theme, setTheme } = useContext(ThemeContext);
  return (
    <div>
      <p>最外层count: {count}</p>
      <p>主题：{theme}</p>
      <button onClick={() => setTheme("dark")}>
        Dark
      </button>
      <button onClick={() => setTheme("light")}>
        Light
      </button>
    </div>
  );
};

export default GrandSon;
```

![](/images/svelte/32-1.gif)

可以看到，通过context传递的变量在跨组件内接收后，能够正常使用，而且传递到组件内的父组件的方法，也能够正常被执行。需要注意的一点时，context并非是万能的银弹，使用context时需要注意传递的值会不会影响到页面的刷新，这对于有性能要求的页面来说非常重要。

### class component
在`class component`中，父组件同样使用`createContext`，而孙子组件中，可以使用Context.Consumer来接收context的传值。
```javascript
// GrandSon.jsx
import React from "react";
import { ThemeContext } from "./Father";

class GrandSon extends React.Component {
  render() {
    return (
      <ThemeContext.Consumer>
        {(context) => {
          const { count, theme, setTheme } = context;
          return (
            <div>
              <p>最外层count: {count}</p>
              <p>主题：{theme}</p>
              <button onClick={() => setTheme("dark")}>Dark</button>
              <button onClick={() => setTheme("light")}>Light</button>
            </div>
          );
        }}
      </ThemeContext.Consumer>
    );
  }
}

export default GrandSon;
```

## Vue

### 3.x
在父组件中，使用`provide`的形式来传递值。
```html
<!-- Father.vue -->
<template>
  <div>
    <button @click="add">add</button> {{ count }}
    <Child />
    <div :class="['theme-content', theme]">theme content</div>
  </div>
</template>

<script>
	export const ContextKey = "ThemeContext";
</script>

<script setup>
	import { ref, provide } from "vue";
	import Child from "./Child.vue";
	
	const count = ref(0);
	const theme = ref("dark");
	
	const add = () => {
	  count.value++;
	};
	
	const setTheme = (newTheme) => {
	  theme.value = newTheme;
	};
	
	provide(ContextKey, {
	  count,
	  theme,
	  setTheme,
	});
</script>

<style scoped>
.theme-content {
  width: 100px;
  height: 100px;
}
.dark {
  background-color: black;
  color: white;
  border: 1px solid black;
}
.light {
  background-color: white;
  color: black;
  border: 1px solid black;
}
</style>
```

作为中间层级的子组件Child.vue，我们不再演示，其就只是引用孙子组件而已。

在孙子组件GrandSon.vue内部，通过`inject`的形式来接收对应Context的值：
```html
<!-- GrandSon.vue -->
<template>
  <div>
      <p>最外层count: {{count}}</p>
      <p>主题：{{theme}}</p>
      <button @click="setTheme('dark')">
        Dark
      </button>
      <button @click="setTheme('light')">
        Light
      </button>
    </div>
</template>

<script setup>
  import { inject } from 'vue';
  import { ContextKey } from './Father.vue';

  const { count, theme, setTheme } = inject(ContextKey);
</script>
```

![](/images/svelte/32-2.gif)

### 2.x
```html
<!-- Father.vue -->
<template>
  <div>
    <button @click="add">add</button> {{ count }}
    <Child />
    <div :class="['theme-content', theme]">theme content</div>
  </div>
</template>

<script>
import Child from "./Child.vue";

export default {
  data() {
    return {
      count: 0,
      theme: 'dark'
    }
  },
  methods: {
    add() {
      this.count++
    },
    setTheme(value) {
      this.theme = value;
    }
  },
  components: {
    Child,
  },
  provide() {
    return {
      ThemeContext: {
        count: this.count,
        theme: this.theme,
        setTheme: this.setTheme
      }
    }
  }
}
</script>

<style scoped>
...
</style>
```

```html
<!-- GrandSon.vue -->
<template>
  <div>
      <p>最外层count: {{ThemeContext.count}}</p>
      <p>主题：{{ThemeContext.theme}}</p>
      <button @click="ThemeContext.setTheme('dark')">
        Dark
      </button>
      <button @click="ThemeContext.setTheme('light')">
        Light
      </button>
    </div>
</template>

<script>
export default {
  inject: ['ThemeContext'],
}
</script>
```

![](/images/svelte/32-3.gif)

不管是在3.x还是2.x中，`provide`和`inject`传递的数据都是非响应性的，但是由于引用类型的特殊性，在子孙组件拿到了数据之后，它们的属性还是能够正常地响应变化，这也是为什么我们直接在3.x中传递`ref`定义的数据后能够实现响应性。那在2.x中，当我们传递基本数据类型的值，也想组件内接收到的值能够响应式地变化，该如何实现呢？

要想拿到基本数据类型的最新值，我们可以将传值改为一个方法，在这个方法中`return`我们的基本数据类型数值。

首先是改造App里`provide`的返回：
```javascript
provide() {
	return {
	  ThemeContext: {
		count: () => this.count,
		theme: () => this.theme,
		setTheme: this.setTheme
	  }
	}
}
```

然后在组件内以方法的形式调用：
```html
<template>
  <div>
    <p>最外层count: {{ThemeContext.count()}}</p>
    <p>主题：{{ThemeContext.theme()}}</p>
    <button @click="ThemeContext.setTheme('dark')">
      Dark
    </button>
    <button @click="ThemeContext.setTheme('light')">
      Light
    </button>
  </div>
</template>
```

## Svelte

```html
<script context="module">
  // Father.svelte
  export const ContextKey = "ThemeContext";
</script>

<script>
  import { setContext } from "svelte";
  import Child from "./Child.svelte";

  let count = 0;
  let theme = "dark";

  const add = () => {
    count++;
  };
  const setTheme = (value) => {
    theme = value;
  };

  setContext(ContextKey, {
    count,
    theme,
    setTheme,
  });
</script>

<button on:click={add}>add</button>{count}
<Child />
<div class={`theme-content ${theme}`}>theme content</div>

<style>
  .theme-content {
    width: 100px;
    height: 100px;
  }
  .dark {
    background-color: black;
    color: white;
    border: 1px solid black;
  }
  .light {
    background-color: white;
    color: black;
    border: 1px solid black;
  }
</style>
```

同样，子组件Child.svelte只有引用孙子组件的逻辑，不展示代码。

孙子组件GrandSon.svelte：
```html
<script>
  // GrandSon.svelte
  import { getContext } from "svelte";
  import { ContextKey } from "./Father.svelte";
  const { count, theme, setTheme } = getContext(ContextKey);
</script>

<div>
	<p>最外层count: {count}</p>
	<p>主题：{theme}</p>
	<button on:click={() => setTheme("dark")}>
	  Dark
	</button>
	<button on:click={() => setTheme("light")}>			
	  Light
	</button>
</div>
```
![](/images/svelte/32-4.gif)  
Svelte的Context传值同样不支持响应性，要想使传递的值具有响应性，我们需要结合`svelte/store`进行使用。

首先是对Father.svelte进行改造：
```html
<script context="module">
  export const ContextKey = "ThemeContext";
</script>

<script>
  import { setContext } from "svelte";
  import { writable } from "svelte/store";
  import Child from "./Child.svelte";

  let countStore = writable(0);
  let themeStore = writable("dark");

  const add = () => {
    $countStore++;
  };
  const setTheme = (value) => {
    $themeStore = value;
  };

  setContext(ContextKey, {
    countStore,
    themeStore,
    setTheme,
  });
</script>

<button on:click={add}>add</button>{$countStore}
<Child />
<div class={`theme-content ${$themeStore}`}>theme content</div>
```

然后是改造GrandSon.svelte：
```html
<script>
  // GrandSon.svelte
  import { getContext } from "svelte";
  import { ContextKey } from "./Father.svelte";
  const { countStore, themeStore, setTheme } = getContext(ContextKey);
</script>

<div>
  <p>最外层count: {$countStore}</p>
  <p>主题：{$themeStore}</p>
  <button on:click={() => setTheme("dark")}> Dark </button><button
    on:click={() => setTheme("light")}
  >
    Light
  </button>
</div>
```
## 小结

本章我们对比了：
- React的`function component`中通过`createContext`和`useContext`来实现跨组件传值。在`class component`中同样通过`createContext`来创建context对象，在内层组件中通过`Context.Consumer`来接收context的传值
- Vue中通过`provide`和`inject`来实现跨组件传值。
- Svelte中通过`setContext`和`getContext`来实现跨组件传值。

对比篇到这里就告一段落，相信大家经过前面一些篇章的学习，已经有所发现：一个最基本的前端框架，应该向使用者提供以下但不限于这些基本功能：
- 定义数据和更新数据的方法
- 事件监听
- 父子传值的能力
- 生命周期钩子
- 插槽
- 数据响应性
- 条件判断和循环判断
- DOM引用
- 样式处理
- 跨组件传值

笔者在[rvs](https://github.com/GrayFrost/rvs)项目中，完整地对以上各类对比进行了代码实现，感兴趣的读者可自行探究。
---
title: Svelte从入门到精通——compiler
description: 【源码篇】compiler
---

经过了前两章的铺垫，我们正式开始对源码进行解读。到笔者目前写文章时，Svelte的最新版本是4.2.12。  
![](/images/svelte/35-16.png)

我们要想在`webpack`或`vite`中使用`Svelte`，必须安装`svelte-loader`或`vite-plugin-svelte`，它们的重要性不言而喻。

看下[svelte-loader](https://github.com/sveltejs/svelte-loader/blob/master/index.js)的核心逻辑: 
```javascript
const svelte = require('svelte/compiler');

svelte.preprocess(source, options.preprocess).then(processed => {
  const compiled = svelte.compile(processed.toString(), compileOptions);
}
```

再看下[vite-plugin-svelte](https://github.com/sveltejs/vite-plugin-svelte/blob/main/packages/vite-plugin-svelte/src/utils/compile.js)的核心逻辑: 
```javascript
import * as svelte from 'svelte/compiler';

let preprocessed;
preprocessed = await svelte.preprocess(code, preprocessors, { filename });
const finalCode = preprocessed ? preprocessed.code : code;

let compiled;
compiled = svelte.compile(finalCode, finalCompileOptions);
```

从源码可以看到，`Svelte`官方的`webpack`插件[svelte-loader](https://github.com/sveltejs/svelte-loader)和`Rollup`插件[rollup-plugin-svelte](https://github.com/sveltejs/rollup-plugin-svelte)的主入口都是`svelte.compile`，这也是我们的切入点。

把项目下载下来，切换到**4.2.12**分支。
```bash
git clone git@github.com:sveltejs/svelte.git
```
![](/images/svelte/35-17.png)

## preprocess

首先是预处理。源码路径：`packages/svelte/src/compiler/preprocess/index.js`
```javascript
export default async function preprocess(source, preprocessor, options) {
  const filename = (options && options.filename) || /** @type {any} */ (preprocessor).filename; // legacy
  const preprocessors = preprocessor
    ? Array.isArray(preprocessor)
      ? preprocessor
      : [preprocessor]
    : [];
  const result = new PreprocessResult(source, filename);
  for (const preprocessor of preprocessors) {
    if (preprocessor.markup) {
      result.update_source(await process_markup(preprocessor.markup, result));
    }
    if (preprocessor.script) {
      result.update_source(await process_tag('script', preprocessor.script, result));
    }
    if (preprocessor.style) {
      result.update_source(await process_tag('style', preprocessor.style, result));
    }
  }

  return result.to_processed();
}
```
简单理解：
- 首先是从外部接收要编译的文件`source`和预处理器对象`preprocessor`。
- 判断`preprocessor`是不是数组，因为可能传了多个`preprocessor`，遍历执行预处理器的功能
- 分别处理`markup`、`script`、`style`，即对应着html标记、js脚本和css样式的编译处理。

总的来说，这个文件提供了预处理Svelte组件源代码的功能，它允许你在编译前对源代码进行任意的转换。

## compile

进入到`packages/svelte/src/compiler/compile/index.js`：
```javascript
export default function compile(source, options = {}) {
  const ast = parse(source, options);
  const component = new Component(
    ast,
    source,
    options.name || get_name_from_filename(options.filename) || 'Component',
    options,
  );
  const result = render_dom(component, options);
  return component.generate(result);
}
```
我们去掉不相关的代码，可以看到基本的compile逻辑：

- 首先会将`parse`过程中拿到的语法树ast转换为`component`
- 然后在`render_dom`中调整成特定的代码片段
- 最后`component.generate`中，通过[code-red](https://github.com/Rich-Harris/code-red)的`print`将调整后的代码片段拼成完整的代码

用以下代码来进行编译为例：
```html
<script>
  let count = 0;
  const addCount = () => {
    count++;
  }
<\/script>

<button on:click={addCount}>add</button>
count:{count}
```
我们分别把`ast`、`component`、`result`这几个变量打印出来看下：
![alt text](/images/svelte/35-1.png)

![alt text](/images/svelte/35-2.png)

![alt text](/images/svelte/35-3.png)

### parse

首先我们查看下compile方法：
```javascript
const ast = parse(source, options);
```
`compile`第一步的逻辑便是调用parse来解析文件内容。

跳转到`parse`方法的主入口`packages/svelte/src/compiler/parse/index.js`：
```javascript
export default function parse(template, options = {}) {
  const parser = new Parser(template, options);
  
  const instance_scripts = parser.js.filter((script) => script.context === 'default');
  const module_scripts = parser.js.filter((script) => script.context === 'module');

  return {
    html: parser.html,
    css: parser.css[0],
    instance: instance_scripts[0],
    module: module_scripts[0]
  };
}
```
逻辑都封装在`Parser`类中，经过`Parser`处理后，返回带有`html`、`css`、`instance`、`module`属性值的对象。`html`和`css`容易理解，而`instance`存储的是正常的`script`内容，`module`存储的则是`<script context="module"></script>`内的js内容。

我们在REPL中可以看到，AST的输出结构正是上述的返回对象。
![](/images/svelte/35-18.png)

#### Parser

```javascript
export class Parser {
  index = 0;
  stack = [];
  html = undefined;
  css = [];
  js = [];

  constructor(template, options) {
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
  }
  current() {}
  eat(str, required, error) {}
  match(str) {}
  match_regex(pattern) {}
  allow_whitespace() {}
  read(pattern) {}
  read_identifier(allow_reserved = false) {}
  read_until(pattern, error_message) {}
  require_whitespace() {}
}
```

在`Parse`类中，定义了一些如何解析模板字符串的方法，比如`match`用来判断是否匹配对应字符串、`eat`用来“吃掉”当前字符串，用于确保读取字符串模板的索引index的正确指向等等。

我们着重关注的是在`constructor`里的一段代码：
```javascript
let state = fragment;
while (this.index < this.template.length) {
  state = state(this) || fragment;
}
```

#### fragment
进入到`fragment`的文件中`packages/svelte/src/compiler/parse/state/fragment.js`：
```javascript
import tag from './tag.js';
import mustache from './mustache.js';
import text from './text.js';

/**
 * @param {import('../index.js').Parser} parser
 */
export default function fragment(parser) {
  if (parser.match('<')) {
    return tag;
  }

  if (parser.match('{')) {
    return mustache;
  }

  return text;
}
```
可以看到，`fragment`内部是使用了三种不同的解析处理，分别是`tag`、`mustache`和`text`。

#### tag

当解析的内容是以`<`开头时，进入到`tag`的解析流程。`tag`除了解析原生html、css、script标签外，还支持了Svelte自定义的标签如`svelte:html`、`svelte:body`、`svelte:component`等等。

```javascript
if (parser.eat('!--')) {
  const data = parser.read_until(regex_closing_comment);
  parser.eat('-->', true, parser_errors.unclosed_comment);
  parser.current().children.push({
    start,
    end: parser.index,
    type: 'Comment',
    data,
    ignores: extract_svelte_ignore(data)
  });
  return;
}
```
当在`<`之后遇到的是`!--`，表明解析到了注释语句，返回`Comment`类型的节点。

```javascript
const meta_tags = new Map([
  ['svelte:head', 'Head'],
  ['svelte:options', 'Options'],
  ['svelte:window', 'Window'],
  ['svelte:document', 'Document'],
  ['svelte:body', 'Body']
]);
const valid_meta_tags = Array.from(meta_tags.keys()).concat(
  'svelte:self',
  'svelte:component',
  'svelte:fragment',
  'svelte:element'
);

const type = meta_tags.has(name)
  ? meta_tags.get(name)
  : regex_capital_letter.test(name[0]) || name === 'svelte:self' || name === 'svelte:component'
  ? 'InlineComponent'
  : name === 'svelte:fragment'
  ? 'SlotTemplate'
  : name === 'title' && parent_is_head(parser.stack)
  ? 'Title'
  : name === 'slot'
  ? 'Slot'
  : 'Element';
```
遇到Svelte的自定义标签时，返回特定类型的节点，剩余的原生html标签，则标记为`Element`类型节点。


```javascript
const specials = new Map([
  [
    'script',
    {
      read: read_script,
      property: 'js'
    }
  ],
  [
    'style',
    {
      read: read_style,
      property: 'css'
    }
  ]
]);

if (is_top_level_script_or_style) {
  const special = specials.get(name);
  parser.eat('>', true);
  const content = special.read(parser, start, element.attributes);
  if (content) parser[special.property].push(content);
  return;
}
```
当遇到`script`标签时，用`read_script`进行解析；当遇到`style`标签时，用`read_style`进行解析。

`read_script`的逻辑如下，核心是调用`code-red`的`parse`方法对script的内容进行解析：
```javascript
export default function read_script(parser, start, attributes) {
  ...
  let ast;
  try {
    ast = acorn.parse(source);
  } catch (err) {
    parser.acorn_error(err);
  }
  
  return {
    type: 'Script',
    start,
    end: parser.index,
    context: get_context(parser, attributes, start),
    content: ast
  };
}
```

acorn.parse的逻辑：
```javascript
export const parse = (source) =>
  code_red.parse(source, {
    sourceType: 'module',
    ecmaVersion: 13,
    locations: true
  });
```

`read_style`的逻辑如下，核心是使用了`css-tree`的`fork`功能：
```javascript
import { parse } from './css-tree-cq/css_tree_parse.js'; // Use extended css-tree for 
import { walk } from 'estree-walker';

export default function read_style(parser, start, attributes) {
  ...

  let ast;

  try {
    ast = parse(styles, {
      positions: true,
      offset: content_start,
      onParseError(error) {
        throw error;
      }
    });
  } catch (err) {
    ...
  }

  ast = JSON.parse(JSON.stringify(ast));

  walk(ast, {
    enter: (node) => {
      ...

    }
  });

  parser.read(regex_starts_with_closing_style_tag);

  const end = parser.index;

  return {
    type: 'Style',
    start,
    end,
    attributes,
    children: ast.children,
    content: {
      start: content_start,
      end: content_end,
      styles
    }
  };
}
```

css`parse`的逻辑：
```javascript
import { fork } from 'css-tree';
import * as node from './node/index.js';

const cq_syntax = fork({
  atrule: {
    container: {
      parse: {
        prelude() {
          return this.createSingleNodeList(this.ContainerQuery());
        },
        block(is_style_block = false) {
          return this.Block(is_style_block);
        }
      }
    }
  },
  node
});

export const parse = cq_syntax.parse;
```

#### mustache

当解析的内容是以`{`开头时，进入到`mustache`的解析流程。除了识别正常的`{xxx}`语法外，还识别Svelte的逻辑渲染语法如`{#if}`、`{#each}`、`{@html}`等等。

```javascript
export default function mustache(parser) {
  ...
  // {/if}, {/each}, {/await} or {/key}
  if (parser.eat('/')) {
    
    ...
  } else if (parser.eat(':else')) {
    ...
    // :else if
    if (parser.eat('if')) {
      ...
      block.else = {
        start: parser.index,
        end: null,
        type: 'ElseBlock',
        children: [
          {
            start: parser.index,
            end: null,
            type: 'IfBlock',
            elseif: true,
            expression,
            children: []
          }
        ]
      };
      parser.stack.push(block.else.children[0]);
    } else {
      // :else
      ...
      block.else = {
        start: parser.index,
        end: null,
        type: 'ElseBlock',
        children: []
      };
      parser.stack.push(block.else);
    }
  } else if (parser.match(':then') || parser.match(':catch')) {
    const block = parser.current();
    const is_then = parser.eat(':then') || !parser.eat(':catch');
    ...
    
    const new_block = {
      start,
      end: null,
      type: is_then ? 'ThenBlock' : 'CatchBlock',
      children: [],
      skip: false
    };
    await_block[is_then ? 'then' : 'catch'] = new_block;
    parser.stack.push(new_block);
  } else if (parser.eat('#')) {
    // {#if foo}, {#each foo} or {#await foo}
    let type;
    if (parser.eat('if')) {
      type = 'IfBlock';
    } else if (parser.eat('each')) {
      type = 'EachBlock';
    } else if (parser.eat('await')) {
      type = 'AwaitBlock';
    } else if (parser.eat('key')) {
      type = 'KeyBlock';
    } else {
      parser.error(parser_errors.expected_block_type);
    }
    parser.require_whitespace();
    const expression = read_expression(parser);
    const block =
      type === 'AwaitBlock'
        ? {
            start,
            end: null,
            type,
            expression,
            value: null,
            error: null,
            pending: {
              start: null,
              end: null,
              type: 'PendingBlock',
              children: [],
              skip: true
            },
            then: {
              start: null,
              end: null,
              type: 'ThenBlock',
              children: [],
              skip: true
            },
            catch: {
              start: null,
              end: null,
              type: 'CatchBlock',
              children: [],
              skip: true
            }
          }
        : {
            start,
            end: null,
            type,
            expression,
            children: []
          };
    parser.allow_whitespace();
    // {#each} blocks must declare a context – {#each list as item}
    if (type === 'EachBlock') {
      ...
    }
    
    ...
  } else if (parser.eat('@html')) {
    // {@html content} tag
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat('}', true);
    parser.current().children.push({
      start,
      end: parser.index,
      type: 'RawMustacheTag',
      expression
    });
  } else if (parser.eat('@debug')) {
    let identifiers;
    // Implies {@debug} which indicates "debug all"
    if (parser.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression = read_expression(parser);
      ...
    }
    parser.current().children.push({
      start,
      end: parser.index,
      type: 'DebugTag',
      identifiers
    });
  } else if (parser.eat('@const')) {
    // {@const a = b}
    parser.require_whitespace();
    const expression = read_expression(parser);
    ...
    parser.current().children.push({
      start,
      end: parser.index,
      type: 'ConstTag',
      expression
    });
  } else {
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat('}', true);
    parser.current().children.push({
      start,
      end: parser.index,
      type: 'MustacheTag',
      expression
    });
  }
}
```
笔者已经把大部分细节代码删除，从上述代码中，我们大体能够知道，`mustache`方法能够解析`{}`、`{@html}`、`{@debug}`、`{@const}`、`{#if}`、`{#each}`、`{#await}`、`{#key}`、`{:else}`、`{:else if}`、`{:then}`、`{:catch}`、`{/if}`、`{/each}`、`{/await}`、`{/key}`等。

#### text
逻辑相对简单很多，主要是用于解析纯文本，返回`Text`类型的数据节点：
```javascript
export default function text(parser) {
  ...

  const node = {
    start,
    end: parser.index,
    type: 'Text',
    raw: data,
    data: decode_character_references(data, false)
  };

  parser.current().children.push(node);
}
```

`const ast = parse(source, options);`的流程解析到此，回到`compile`。

![alt text](/images/svelte/35-4.png)

### Component

经过`parse`的处理，我们拿到了ast对象，然后我们往`Component`中传入字符串内容和ast对象：
```javascript
const component = new Component(
  ast,
  source,
  options.name || get_name_from_filename(options.filename) || 'Component',
  options,
);
```

```javascript
export default class Component {
  constructor(ast, source, name, compile_options, stats, warnings) {
    this.ast = ast;
    this.source = source;

    // styles
    this.stylesheet = new Stylesheet({
      source,
      ast,
      filename: compile_options.filename,
      component_name: name,
      dev: compile_options.dev,
      get_css_hash: compile_options.cssHash
    });

    this.walk_module_js();
    this.walk_instance_js_pre_template();
    this.fragment = new Fragment(this, ast.html);

    this.walk_instance_js_post_template();
  }
  generate(result) {}
  walk_module_js() {}
  walk_instance_js_pre_template() {}
  walk_instance_js_post_template() {}
}
```

#### walk_module_js
```javascript
walk_module_js() {
  const component = this;
  const script = this.ast.module;
  if (!script) return;
  walk(script.content, {
    /** @param {import('estree').Node} node */
    enter(node) {
      ...
    }
  });
  const { scope, globals } = create_scopes(script.content);
  this.module_scope = scope;
  scope.declarations.forEach((node, name) => {
    if (name[0] === '$') {
      return this.error(/** @type {any} */ (node), compiler_errors.illegal_declaration);
    }
    const writable =
      node.type === 'VariableDeclaration' && (node.kind === 'var' || node.kind === 'let');
    const imported = node.type.startsWith('Import');
    this.add_var(node, {
      name,
      module: true,
      hoistable: true,
      writable,
      imported
    });
  });
}
```
这个方法主要对`ast.module`的内容进行解析，即对`<script context="module"></script>`中的内容进行解析，比如判断里面是否声明了`$`相关的响应式语句，对`import`、`export`语句的处理等。

#### walk_instance_js_pre_template

```javascript
walk_instance_js_pre_template() {
  const script = this.ast.instance;
  if (!script) return;
  // inject vars for reactive declarations
  script.content.body.forEach((node) => {
    ...
    extract_names(expression.left).forEach((name) => {
      if (!this.var_lookup.has(name) && name[0] !== '$') {
        this.injected_reactive_declaration_vars.add(name);
      }
    });
  });
  const { scope: instance_scope, map, globals } = create_scopes(script.content);
  this.instance_scope = instance_scope;
  this.instance_scope_map = map;
  instance_scope.declarations.forEach((node, name) => {
    ...
    const { type } = node;
    this.add_var(node, {
      name,
      initialised: instance_scope.initialised_declarations.has(name),
      imported: type.startsWith('Import'),
      writable: type === 'VariableDeclaration' && (node.kind === 'var' || node.kind === 'let')
    });
    this.node_for_declaration.set(name, node);
  });
  // NOTE: add store variable first, then only $store value
  // as `$store` will mark `store` variable as referenced and subscribable
  const global_keys = Array.from(globals.keys());
  const sorted_globals = [
    ...global_keys.filter((key) => key[0] !== '$'),
    ...global_keys.filter((key) => key[0] === '$')
  ];
  ...
  this.track_references_and_mutations();
}
```

`walk_instance_js_pre_template()`方法在处理html模板之前解析`ast.instance`即`<script></script>`标签中的内容，主要处理功能包括处理变量声明、提取响应式声明的变量，解析作用域等。

#### Fragment
源码路径：`packages/svelte/src/compiler/compile/nodes/Fragment.js`
```javascript
export default class Fragment extends Node {
  block;
  children;
  scope;
  constructor(component, info) {
    const scope = new TemplateScope();
    super(component, null, scope, info);
    this.scope = scope;
    this.children = map_children(component, this, scope, info.children);
  }
}
```

`map_children`源码路径：`packages/svelte/src/compiler/compile/nodes/shared/map_children.js`
```javascript
export default function map_children(component, parent, scope, children) {
  let last = null;
  let ignores = [];
  return children.map((child) => {
    const constructor = get_constructor(child.type);
    ...
    const node = new constructor(component, parent, scope, child);
    ...
    return node;
  });
}
```

`get_constructor`经过new得到一个node对象：
```javascript
function get_constructor(type) {
  switch (type) {
    case 'AwaitBlock':
      return AwaitBlock;
    case 'Body':
      return Body;
    case 'Comment':
      return Comment;
    case 'ConstTag':
      return ConstTag;
    case 'Document':
      return Document;
    case 'EachBlock':
      return EachBlock;
    case 'Element':
      return Element;
    case 'Head':
      return Head;
    case 'IfBlock':
      return IfBlock;
    ...
    default:
      throw new Error(`Not implemented: ${type}`);
  }
}
```

我们把`this.fragment`打印出来看下：
![alt text](/images/svelte/35-5.png)  
`children`属性中，就是经过各种各种node类型实例化后的对象。

我们拿数组中一个子元素来看：
![alt text](/images/svelte/35-6.png)

里面的`component`属性其实就是在`this.fragment = new Fragment(this, ast.html);`时传递的`this`。

#### walk_instance_js_post_template
```javascript
walk_instance_js_post_template() {
  const script = this.ast.instance;
  if (!script) return;
  this.post_template_walk();
  this.hoist_instance_declarations();
  this.extract_reactive_declarations();
  this.check_if_tags_content_dynamic();
}
```
`walk_instance_js_pre_template`是在html模板处理前对`ast.instance`实例进行解析，而`walk_instance_js_post_template`是在处理模板之后解析`ast.instance`。因为处理了html模板之后，模板文件中存在和变量相关的内容，比如在`{}`中渲染变量，在事件绑定中绑定变量等。

我们看下`const component = new Component();`得到的数据：
![alt text](/images/svelte/35-7.png)

### render_dom
解析完`new Component()`，我们继续执行下一步：
```javascript
const result =
  options.generate === false
    ? null
    : options.generate === 'ssr'
    ? render_ssr(component, options)
    : render_dom(component, options);
```
关注`render_dom`部分，源码路径：`packages/svelte/src/compiler/compile/render_dom/index.js`：

```javascript
export default function dom(component, options) {
  const { name } = component;
  const renderer = new Renderer(component, options);
  const { block } = renderer;
  block.has_outro_method = true;
  ...

  const blocks = renderer.blocks.slice().reverse();
  push_array(
    body,
    blocks.map((block) => {
      if (/** @type {import('./Block.js').default} */ (block).render)
        return /** @type {import('./Block.js').default} */ (block).render();
      return block;
    })
  );

  ...

  const rest = uses_rest
    ? b`
    const ${omit_props_names.name} = [${props.map((prop) => `"${prop.export_name}"`).join(',')}];
    let $$restProps = ${compute_rest};
  `
    : null;
  ...
  
  // instrument assignments
  if (component.ast.instance) {
    let scope = component.instance_scope;
    const map = component.instance_scope_map;

    /** @type {import('estree').Node | null} */
    let execution_context = null;
    walk(component.ast.instance.content, {
      enter(node) {
        ...
      },
      leave(node) {
        if (map.has(node)) {
          scope = scope.parent;
        }
        if (execution_context === node) {
          execution_context = null;
        }
        if (node.type === 'AssignmentExpression' || node.type === 'UpdateExpression') {
          const assignee = node.type === 'AssignmentExpression' ? node.left : node.argument;
          const names = new Set(extract_names(/** @type {import('estree').Node} */ (assignee)));
          this.replace(invalidate(renderer, scope, node, names, execution_context === null));
        }
      }
    });
    ...
  }

  ...

  const has_create_fragment = component.compile_options.dev || block.has_content();
  if (has_create_fragment) {
    body.push(b`
      function create_fragment(#ctx) {
        ${block.get_contents()}
      }
    `);
  }

  const instance_javascript = component.extract_javascript(component.ast.instance);
  ...
  const definition = has_definition
    ? component.alias('instance')
    : { type: 'Literal', value: null };

    if (has_create_fragment) {
    console.log('svelte block', block)
    body.push(b`
      function create_fragment(#ctx) {
        ${block.get_contents()}
      }
    `);
  }
  ...
  const instance_javascript = component.extract_javascript(component.ast.instance);
  const has_definition =
    component.compile_options.dev ||
    (instance_javascript && instance_javascript.length > 0) ||
    filtered_props.length > 0 ||
    uses_props ||
    component.partly_hoisted.length > 0 ||
    renderer.initial_context.length > 0 ||
    component.reactive_declarations.length > 0 ||
    capture_state ||
    inject_state;
  const definition = has_definition
    ? component.alias('instance')
    : { type: 'Literal', value: null };
  ...
  if (has_definition) {
    ...
    
    body.push(b`
      function ${definition}(${args}) {
        ...
      }
    `);
  }

  ...

  const superclass = {
    type: 'Identifier',
    name: options.dev ? '@SvelteComponentDev' : '@SvelteComponent'
  };
  ...
  const declaration = /** @type {import('estree').ClassDeclaration} */ (
    b`
    class ${name} extends ${superclass} {
      constructor(options) {
        super(${options.dev && 'options'});
        @init(this, options, ${definition}, ${
      has_create_fragment ? 'create_fragment' : 'null'
    }, ${not_equal}, ${prop_indexes}, ${optional_parameters});
        ${
          options.dev &&
          b`@dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "${name.name}", options, id: create_fragment.name });`
        }
      }
    }
  `[0]
  );
  push_array(declaration.body.body, accessors);
  body.push(/** @type {any} */ (declaration));

  ...

  return { js: flatten(body), css };
}
```

`Renderer`实例中包含了一系列用于生成各种DOM操作的代码，这些代码最终会通过`component.generate`包含在一个js文件中。

这里笔者删除了大量细节逻辑，我们关注其中几个部分即可：
```javascript
this.replace(invalidate(renderer, scope, node, names, execution_context === null));
```
我们从REPL上看一下一个代码例子的编译后结果：
![alt text](/images/svelte/35-8.png)
很明显，`this.replace(invalidate)`的作用就是将我们的赋值语句进行`$$invalidate`的替换。

```javascript
if (has_create_fragment) {
  body.push(b`
    function create_fragment(#ctx) {
      ${block.get_contents()}
    }
  `);
}
```
这部分则是处理以下片段，`block.get_contents()`我们在后面讲Block时进行说明：
![alt text](/images/svelte/35-9.png)

```javascript
const definition = has_definition
  ? component.alias('instance')
  : { type: 'Literal', value: null };
...
if (has_definition) {
  ...
  
  body.push(b`
    function ${definition}(${args}) {
      ...
    }
  `);
}
```
这一部分则对应了`instance`片段：
![alt text](/images/svelte/35-10.png)
我们可以在源码中把`definition`这个变量打印出来看下：
![alt text](/images/svelte/35-11.png)

```javascript
const superclass = {
  type: 'Identifier',
  name: options.dev ? '@SvelteComponentDev' : '@SvelteComponent'
};
...
const declaration = /** @type {import('estree').ClassDeclaration} */ (
  b`
  class ${name} extends ${superclass} {
    constructor(options) {
      super(${options.dev && 'options'});
      @init(this, options, ${definition}, ${
    has_create_fragment ? 'create_fragment' : 'null'
  }, ${not_equal}, ${prop_indexes}, ${optional_parameters});
      ${
        options.dev &&
        b`@dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "${name.name}", options, id: create_fragment.name });`
      }
    }
  }
`[0]
);
```
这部分很明显则对应了以下片段：
![alt text](/images/svelte/35-12.png)

#### Renderer

```javascript
import Block from './Block.js';
import FragmentWrapper from './wrappers/Fragment.js';
import { x } from 'code-red';
import flatten_reference from '../utils/flatten_reference.js';
import { reserved_keywords } from '../utils/reserved_keywords.js';
import { renderer_invalidate } from './invalidate.js';

export default class Renderer {

  ...

  constructor(component, options) {
    this.component = component;
    ...
    // main block
    this.block = new Block({
      renderer: this,
      name: null,
      type: 'component',
      key: null,
      bindings: new Map(),
      dependencies: new Set()
    });
    this.block.has_update_method = true;
    this.fragment = new FragmentWrapper(
      this,
      this.block,
      component.fragment.children,
      null,
      true,
      null
    );

    this.blocks.forEach((block) => {
      if (block instanceof Block) {
        block.assign_variable_names();
      }
    });
    this.block.assign_variable_names();
    this.fragment.render(this.block, null, /** @type {import('estree').Identifier} */ (x`#nodes`));
    
    ...
  }

  ...

  invalidate(name, value, main_execution_context = false) {
    return renderer_invalidate(this, name, value, main_execution_context);
  }

  dirty(names, is_reactive_declaration = false) {
    const renderer = this;
    const dirty = /** @type {| import('estree').Identifier
                    | import('estree').MemberExpression} */ (
      is_reactive_declaration ? x`$$self.$$.dirty` : x`#dirty`
    );
    const get_bitmask = () => {
      /** @type {BitMasks} */
      const bitmask = [];
      names.forEach((name) => {
        const member = renderer.context_lookup.get(name);
        if (!member) return;
        if (member.index.value === -1) {
          throw new Error('unset index');
        }
        const value = /** @type {number} */ (member.index.value);
        const i = (value / 31) | 0;
        const n = 1 << value % 31;
        if (!bitmask[i]) bitmask[i] = { n: 0, names: [] };
        bitmask[i].n |= n;
        bitmask[i].names.push(name);
      });
      return bitmask;
    };
    return ({
      type: 'ParenthesizedExpression',
      get expression() {
        const bitmask = get_bitmask();
        if (!bitmask.length) {
          return /** @type {import('estree').BinaryExpression} */ (
            x`${dirty} & /*${names.join(', ')}*/ 0`
          );
        }
        if (renderer.context_overflow) {
          return bitmask
            .map((b, i) => ({ b, i }))
            .filter(({ b }) => b)
            .map(({ b, i }) => x`${dirty}[${i}] & /*${b.names.join(', ')}*/ ${b.n}`)
            .reduce((lhs, rhs) => x`${lhs} | ${rhs}`);
        }
        return /** @type {import('estree').BinaryExpression} */ (
          x`${dirty} & /*${names.join(', ')}*/ ${bitmask[0].n}`
        );
      }
    });
  }

  ...

  remove_block(block) {
    this.blocks.splice(this.blocks.indexOf(block), 1);
  }
}

```

##### Block
```javascript
import { b, x } from 'code-red';
import { is_head } from './wrappers/shared/is_head.js';
import { regex_double_quotes } from '../../utils/patterns.js';
import { flatten } from '../../utils/flatten.js';

export default class Block {
  ...

  /** @param {BlockOptions} options */
  constructor(options) {
    ...
    this.chunks = {
      declarations: [],
      init: [],
      create: [],
      claim: [],
      hydrate: [],
      mount: [],
      measure: [],
      restore_measurements: [],
      fix: [],
      animate: [],
      intro: [],
      update: [],
      outro: [],
      destroy: []
    };
    ...
  }

  assign_variable_names() {}

  ...

  add_element(id, render_statement, claim_statement, parent_node, no_detach) {
    this.add_variable(id);
    this.chunks.create.push(b`${id} = ${render_statement};`);
    if (this.renderer.options.hydratable) {
      this.chunks.claim.push(b`${id} = ${claim_statement || render_statement};`);
    }
    if (parent_node) {
      this.chunks.mount.push(b`@append(${parent_node}, ${id});`);
      if (is_head(parent_node) && !no_detach) this.chunks.destroy.push(b`@detach(${id});`);
    } else {
      this.chunks.mount.push(b`@insert(#target, ${id}, #anchor);`);
      if (!no_detach) this.chunks.destroy.push(b`if (detaching) @detach(${id});`);
    }
  }

  ...

  /** @param {any} [key] */
  get_contents(key) {
    ...
    /** @type {Record<string, any>} */
    const properties = {};
    const noop = x`@noop`;
    properties.key = key;
    if (this.first) {
      properties.first = x`null`;
      this.chunks.hydrate.push(b`this.first = ${this.first};`);
    }
    if (this.chunks.create.length === 0 && this.chunks.hydrate.length === 0) {
      properties.create = noop;
    } else {
      const hydrate =
        this.chunks.hydrate.length > 0 &&
        (this.renderer.options.hydratable ? b`this.h();` : this.chunks.hydrate);
      properties.create = x`function #create() {
        ${this.chunks.create}
        ${hydrate}
      }`;
    }
    ...
    if (this.chunks.mount.length === 0) {
      properties.mount = noop;
    } else if (this.event_listeners.length === 0) {
      properties.mount = x`function #mount(#target, #anchor) {
        ${this.chunks.mount}
      }`;
    } else {
      properties.mount = x`function #mount(#target, #anchor) {
        ${this.chunks.mount}
      }`;
    }
    ...
    if (this.has_animation) {
      ...
    }
    if (this.has_intro_method || this.has_outro_method) {
      ...
    }
    if (this.chunks.destroy.length === 0) {
      properties.destroy = noop;
    } else {
      const dispose_elements = [];
      // Coalesce if blocks with the same condition
      const others = flatten(this.chunks.destroy).filter(
        /** @param {import('estree').Node} node */
        (node) => {
          if (
            node.type === 'IfStatement' &&
            node.test.type === 'Identifier' &&
            node.test.name === 'detaching'
          ) {
            dispose_elements.push(node.consequent);
            return false;
          } else {
            return true;
          }
        }
      );

      properties.destroy = x`function #destroy(detaching) {
        ${dispose_elements.length ? b`if (detaching) { ${dispose_elements} }` : null}
        ${others}
      }`;
    }
    ...

    /** @type {any} */
    const return_value = x`{
      key: ${properties.key},
      first: ${properties.first},
      c: ${properties.create},
      l: ${properties.claim},
      h: ${properties.hydrate},
      m: ${properties.mount},
      p: ${properties.update},
      r: ${properties.measure},
      s: ${properties.restore_measurements},
      f: ${properties.fix},
      a: ${properties.animate},
      i: ${properties.intro},
      o: ${properties.outro},
      d: ${properties.destroy}
    }`;
    const block = dev && this.get_unique_name('block');
    const body = b`
      ${this.chunks.declarations}

      ${Array.from(this.variables.values()).map(({ id, init }) => {
        return init ? b`let ${id} = ${init}` : b`let ${id}`;
      })}

      ${this.chunks.init}

      ${
        dev
          ? b`
          const ${block} = ${return_value};
          @dispatch_dev("SvelteRegisterBlock", {
            block: ${block},
            id: ${this.name || 'create_fragment'}.name,
            type: "${this.type}",
            source: "${this.comment ? this.comment.replace(regex_double_quotes, '\\"') : ''}",
            ctx: #ctx
          });
          return ${block};`
          : b`
          return ${return_value};`
      }
    `;
    return body;
  }

  /** @returns {boolean} */
  has_content() {}

  render() {
    const key = this.key && this.get_unique_name('key');

    /** @type {any[]} */
    const args = [x`#ctx`];
    if (key) args.unshift(key);
    const fn = b`function ${this.name}(${args}) {
      ${this.get_contents(key)}
    }`;
    return this.comment
      ? b`
        // ${this.comment}
        ${fn}`
      : fn;
  }

  render_listeners(chunk = '') {}
  render_binding_groups() {}
}
```
从代码中我们可以知道，`Block`主要是为代码块添加生命周期，比如我们常见的c`create`、m`mount`、p`update`、d`destroy`等。

##### FragmentWrapper
```javascript
...
const wrappers = {
  AwaitBlock,
  Body,
  Comment,
  DebugTag,
  Document,
  EachBlock,
  Element,
  Head,
  IfBlock,
  InlineComponent,
  KeyBlock,
  MustacheTag,
  Options: null,
  RawMustacheTag,
  Slot,
  SlotTemplate,
  Text,
  Title,
  Window
};

...

export default class FragmentWrapper {
  nodes;
  constructor(renderer, block, nodes, parent, strip_whitespace, next_sibling) {
    this.nodes = [];
    ...
    while (i--) {
      const child = nodes[i];
      ...
      if (child.type === 'Window') {
        window_wrapper = new Window(renderer, block, parent, child);
        continue;
      }
      if (child.type === 'Text') {
        ...
      } else {
        const Wrapper = wrappers[child.type];
        if (!Wrapper || (child.type === 'Comment' && !renderer.options.preserveComments)) continue;
        const wrapper = new Wrapper(
          renderer,
          block,
          parent,
          child,
          strip_whitespace,
          last_child || next_sibling
        );
        this.nodes.unshift(wrapper);
        link(last_child, (last_child = wrapper));
      }
    }
    ...
  }

  render(block, parent_node, parent_nodes) {
    for (let i = 0; i < this.nodes.length; i += 1) {
      this.nodes[i].render(block, parent_node, parent_nodes);
    }
  }
}
```
`FragmentWrapper`通过`child.type`来调用对应类型的Wrapper，每个Wrapper内部都实现了自己的render方法。

通过`this.fragment = new FragmentWrapper()`得到的fragment和原来在`new Component()`中生成的fragment并不相同，注意区分，我们可以把两者打印出来比较一下：

在`packages/svelte/src/compiler/compile/Component.js`中：
```diff
  this.fragment = new Fragment(this, ast.html);
+  console.log('svelte new Fragment in Component', this.fragment);
```
和在`packages/svelte/src/compiler/compile/render_dom/Renderer.js`中：
```diff
  this.fragment = new FragmentWrapper(
    this,
    this.block,
    component.fragment.children,
    null,
    true,
    null
  );
+ console.log('svelte new FragmentWrapper in Renderer', this.fragment);
```

![alt text](/images/svelte/35-13.png)

##### render
前面说到每个Wrapper都会实现自己的`render`方法，之后便是调用各自的`render`。
```javascript
this.fragment.render(this.block, null, /** @type {import('estree').Identifier} */ (x`#nodes`));
```

比如`Text`的Wrapper：
```javascript
import Wrapper from './shared/Wrapper.js';
import { x } from 'code-red';

export default class TextWrapper extends Wrapper {
  _data;
  skip;
  var;

  constructor(renderer, block, parent, node, data) {
    super(renderer, block, parent, node);
    this.skip = this.node.should_skip();
    this._data = data;
    this.var = /** @type {unknown} */ /** @type {import('estree').Identifier} */ (
      this.skip ? null : x`t`
    );
  }
  use_space() {
    return this.node.use_space();
  }
  set data(value) {
    this.node.data = this._data = value;
  }
  get data() {
    return this._data;
  }

  render(block, parent_node, parent_nodes) {
    if (this.skip) return;
    const use_space = this.use_space();
    const string_literal = {
      type: 'Literal',
      value: this.data,
      loc: {
        start: this.renderer.locate(this.node.start),
        end: this.renderer.locate(this.node.end)
      }
    };
    block.add_element(
      this.var,
      use_space ? x`@space()` : x`@text(${string_literal})`,
      parent_nodes &&
        (use_space
          ? x`@claim_space(${parent_nodes})`
          : x`@claim_text(${parent_nodes}, ${string_literal})`),
      /** @type {import('estree').Identifier} */ (parent_node)
    );
  }
}
```
Wrapper内部的render是对已经添加了生命周期处理的block对象进行二次处理。

### generate

来到最后一步，首先看下result的大致结构：
![alt text](/images/svelte/35-14.png)

`genetate`隶属于`Component`中的一个方法。

```javascript
generate(result) {
  let js = null;
  let css = null;
  if (result) {

    const program = { type: 'Program', body: result.js };
    walk(program, {
      enter: (node, parent, key) => {
        if (node.type === 'Identifier') {
          if (node.name[0] === '@') {
            ...
          } else if (node.name[0] !== '#' && !is_valid(node.name)) {
            const literal = { type: 'Literal', value: node.name };
            if (parent.type === 'Property' && key === 'key') {
              parent.key = literal;
            } else if (parent.type === 'MemberExpression' && key === 'property') {
              parent.property = literal;
              parent.computed = true;
            }
          }
        }
      }
    });
    ...
    create_module(
      program,
      name,
      banner,
      compile_options.sveltePath,
      imported_helpers,
      referenced_globals,
      this.imports,
      this.vars
        .filter((variable) => variable.module && variable.export_name)
        .map((variable) => ({
          name: variable.name,
          as: variable.export_name
        })),
      this.exports_from
    );
    css = compile_options.customElement ? { code: null, map: null } : result.css;
    const js_sourcemap_enabled = check_enable_sourcemap(compile_options.enableSourcemap, 'js');
    if (!js_sourcemap_enabled) {
      js = print(program);
      js.map = null;
    } else {
      ...
    }
  }
  return {
    js,
    css,
    ast: this.original_ast,
    warnings: this.warnings,
    vars: this.get_vars_report(),
    stats: this.stats.render()
  };
}
```
整体逻辑就是把`program`变量进行`create_module`的模块化输出准备，然后调用`print`把完整的js文件内容输出。

#### create_module
```javascript
export default function create_module(
  program,
  name,
  banner,
  svelte_path = 'svelte',
  helpers,
  globals,
  imports,
  module_exports,
  exports_from
) {
  const internal_path = `${svelte_path}/internal`;
  helpers.sort((a, b) => (a.name < b.name ? -1 : 1));
  globals.sort((a, b) => (a.name < b.name ? -1 : 1));
  return esm(
    program,
    name,
    banner,
    svelte_path,
    internal_path,
    helpers,
    globals,
    imports,
    module_exports,
    exports_from
  );
}
```
`create_module`内部调用了`esm`方法。

```javascript
function esm(
  program,
  name,
  banner,
  svelte_path,
  internal_path,
  helpers,
  globals,
  imports,
  module_exports,
  exports_from
) {
  
  ...

  program.body = b`
    /* ${banner} */

    ${import_declaration}
    ${internal_globals}
    ${imports}
    ${exports_from}

    ${program.body}

    export default ${name};
    ${exports}
  `;
}
```
我们可以把`program.body`打印出来看下：
![alt text](/images/svelte/35-15.png)  

可以看到，到这一步，所有的代码片段已经整理好，之后调用`code-red`的`print`方法对编译好的节点进行整合输出。

## 小结

本章我们学习了：
- `parse`如何把字符串模板内容解析成ast抽象语法树
- `new Component`从ast中解析出html、css、js代码片段
- `render_dom()`将分析好的html、css、js代码片段进行组装，切分成一个个代码块
- `generate`将切分好的代码块进行整合输出---
title: Svelte从入门到精通——流程
description: 【源码篇】流程
---

本章笔者将演示Svelte从编译到运行的整体流程。

这里笔者使用的Node版本为`18.15.0`。

首先我们下载源码，然后把版本分支切换到`4.2.12`分支。
```bash
git clone git@github.com:sveltejs/svelte.git
```

![项目结构](/images/svelte/37-45.png)

Svelte使用的是`monorepo`的管理方式，首先我们参考README.md的建议安装依赖：
```bash
pnpm install
```

然后我们进入到`sites/svelte.dev`目录，执行`pnpm run dev`。
大概率会遇到这个问题：
![alt text](/images/svelte/37-46.png)

缺少sharp，我们按照提示安装：
```bash
pnpm add --force @img/sharp-darwin-arm64
```

重新运行，遇到一个warning：
![alt text](/images/svelte/37-47.png)

这是因为`svelte.dev`下缺少了一个`.svelte-kit`目录。
我们可以执行`pnpm run check`：
![alt text](/images/svelte/37-48.png)

里面的`svelte-kit sync`帮助我们同步下载这个目录。
![alt text](/images/svelte/37-49.png)

现在我们看到`svelte.dev`下已经有了`.svelte-kit`目录。
![alt text](/images/svelte/37-50.png)

我们重新运行下`pnpm run dev`，正常情况能运行起来。


请读者朋友们结合本章内容和源码对比阅读，效果更佳。

## compile阶段

参照`svelte-loader`中的[逻辑](https://github.com/sveltejs/svelte-loader/blob/master/index.js):
```javascript
svelte.preprocess(source, options.preprocess).then(processed => {
  if (processed.dependencies && this.addDependency) {
    for (let dependency of processed.dependencies) {
      this.addDependency(dependency);
    }
  }

  if (processed.map) compileOptions.sourcemap = processed.map;

  const compiled = svelte.compile(processed.toString(), compileOptions);
  let { js, css, warnings } = compiled;

  callback(null, js.code, js.map);
})
```
首先Svelte文件经过预处理，比如像要添加typescript支持等，然后调用`compile`，最后返回`js.code`。


为了简单直观地查看到各个阶段的执行结果，我们在网站首页`sites/svelte.dev/src/routes/+layout.svelte`直接引入svelte编译器文件：
```diff
  import '@sveltejs/site-kit/styles/index.css';

  import { browser } from '$app/environment';
  import { page } from '$app/stores';
  import { Icon, Shell, Banners } from '@sveltejs/site-kit/components';
  import { Nav, Separator } from '@sveltejs/site-kit/nav';
  import { Search, SearchBox } from '@sveltejs/site-kit/search';
+ import { compile, preprocess } from '../../../../packages/svelte/src/compiler';
```

然后我们仿照`svelte-loader`的逻辑，先调用`preprocess`，然后把预处理的结果打印出来，因为我们本次重点在编译和运行，所以我们只是打印经过`preprocess`后的结果，在`compile`阶段，我们直接传入Svelte文件的字符串内容。
```javascript
let str = `<script>
  let count = 0;
  const addCount = () => {
    count++;
  }
<\/script>

<button on:click={addCount}>add</button>
count:{count}
`;
preprocess(str, {}).then(preResult => {
  console.log('preprocess result', preResult);
  let result = compile(str);
  console.log('compile result', result);
});
```

进入到网站目录`cd sites/svelte.dev`，执行`pnpm run dev`把网站跑起来，在控制台中查看打印结果：
![alt text](/images/svelte/37-1.png)

### parse
`compile(str)`的内部逻辑首先是`parse`，地址：`packages/svelte/src/compiler/compile/index.js`。
```javascript
  console.log('svelte before parse', source);
  const ast = parse(source, options);
  console.log('svelte after parse', ast);
```

![alt text](/images/svelte/37-2.png)  
`source`即是我们的模板字符串，即Svelte文件的内容。

![alt text](/images/svelte/37-3.png)  
经过转换后得到ast对象
```javascript
ast = {
  css: {}
  html: {},
  instance: {},
  module: {}
}
```

点击`parse`，进入到`packages/svelte/src/compiler/parse/index.js`。  
`parse`内部有个`Parser`类，通过实例化该类，对模板字符串文件进行解析。
```javascript
const parser = new Parser(template, options);
```

`Parser`内部则通过四种不同的类型的节点解析器，分别是`fragment`、`tag`、`mustache`和`text`。通过遍历文件的字符串内容，轮流调用这几个方法。

首先，我们没有使用`<style></style>`标签，忽略css解析的步骤。  
在初始化时，默认的html内容整体的type是`Fragment`。把解析后的html数据存储到`this.html`中

```javascript
this.html = {
  start: null,
  end: null,
  type: 'Fragment',
  children: []
};
```

开始解析我们的Svelte文件内容，最开始解析`<script>...`的最左侧`<`，符合`tag`的解析。
```javascript
if (parser.match('<')) {
  return tag;
}
```

点击`tag`，进入`packages/svelte/src/compiler/parse/state/tag.js`。很明显，`script`符合以下逻辑：
```javascript
const specials = new Map([
  [
    'script',
    {
      read: read_script,
      property: 'js'
    }
  ],
  [
    'style',
    {
      read: read_style,
      property: 'css'
    }
  ]
]);
```

调用`read_script`：
```javascript
export default function read_script(parser, start, attributes) {
  ...
  let ast;
  try {
    ast = acorn.parse(source);
  } catch (err) {
    parser.acorn_error(err);
  }
  ...
  return {
    type: 'Script',
    start,
    end: parser.index,
    context: get_context(parser, attributes, start),
    content: ast
  };
}
```

点击`acorn.parse`，我们看到里面的核心便是调用`code-read`的`parse`来解析js的内容：
```javascript
export const parse = (source) =>
  code_red.parse(source, {
    sourceType: 'module',
    ecmaVersion: 13,
    locations: true
  });
```

这部分便是ast对象中的instance属性中的内容：
![alt text](/images/svelte/37-5.png)  
到这里我们已经完成了对`<script>...</script>`标签内容的解析

接下来是重点处理的html的内容。

`<script></script>`解析完成之后，我们遇到了一个空行，空字符串也不能忽略，继续用fragment方法判断。
```javascript
export default function fragment(parser) {
  ...

  return text;
}
```
使用`text`方法来解析这个空行内容。返回的格式：
```javascript
export default function text(parser) {
  ...

  const node = {
    start,
    end: parser.index,
    type: 'Text',
    raw: data,
    data: decode_character_references(data, false)
  };

  parser.current().children.push(node);
}
```
![alt text](/images/svelte/37-6.png)

空行解析完成，我们遇到了`<button>`标签，此时仍旧是调用`fragment`中的`tag`方法。
```javascript
const type = meta_tags.has(name)
    ? meta_tags.get(name)
    : regex_capital_letter.test(name[0]) || name === 'svelte:self' || name === 'svelte:component'
    ? 'InlineComponent'
    : name === 'svelte:fragment'
    ? 'SlotTemplate'
    : name === 'title' && parent_is_head(parser.stack)
    ? 'Title'
    : name === 'slot'
    ? 'Slot'
    : 'Element';

const element = {
  start,
  end: null,
  type,
  name,
  attributes: [],
  children: []
};
```
我们遇到的不是`<script>`、`<style>`此类标签，也不是Svelte的自定义标签，最后得到的是`Element`type。

之后开始读取标签内属性的内容：
```javascript
while ((attribute = read_attribute(parser, unique_names, is_top_level_script_or_style))) {
  element.attributes.push(attribute);
  parser.allow_whitespace();
}
```

```javascript
const name = parser.read_until(regex_token_ending_character);
if (!name) return null;
let end = parser.index;
parser.allow_whitespace();
const colon_index = name.indexOf(':');
const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));
```

`parser.read_until`读取到`on:click`：
```javascript
function get_directive_type(name) {
  if (name === 'use') return 'Action';
  if (name === 'animate') return 'Animation';
  if (name === 'bind') return 'Binding';
  if (name === 'class') return 'Class';
  if (name === 'style') return 'StyleDirective';
  if (name === 'on') return 'EventHandler';
  if (name === 'let') return 'Let';
  if (name === 'in' || name === 'out' || name === 'transition') return 'Transition';
}
```
通过`get_directive_type`来得到attribute的type是`EventHandler`类型。

通过`read_attribute_value`来获取`on:click={}`中`{}`内的值。
```javascript
if (parser.eat('=')) {
  parser.allow_whitespace();
  value = read_attribute_value(parser, is_static);
  end = parser.index;
} 
```

在`read_attribute_value`内部调用`read_sequence`：
```javascript
try {
  value = read_sequence(
    parser,
    () => {
      // handle common case of quote marks existing outside of regex for performance reasons
      if (quote_mark) return parser.match(quote_mark);
      return !!parser.match_regex(regex_starts_with_invalid_attr_value);
    },
    'in attribute value'
  );
} 
```

而`read_sequence`内部则调用`read_expression(parser);`，深挖其核心逻辑，最终是调用`code-red`的`parseExpressionAt`来解析`{}`的内容，将这部分内容赋值到`expression`属性中。

```javascript
import * as code_red from 'code-red';

export const parse_expression_at = (source, index) =>
code_red.parseExpressionAt(source, index, {
  sourceType: 'module',
  ecmaVersion: 13,
  locations: true
});
```

![alt text](/images/svelte/37-7.png)

此时我们已经解析到`<button on:click={addCount}>`。

接着往下，这个`Element`type的children值只有一个节点，那就是add文案所代表的Text节点
![alt text](/images/svelte/37-8.png)  
之后我们算是已经解析到`</button>`。

接着往下我们遇到`count:`，同样是`Text`节点。
![alt text](/images/svelte/37-9.png)

接着遇到`{`，继续调用`fragment`内的`mustache`方法，解析得到`MustacheTag`类型的节点。
```javascript
const expression = read_expression(parser);
parser.allow_whitespace();
parser.eat('}', true);
parser.current().children.push({
  start,
  end: parser.index,
  type: 'MustacheTag',
  expression
});
```

![alt text](/images/svelte/37-10.png)

### Component
执行完`const ast = parse(source, options);`后，我们进入下一步：
```javascript
const component = new Component(
  ast,
  source,
  options.name || get_name_from_filename(options.filename) || 'Component',
  options,
  stats,
  warnings
);
```

`Component`中几个关键的步骤：
```javascript
this.walk_module_js();
this.walk_instance_js_pre_template();
this.fragment = new Fragment(this, ast.html);
this.walk_instance_js_post_template();
```
我们没有声明过`context='module'`的script内容，所以跳过`walk_module_js`。

在`walk_instance_js_pre_template`中调用`create_scopes`来解析script标签内的作用域：
```javascript
const { scope: instance_scope, map, globals } = create_scopes(script.content);
```
可以把这些变量打印出来看下`console.log('svelte Component walk_instance_js_pre_template', instance_scope, map, globals);`

`create_scopes`内部是使用了`periscopic`的`analyse`方法。
```javascript
import { analyze, Scope, extract_names, extract_identifiers } from 'periscopic';

/**
 * @param {import('estree').Node} expression
 */
export function create_scopes(expression) {
  return analyze(expression);
}
```
![alt text](/images/svelte/37-11.png)

调用`this.add_var()`将变量存入`vars`中：
```javascript
add_var(node, variable, add_to_lookup = true) {
  this.vars.push(variable);
  if (add_to_lookup) {
    if (this.var_lookup.has(variable.name)) {
      const exists_var = this.var_lookup.get(variable.name);
      if (exists_var.module && exists_var.imported) {
        this.error(/** @type {any} */ (node), compiler_errors.illegal_variable_declaration);
      }
    }
    this.var_lookup.set(variable.name, variable);
  }
}
```

打印出来看下：
```diff
  this.walk_instance_js_pre_template();
+ console.log('svelte Component this', this);
```

![alt text](/images/svelte/37-12.png)

执行完`this.walk_instance_js_pre_template();`，继续下一步：
```javascript
this.fragment = new Fragment(this, ast.html);
```

`Fragment`内部，执行`map_children`方法：
```javascript
export default class Fragment extends Node {
  constructor(component, info) {
    const scope = new TemplateScope();
    super(component, null, scope, info);
    this.scope = scope;
    this.children = map_children(component, this, scope, info.children);
  }
}
```

```diff
  this.children = map_children(component, this, scope, info.children);
+ console.log('svelte Fragment children', this.children);
```
![alt text](/images/svelte/37-13.png)

把数组的每项展开看下：
![alt text](/images/svelte/37-14.png)
![alt text](/images/svelte/37-15.png)
![alt text](/images/svelte/37-16.png)
![alt text](/images/svelte/37-17.png)

`map_children`的作用是将ast中的节点进行转换。

执行完`new Fragment()`，继续下一步：
```javascript
walk_instance_js_post_template() {
  const script = this.ast.instance;
  if (!script) return;
  this.post_template_walk();
  this.hoist_instance_declarations();
  this.extract_reactive_declarations();
  this.check_if_tags_content_dynamic();
}
```
执行`walk_instance_js_post_template`中的`this.post_template_walk`
walk的content就是ast.instance.content的内容。
```javascript
post_template_walk() {
  const script = this.ast.instance;
  if (!script) return;
  const component = this;
  const { content } = script;

  ...

  walk(content, {
    enter(node, parent, prop, index) {},
    leave(node) {}
  })
}
```

把content打印出来看下：
![alt text](/images/svelte/37-18.png)

这个`walk_instance_js_post_template`的主要作用是：
对节点进行一些额外的检查，例如检查是否有未关闭的标签，是否有不合法的属性等。
对节点进行一些优化，例如移除不必要的空白节点，合并连续的文本节点等。
收集一些信息，例如收集所有使用的组件，收集所有的依赖等。

```diff
const component = new Component(
  ast,
  source,
  options.name || get_name_from_filename(options.filename) || 'Component',
  options,
  stats,
  warnings
);
+  console.log('svelte component', component);
```
把`new Component()`的结果打印出来看下：
![alt text](/images/svelte/37-19.png)

### render_dom
往下执行`render_dom`，查看下`render_dom`的执行逻辑：
```javascript
const result =
  options.generate === false
    ? null
    : options.generate === 'ssr'
    ? render_ssr(component, options)
    : render_dom(component, options);
```
点击`render_dom`进入内部，内部有个`Renderer`：
```javascript
const renderer = new Renderer(component, options);
```

`Renderer`内部：
```javascript
this.block = new Block({
  renderer: this,
  name: null,
  type: 'component',
  key: null,
  bindings: new Map(),
  dependencies: new Set()
});
this.block.has_update_method = true;
this.fragment = new FragmentWrapper(
  this,
  this.block,
  component.fragment.children,
  null,
  true,
  null
);
this.fragment.render(this.block, null, /** @type {import('estree').Identifier} */ (x`#nodes`));
```

看下`Block`的实现，`Block`的`constructor`如下：
```javascript
constructor(options) {
  this.parent = options.parent;
  this.renderer = options.renderer;
  this.name = options.name;
  this.type = options.type;
  this.comment = options.comment;
  this.wrappers = [];
  // for keyed each blocks
  this.key = options.key;
  this.first = null;
  this.bindings = options.bindings;
  this.chunks = {
    declarations: [],
    init: [],
    create: [],
    claim: [],
    hydrate: [],
    mount: [],
    measure: [],
    restore_measurements: [],
    fix: [],
    animate: [],
    intro: [],
    update: [],
    outro: [],
    destroy: []
  };
  this.has_animation = false;
  this.has_intro_method = false; // a block could have an intro method but not intro transitions, e.g. if a sibling block has intros
  this.has_outro_method = false;
  this.outros = 0;
  this.get_unique_name = this.renderer.component.get_unique_name_maker();
  this.aliases = new Map();
  if (this.key) this.aliases.set('key', this.get_unique_name('key'));
}
```
![alt text](/images/svelte/37-20.png)
用来表示一个代码块的类，它包含了一些关于这个代码块的信息，例如它的类型，它的依赖，它的绑定等。

了解完`Block`，下一步`FragmentWrapper`：
```javascript
this.fragment = new FragmentWrapper(
  this,
  this.block,
  component.fragment.children,
  null,
  true,
  null
);
```
Svelte内部用来表示一个模板片段的类，它包含了一些关于这个模板片段的信息，例如它的子节点，它的父节点等。

继续下一步：
```javascript
this.fragment.render(this.block, null, /** @type {import('estree').Identifier} */ (x`#nodes`));
```

就是`FragmentWrapper`内部的`render`方法：
```javascript
render(block, parent_node, parent_nodes) {
  for (let i = 0; i < this.nodes.length; i += 1) {
    this.nodes[i].render(block, parent_node, parent_nodes);
  }
}
```

![alt text](/images/svelte/37-21.png)

这里的nodes是调用各个类型的wrapper实例化后的对象，每个wrapper类有自己的render方法：
```javascript
const wrappers = {
  AwaitBlock,
  Body,
  Comment,
  DebugTag,
  Document,
  EachBlock,
  Element,
  Head,
  IfBlock,
  InlineComponent,
  KeyBlock,
  MustacheTag,
  Options: null,
  RawMustacheTag,
  Slot,
  SlotTemplate,
  Text,
  Title,
  Window
};
```

简单看一些wrapper的实现，比如Text Wrapper：
```javascript
render(block, parent_node, parent_nodes) {
  if (this.skip) return;
  const use_space = this.use_space();
  const string_literal = {
    type: 'Literal',
    value: this.data,
    loc: {
        start: this.renderer.locate(this.node.start),
        end: this.renderer.locate(this.node.end)
    }
  };
  block.add_element(
    this.var,
    use_space ? x`@space()` : x`@text(${string_literal})`,
    parent_nodes &&
        (use_space
          ? x`@claim_space(${parent_nodes})`
          : x`@claim_text(${parent_nodes}, ${string_literal})`),
    /** @type {import('estree').Identifier} */ (parent_node)
  );
}
```

这里调用了`code-red`的`x`方法，把内容打印出来看下：

```diff
+ console.log('svelte text wrapper render', x`@text(${string_literal})`);
  block.add_element(
  this.var,
  use_space ? x`@space()` : x`@text(${string_literal})`,
  ...
```
![alt text](/images/svelte/37-22.png)


Element的`render`方法：
```javascript
render(block, parent_node, parent_nodes) {
  if (this.child_dynamic_element) {
    this.render_dynamic_element(block, parent_node, parent_nodes);
  } else {
    this.render_element(block, parent_node, parent_nodes);
  }
}
```

看下这个`render_element`的实现：
```javascript
render_element(block, parent_node, parent_nodes) {
  const { renderer } = this;
  const hydratable = renderer.options.hydratable;
  if (this.node.name === 'noscript') return;
  const node = this.var;
  const nodes = parent_nodes && block.get_unique_name(`${this.var.name}_nodes`);
  const children = x`@children(${this.node.name === 'template' ? x`${node}.content` : node})`;
  block.add_variable(node);
  const render_statement = this.get_render_statement(block);
  block.chunks.create.push(b`${node} = ${render_statement};`);
  const { can_use_textcontent, can_optimise_to_html_string, can_optimise_hydration } = this.node;
  ...
  if (parent_node) {
    ...
  } else {
    const insert = b`@insert(#target, ${node}, #anchor);`;
    ((insert[0]).expression).callee.loc = {
      start: this.renderer.locate(this.node.start),
      end: this.renderer.locate(this.node.end)
    };
    block.chunks.mount.push(insert);
    block.chunks.destroy.push(b`if (detaching) @detach(${node});`);
  }
  if (can_optimise_to_html_string && (!hydratable || can_optimise_hydration)) {
    if (this.fragment.nodes.length === 1 && this.fragment.nodes[0].node.type === 'Text') {
      /** @type {import('estree').Node} */
      let text = string_literal(
        /** @type {import('../Text.js').default} */ (this.fragment.nodes[0]).data
      );
      ...
      block.chunks.create.push(b`${node}.textContent = ${text};`);
      ...
    } else {
      ...
    }
  } else {
    this.fragment.nodes.forEach((child) => {
      child.render(block, this.node.name === 'template' ? x`${node}.content` : node, nodes, {
        element_data_name: this.element_data_name
      });
    });
  }
  
  ...
  block.renderer.dirty(this.node.tag_expr.dynamic_dependencies());
}
```

我们尝试把它的`children`打印出来看下：
```diff
const node = this.var;
  const nodes = parent_nodes && block.get_unique_name(`${this.var.name}_nodes`); // if we're in unclaimable territory, i.e. <head>, parent_nodes is null
  const children = x`@children(${this.node.name === 'template' ? x`${node}.content` : node})`;
  block.add_variable(node);
+ console.log('svelte render_element children', children);
  const render_statement = this.get_render_statement(block);
```
![alt text](/images/svelte/37-23.png)


```diff
  const insert = b`@insert(#target, ${node}, #anchor);`;
  /** @type {import('estree').CallExpression} */ (
    /** @type {import('estree').ExpressionStatement} */ (insert[0]).expression
  ).callee.loc = {
    start: this.renderer.locate(this.node.start),
    end: this.renderer.locate(this.node.end)
  };
  block.chunks.mount.push(insert);
  block.chunks.destroy.push(b`if (detaching) @detach(${node});`);
+ console.log('svelte render_element insert', insert, node, b`if (detaching) @detach(${node});`)
```
![alt text](/images/svelte/37-24.png)
![alt text](/images/svelte/37-25.png)

```javascript
this.fragment.nodes.forEach((child) => {
  child.render(block, this.node.name === 'template' ? x`${node}.content` : node, nodes, {
    element_data_name: this.element_data_name
  });
});
```
依次调用`render`方法。

`MustachTag`的`render`方法：
```javascript
render(block, parent_node, parent_nodes, data) {
  const contenteditable_attributes =
    this.parent instanceof ElementWrapper &&
    this.parent.attributes.filter((a) => a.node.name === 'contenteditable');
  const spread_attributes =
    this.parent instanceof ElementWrapper &&
    this.parent.attributes.filter((a) => a.node.is_spread);

  ...
  const { init } = this.rename_this_method(block, (value) => {
    if (contenteditable_attr_value) {
      ...
    } else {
      return x`@set_data(${this.var}, ${value})`;
    }
  });
  block.add_element(
    this.var,
    x`@text(${init})`,
    parent_nodes && x`@claim_text(${parent_nodes}, ${init})`,
    parent_node
  );
}
```

```diff
const { init } = this.rename_this_method(block, (value) => {
  if (contenteditable_attr_value) {
    if (contenteditable_attr_value === true) {
      return x`@set_data_contenteditable(${this.var}, ${value})`;
    } else {
      return x`@set_data_maybe_contenteditable(${this.var}, ${value}, ${contenteditable_attr_value})`;
    }
  } else {
+   console.log('svelte mustachetag rename_this_method', x`@set_data(${this.var}, ${value})`, this.var, value);
    return x`@set_data(${this.var}, ${value})`;
  }
});
```

![alt text](/images/svelte/37-26.png)

返回到`packages/svelte/src/compiler/compile/render_dom/index.js`
```diff
export default function dom(component, options) {
  const { name } = component;
  const renderer = new Renderer(component, options);
+ console.log('svelte renderer', renderer);
  const { block } = renderer;
  ...
```

![alt text](/images/svelte/37-27.png)
在刚才查看各个render方法时，我们注意到它一直在操作`block.chunk`，现在我们可以看到上面的`create`、`mount`、`update`和`destroy`上的逻辑代码已准备就绪。我们也知道了`render_dom`的主要作用就是把代码转化成能真正挂载到页面上的节点，同时处理了页面的各个生命周期。

`render_dom`中一段非常重要的解析：
```javascript
walk(component.ast.instance.content, {
  enter(node) {
    ...
  },
  leave(node) {
    if (map.has(node)) {
      scope = scope.parent;
    }
    if (execution_context === node) {
      execution_context = null;
    }
    if (node.type === 'AssignmentExpression' || node.type === 'UpdateExpression') {
      const assignee = node.type === 'AssignmentExpression' ? node.left : node.argument;
      // normally (`a = 1`, `b.c = 2`), there'll be a single name
      // (a or b). In destructuring cases (`[d, e] = [e, d]`) there
      // may be more, in which case we need to tack the extra ones
      // onto the initial function call
      const names = new Set(extract_names(/** @type {import('estree').Node} */ (assignee)));
      this.replace(invalidate(renderer, scope, node, names, execution_context === null));
    }
  }
});
```
大家对`this.replace`还有印象吗？不错，我们在《库》章节演示estree-walk时演示过这个方法，`this.replace(invalidate(renderer, scope, node, names, execution_context === null))`对Svelte文件中涉及到更新的代码进行替换，替换成`$$invalidate`相关形式的代码。

查看下invalidate的逻辑，`packages/svelte/src/compiler/compile/render_dom/invalidate.js`：
```diff
invalidate = x`$$invalidate(${
  renderer.context_lookup.get(head.name).index
}, ${node}, ${extra_args})`;
+ console.log('svelte invalidate', invalidate, renderer.context_lookup, node);
```

![alt text](/images/svelte/37-28.png)

继续回到`render_dom`方法
```javascript
const has_create_fragment = component.compile_options.dev || block.has_content();
if (has_create_fragment) {
  body.push(b`
    function create_fragment(#ctx) {
      ${block.get_contents()}
    }
  `);
}
```
很明显，这段就是到时会编译到页面上的`create_fragment`方法。我们可以把`block.get_contents`打印出来看一下
![alt text](/images/svelte/37-29.png)
笔者之前都是使用console.log这种粗暴直接的方法来进行演示，一是快速直接，二是在控制台中打印出数据的全貌便于浏览。如果读者对断点调试得心应手，也可像上图般对各个关键节点进行打断点调试。

```javascript
const condition =
  !uses_rest_or_props && writable.length > 0 && renderer.dirty(writable, true);
let statement = d.node;
if (condition)
  statement = /** @type {import('estree').Statement} */ (
    b`if (${condition}) { ${statement} }`[0]
  );
```
此段代码是用来编译条件判断ifblock的展示。

继续往下：
```javascript
body.push(b`
  function ${definition}(${args}) {
    ${injected.map((name) => b`let ${name};`)}

    ${rest}

    ${reactive_store_declarations}

    ${reactive_store_subscriptions}

    ${resubscribable_reactive_store_unsubscribers}

    ${
      component.slots.size || component.compile_options.dev || uses_slots
        ? b`let { $$slots: #slots = {}, $$scope } = $$props;`
        : null
    }
    ...

    ${instance_javascript}

    ...

    ${/* before reactive declarations */ props_inject}

    ${
      reactive_declarations.length > 0 &&
      b`
    $$self.$$.update = () => {
      ${reactive_declarations}
    };
    `
    }

    ...

    return ${return_value};
  }
`);
```
我们把definition和args打印出来看下
![alt text](/images/svelte/37-30.png)
从打印结果我们能够推断出，这段代码编译后对应的是`function instance(){}`

```javascript
const superclass = {
  type: 'Identifier',
  name: options.dev ? '@SvelteComponentDev' : '@SvelteComponent'
};
...
const declaration = /** @type {import('estree').ClassDeclaration} */ (
  b`
  class ${name} extends ${superclass} {
    constructor(options) {
      super(${options.dev && 'options'});
      @init(this, options, ${definition}, ${
    has_create_fragment ? 'create_fragment' : 'null'
  }, ${not_equal}, ${prop_indexes}, ${optional_parameters});
      ${
        options.dev &&
        b`@dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "${name.name}", options, id: create_fragment.name });`
      }
    }
  }
`[0]
);
push_array(declaration.body.body, accessors);
body.push(/** @type {any} */ (declaration));
```
这段代码则对应编译后的组件的类`class X extends SvelteComponent {}`

```diff
const result =
  options.generate === false
    ? null
    : options.generate === 'ssr'
    ? render_ssr(component, options)
    : render_dom(component, options);
+ console.log('svelte compile result', result);
```
![alt text](/images/svelte/37-31.png)

### generate
终于来到编译的最后一步。

```javascript
generate(result) {
  let js = null;
  let css = null;
  if (result) {

    /** @type {any} */
    const program = { type: 'Program', body: result.js };
    walk(program, {
      enter: (node, parent, key) => {
        if (node.type === 'Identifier') {
          ...
        }
      }
    });
    ...
    create_module(
      program,
      name,
      banner,
      compile_options.sveltePath,
      imported_helpers,
      referenced_globals,
      this.imports,
      this.vars
        .filter((variable) => variable.module && variable.export_name)
        .map((variable) => ({
          name: variable.name,
          as: variable.export_name
        })),
      this.exports_from
    );
    const js_sourcemap_enabled = check_enable_sourcemap(compile_options.enableSourcemap, 'js');
    if (!js_sourcemap_enabled) {
      js = print(program);
      js.map = null;
    } else {
      ...
    }
  }
  return {
    js,
    css,
    ast: this.original_ast,
    warnings: this.warnings,
    vars: this.get_vars_report(),
    stats: this.stats.render()
  };
}
```

`create_module`方法
```javascript
export default function create_module(
  program,
  name,
  banner,
  svelte_path = 'svelte',
  helpers,
  globals,
  imports,
  module_exports,
  exports_from
) {
  const internal_path = `${svelte_path}/internal`;
  helpers.sort((a, b) => (a.name < b.name ? -1 : 1));
  globals.sort((a, b) => (a.name < b.name ? -1 : 1));
  return esm(
    program,
    name,
    banner,
    svelte_path,
    internal_path,
    helpers,
    globals,
    imports,
    module_exports,
    exports_from
  );
}

function esm(
  program,
  name,
  banner,
  svelte_path,
  internal_path,
  helpers,
  globals,
  imports,
  module_exports,
  exports_from
) {
  const import_declaration = {
    type: 'ImportDeclaration',
    specifiers: helpers.map((h) => ({
      type: 'ImportSpecifier',
      local: h.alias,
      imported: { type: 'Identifier', name: h.name }
    })),
    source: { type: 'Literal', value: internal_path }
  };

  ...

  program.body = b`
    /* ${banner} */

    ${import_declaration}
    ${internal_globals}
    ${imports}
    ${exports_from}

    ${program.body}

    export default ${name};
    ${exports}
  `;
}

```
核心就是编译生成页面最终的`import`和`export`部分的内容。

![alt text](/images/svelte/37-32.png)  
![alt text](/images/svelte/37-33.png)

我们尝试把import部分的代码变量打印出来看下：
```diff
const import_declaration = {
  type: 'ImportDeclaration',
  specifiers: helpers.map((h) => ({
    type: 'ImportSpecifier',
    local: h.alias,
    imported: { type: 'Identifier', name: h.name }
  })),
  source: { type: 'Literal', value: internal_path }
};
+ console.log('svelte import_declaration', import_declaration, helpers);
```
![alt text](/images/svelte/37-34.png)

最后经过code-red的`print`方法生成最终的js代码
```javascript
if (!js_sourcemap_enabled) {
  js = print(program);
  js.map = null;
} 
```

```diff
const result =
  options.generate === false
    ? null
    : options.generate === 'ssr'
    ? render_ssr(component, options)
    : render_dom(component, options);
+ console.log('svelte final code',
+   component.generate(result),
+   component.generate(result).js.code
+ );
```
![alt text](/images/svelte/37-35.png)  
![alt text](/images/svelte/37-36.png)


回看`svelte-loader`的代码，同样是返回`js.code`的代码。
`https://github.com/sveltejs/svelte-loader/blob/master/index.js`
![alt text](/images/svelte/37-37.png)

最后提供一个compile阶段的思维导图：
![](/images/svelte/37-43.png)

## runtime

我们把在编译后得到的js代码复制进一个文件中`index.js`。
在svelte源码项目目录下新建一个目录叫`test-runtime`，新建一个index.html：
```html
<div id="app"></div>
<script type="module" src="./index.js"></script>
```

![alt text](/images/svelte/37-38.png)

修改index.js的几处地方：
- 把引用`svelte/internal`的路径进行调整`../packages/svelte/src/runtime/internal`；
- 把`import "svelte/internal/disclose-version";`移除；
- 注释最下面一行的`export default Component`，改成：
```javascript
new Component({
  target: document.querySelector('#app')
})
```

在`test-runtime`目录下
```bash
npm init -y
npm install vite
```
在`package.json`中添加运行指令：
```diff
"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1",
+ "dev": "vite"
},
```
`npm run dev`把项目跑起来：
![alt text](/images/svelte/37-39.png)

在`runtime`阶段，我们主要观察数据是如何更新的。

首先是当我们点击button时
```javascript
if (!mounted) {
  dispose = listen(button, "click", /*addCount*/ ctx[1]);
  mounted = true;
}
```
这里click绑定的监听方法是`ctx[1]`，经过前面的学习，我们知道，ctx数组就是instance方法执行后的返回值。
```javascript
function instance($$self, $$props, $$invalidate) {
  let count = 0;

  const addCount = () => {
    $$invalidate(0, count++, count);
  };

  return [count, addCount];
}
```

也就是我们点击按钮之后，会执行addCount方法，addCount内部的赋值语句已经被重新编译后，变成了`$$invalidate()`。
```diff
instance(component, options.props || {}, (i, ret, ...rest) => {
  const value = rest.length ? rest[0] : ret;
+ console.log('svelte instance $$invalidate', i, ret, rest);
  if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
    if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
    if (ready) make_dirty(component, i);
  }
  return ret;
})
```

![alt text](/images/svelte/37-40.png)
i是0，ret是未更新前的值0，rest数组中是更新后的值1。
经过`not_equal`比较后0和1不相等，触发`make_dirty`。
我们把剩余的关键节点都逐个打印出来

```diff
function make_dirty(component, i) {
+ console.log('svelte make_dirty', component, i);
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
+   console.log('svelte component.$$.dirty before', [...component.$$.dirty]);
  }
  component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
+ console.log('svelte component.$$.dirty after', component.$$.dirty);
}
```

```diff
export function schedule_update() {
+ console.log('svelte schedule_update');
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
```

```diff
export function flush() {
+ console.log('svelte flush', flushidx, dirty_components);
  
  ...

  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      ...
    }
  }
  ...
}
```

```diff
function update($$) {
+ console.log('svelte update');
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
```

```diff
p(ctx, [dirty]) {
+ console.log('svelte runtime p', ctx, dirty);
  if (dirty & /*count*/ 1) set_data(t2, /*count*/ ctx[0]);
},
```

当我们刷新页面时，执行了`flush`：
![alt text](/images/svelte/37-41.png)

当我们点击button进行更新：
![alt text](/images/svelte37-42.png)

首先执行`$$invalidate`，然后执行`make_dirty`，然后执行`schedule_update`。
我们看到`schedule_update`内部其实就是把`flush`放到微任务中执行，所以我们会先看到`component.$$.dirty`在更新前的值是`[0]`，然后执行位运算之后变成`[1]`。之后执行微任务中的`flush`，`flush`内部调用`update`，而`update`方法则是调用组件内的`p`方法。`p`方法中通过`dirty & 1`的判断`1 & 1`，从而执行`set_data`。

```javascript
export function set_data(text, data) {
  data = '' + data;
  if (text.data === data) return;
  text.data = /** @type {string} */ (data);
}
```
`set_data`方法的主要逻辑则是更新text节点的data属性的值。

最后也提供一个简易的流程图：
![](/images/svelte/37-44.png)

## 小结

本章我们学习了：
- compile的执行流程
- runtime的执行流程

compile和runtime的难易程度，基本符合二八定律，百分之八十的内容都在编译器如何解析Svelte文件上。---
title: Svelte从入门到精通——runtime
description: 【源码篇】runtime
---

要了解Svelte的运行时逻辑，可以从它编译后的代码出发。我们在[REPL](https://svelte.dev/repl/hello-world?version=4.2.12)编写一个简易的程序。

```html
<script>
  let count = 0;
  const updateCount = () => {
    count++;
  }
</script>

<button on:click={updateCount}>add count</button> 
<p>count: {count}</p>
{#if count> 2}
  hello svelte!!!
{/if}
```

看下编译后的js代码：
```javascript
/* App.svelte generated by Svelte v4.2.12 */
import {
  SvelteComponent,
  append,
  detach,
  element,
  empty,
  init,
  insert,
  listen,
  noop,
  safe_not_equal,
  set_data,
  space,
  text
} from "svelte/internal";

import "svelte/internal/disclose-version";

function create_if_block(ctx) {
  let t;

  return {
    c() {
      t = text("hello svelte!!!");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}

function create_fragment(ctx) {
  let button;
  let t1;
  let p;
  let t2;
  let t3;
  let t4;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = /*count*/ ctx[0] > 2 && create_if_block(ctx);

  return {
    c() {
      button = element("button");
      button.textContent = "add count";
      t1 = space();
      p = element("p");
      t2 = text("count: ");
      t3 = text(/*count*/ ctx[0]);
      t4 = space();
      if (if_block) if_block.c();
			if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, button, anchor);
      insert(target, t1, anchor);
      insert(target, p, anchor);
      append(p, t2);
      append(p, t3);
      insert(target, t4, anchor);
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);

      if (!mounted) {
        dispose = listen(button, "click", /*updateCount*/ ctx[1]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*count*/ 1) set_data(t3, /*count*/ ctx[0]);

      if (/*count*/ ctx[0] > 2) {
        if (if_block) {
					
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t1);
        detach(p);
        detach(t4);
        detach(if_block_anchor);
      }

      if (if_block) if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}

function instance($$self, $$props, $$invalidate) {
  let count = 0;

  const updateCount = () => {
    $$invalidate(0, count++, count);
  };

  return [count, updateCount];
}

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}

export default App;
```

我们理一下编译后的大体逻辑：
- 首先是建一个`SvelteComponent`类，该类由`svelte/internal`导出。在`SvelteComponent`类实例化时调用`init`方法。`init`方法中比较关键的参数有`instance`和`create_fragment`。
- `instance`是一个方法，里面有用于触发响应式更新的方法`$$invalidate`。
- `create_fragment`组件完整的生命周期，包含了创建、挂载、更新和卸载等。

我们所关注的运行时逻辑都在源码仓库的`packages/svelte/src/runtime`里。
![](/images/svelte/36-1.png)

## SvelteComponent

源码路径：`packages/svelte/src/runtime/internal/Component.js`
```javascript
export class SvelteComponent {
  $$ = undefined;
  $$set = undefined;
  $destroy() {}
  $on(type, callback) {}
  $set(props) {}
}
```

`SvelteComponent`中定义了一些属性和方法，在官网的[Client-side component API](https://svelte.dev/docs/client-side-component-api)中，有介绍这些方法的使用，我们集中关注`$$`这个属性，后面大量的数据会挂载到这个属性上。

## init
`init`方法，在组件初始化时执行的唯一方法，由`svelte/internal`导出。

源码路径：`packages/svelte/src/runtime/internal/Component.js`

```javascript
export function init(
  component,
  options,
  instance,
  create_fragment,
  not_equal,
  props,
  append_styles = null,
  dirty = [-1]
) {
  const parent_component = current_component;
  set_current_component(component);
  /** @type {import('./private.js').T$$} */
  const $$ = (component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  });

  let ready = false;
  $$.ctx = instance
    ? instance(component, options.props || {}, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
          if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
          if (ready) make_dirty(component, i);
        }
        return ret;
      })
    : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
  if (options.target) {
    $$.fragment && $$.fragment.c();
    mount_component(component, options.target, options.anchor);
    flush();
  }
  set_current_component(parent_component);
}
```
这里笔者删除了一些无关代码，比如样式的添加，hydrate注水逻辑等。

先看下`init`接收的几个参数：
```javascript
init(
  component,
  options,
  instance,
  create_fragment,
  not_equal,
  props,
  append_styles = null,
  dirty = [-1]
) 
```
- component：组件实例，即组件初始化时传的this
- instance：外部传入的方法，内含数据更新逻辑
- create_fragment：外部传入的方法，组件的生命周期逻辑
- dirty：组件内的数据更新标识

init的逻辑：
- 进入`init`，首先设置当前组件为正在运行的组件，往组件的`$$`属性中挂载大量属性
- 执行`instance`方法，`instance`接收三个参数，第一个参数是组件实例，第三个参数是一个方法，其实它就是`$$invalidate`（待会分析），执行后将返回值挂载到`$$.ctx`。我们可以把`$$.ctx`理解为组件的上下文，每个组件都有自己的上下文，其中存储的是在`<script></script>`内定义的变量的值和涉及到变量更新的方法，Svelte会按照变量在组件内的声明顺序依次保存在`$$.ctx`数组当中，先保存变量，再变量方法。
- 进行更新，`run_all($$.before_update)`在`mount_component`之前，对应了我们在生命周期里了解到的第一次`beforeUpdate`是在`onMount`之前执行的。
- `create_fragment`创建组件的fragment，同时挂载到`$$.fragment`。`mount_component`挂载组件到页面上。
- 执行`flush`方法。
- 执行完这个组件的逻辑后，重置当前组件为父组件。

### instance

我们可以把`instance`方法是理解成是svelte实例的执行器，里面包含的是一个组件应该如何运行的逻辑。我们在Svelte组件中写在`<script></script>`里的代码，会被编译进`instance`方法内。每个组件在执行`init`初始化时，会调用一次`instance`方法形成自己的闭包，从而达到数据隔离的目的。

比如我们最开始的例子里：
```javascript
<script>
  let count = 0;
  const updateCount = () => {
    count++;
  }
</script>
```

被编译后，变成：
```javascript
function instance($$self, $$props, $$invalidate) {
  let count = 0;

  const updateCount = () => {
    $$invalidate(0, count++, count);
  };

  return [count, updateCount];
}
```

#### `$$invalidate`
```typescript
(i, ret, ...rest) => {
	const value = rest.length ? rest[0] : ret;
	if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
		if (ready) make_dirty(component, i);
	}
	return ret;
}
```
`$$invalidate`的逻辑：
- 首先是编译器将我们原来的赋值代码进行了更改，将`count++`转变成`$$invalidate(0, count++, count)`，看下`$$invalidate`的三个参数`(i, ret, ...rest)`：i表示是组件内的第几个变量，ret是表达式，`...rest`是剩余参数
- 首先是进行赋值`($$.ctx[i] = value)`，然后通过`not_equal`判断赋值前后的变量是否改变，如果改变了，通过`make_dirty`标记组件为dirty（非常关键！！！）

调用`$$invalidate`，会对某个改动的变量进行标记，然后在微任务中调用`flush`函数，根据变量改动的dirty标记进行局部更新。

##### make_dirty

源码路径：`packages/svelte/src/runtime/internal/Component.js`
```javascript
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
}
```

`make_dirty`的逻辑如下：
- 首先检查组件是否已经被标记为dirty。如果没有（Svelte中约定，`$$.dirty`数组的第一项如果是-1，则非dirty)，那么将组件添加到dirty_components数组中，并调度一个更新。
- 将组件的dirty标志位数组原来是`[-1]`的填充为`[0]`，既标记了组件是dirty状态，又方便后续的位运算操作
- 最后将参数i指定的部分标记为dirty，通过将dirty标志位数组的相应元素设置为1来实现的。终于轮到位运算上场！

###### schedule_update

```typescript
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;

export function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
```
在`Promise.then`微任务中执行更新。
### create_fragment

`create_fragment`是Svelte文件编译后输出的一个方法，里面包含了组件具体的生命周期。
```javascript
function create_fragment(ctx) {
  let button;
  ...
  let if_block = /*count*/ ctx[0] > 2 && create_if_block(ctx);

  return {
    c() {
      button = element("button");
      button.textContent = "add count";
      t1 = space();
      p = element("p");
      t2 = text("count: ");
      t3 = text(/*count*/ ctx[0]);
      ...
    },
    m(target, anchor) {
      insert(target, button, anchor);
      ...
      append(p, t2);
      ...

      if (!mounted) {
        dispose = listen(button, "click", /*updateCount*/ ctx[1]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*count*/ 1) set_data(t3, /*count*/ ctx[0]);
    },
    d(detaching) {
      if (detaching) {
         detach(button);
        ...
      }
    }
  };
}
```

`create_fragment`的逻辑：
- `create_fragment`接收一个参数ctx，我们通过前面知道，这个ctx就是`instance`方法执行后的返回值，ctx是一个数组，包含了数据和用于更新数据的方法，比如：
![](/images/svelte/36-2.png)

- `create_fragment`方法返回一个对象，这个对象内包含 `c,m,p,i,o,d`等特殊名称的函数，这些函数并非编译混淆，而是Fragment内部的生命周期缩写，这个对象会挂载到`$$.fragment`上。
```javascript
// 源码路径：packages/svelte/src/runtime/internal/private.d.ts
export interface Fragment {
  key: string | null;
  first: null;
  /* create  */ c: () => void;
  /* claim   */ l: (nodes: any) => void;
  /* hydrate */ h: () => void;
  /* mount   */ m: (target: HTMLElement, anchor: any) =>   void;
  /* update  */ p: (ctx: T$$['ctx'], dirty: T$$['dirty'])   => void;
  /* measure */ r: () => void;
  /* fix     */ f: () => void;
  /* animate */ a: () => void;
  /* intro   */ i: (local: any) => void;
  /* outro   */ o: (local: any) => void;
  /* destroy */ d: (detaching: 0 | 1) => void;
}
```
- 在创建时，会调用封装好的`element`、`space`、`text`等方法；在挂在时调用`insert`、`append`等方法；在更新时，通过dirty数组中的值进行位运算，判断是否需要更新数据，还记得我们前面章节学习到的位运算的知识吗，在Svelte源码中，凡是涉及到dirty的地方，位运算无处不在；在卸载时调用`detach`等方法。

#### 封装

源码路径：`packages/svelte/src/runtime/internal/dom.js`
```typescript
export function append(target: Node, node: Node) {
  target.appendChild(node);
}

export function detach(node: Node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}

export function element<K extends keyof HTMLElementTagNameMap>(name: K) {
  return document.createElement<K>(name);
}

export function insert(target: Node, node: Node, anchor?: Node) {
  target.insertBefore(node, anchor || null);
}

export function listen(node: EventTarget, event: string, handler: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions | EventListenerOptions) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}

export function text(data: string) {
  return document.createTextNode(data);
}
```

### mount_component

源码路径：`packages/svelte/src/runtime/internal/Component.js`

```javascript
export function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  // onMount happens before the initial afterUpdate
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);

    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
```
调用fragment的`m()`方法，这里我们可以看到，会调用`onMount`方法，如果`onMount`有返回值，则相当于是`destroy`方法。

### flush

源码路径：`packages/svelte/src/runtime/internal/scheduler.js`

```javascript
let flushidx = 0;

export function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
```
`flush`函数的主要作用是更新和渲染组件，其步骤如下：
- 通过`flushidx !== 0`检查是否已经在更新脏组件，如果是则返回，避免无限循环。
- 先保存当前组件，然后在一个do-while循环中，首先调用`beforeUpdate`函数并更新组件。如果在更新过程中出现错误，会重置脏状态以避免死锁。
- 清空脏组件列表，重置`flushidx`，然后调用所有`bind:this`回调函数。
- 在组件更新后，调用`afterUpdate`函数。这可能会导致后续的更新，所以需要防止无限循环。之后清空渲染回调列表。
- 如果还有脏组件，重复上述步骤。
- 调用所有`flush`回调函数。清除已调用的回调函数列表。
- 恢复保存的当前组件。

这个函数的主要目的是确保所有的组件都被正确地更新和渲染，同时避免因为错误或无限循环导致的问题。

#### update
```typescript
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);

    $$.after_update.forEach(add_render_callback);
  }
}
```

一言蔽之，就是把需要更新的组件给更新了。调用 `$$.update`,调用组件里的`$$.fragment.p`方法，执行`$$.after_update`的回调。

## 更新流程

我们重新整理下组件的更新逻辑：
- 用户执行具体操作触发更新流程
- 在instance的`$$invalidate`方法中，通过`not_equal`比较操作前后`$$.ctx`中的值是否发生了改变，如果发生改变则继续执行`make_dirty`
- 执行`make_dirty`函数标记为脏值，添加带有脏值需要更新的组件，从而继续触发更新
- 执行`schedule_update`函数
- 执行`flush`函数，取出所有的脏值组件，执行update方法`update(component.$$)`
- 在`update`方法中，执行的是组件的`fragment.p`方法，p方法的逻辑就是确定需要更新组件，并操作和更新dom组件，从而完成了最后的流程

我们用以下例子来进行说明：
```html
<script>
  let count = 0;
  let count2 = 0;
</script>

<button on:click={() => count++}>add</button>
<button on:click={() => count2++}>add2</button>
{count} {count2}
```

它的编译结果如下：
```javascript
/* App.svelte generated by Svelte v4.2.12 */
import {
	...
} from "svelte/internal";

function create_fragment(ctx) {
  ...

  return {
    c() {
      button0 = element("button");
      button0.textContent = "add";
      t1 = space();
      button1 = element("button");
      button1.textContent = "add2";
      t3 = space();
      t4 = text(/*count*/ ctx[0]);
      t5 = space();
      t6 = text(/*count2*/ ctx[1]);
    },
    m(target, anchor) {
      ...

      if (!mounted) {
        dispose = [
          listen(button0, "click", /*click_handler*/ ctx[2]),
          listen(button1, "click", /*click_handler_1*/ ctx[3])
        ];

        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*count*/ 1) set_data(t4, /*count*/ ctx[0]);
      if (dirty & /*count2*/ 2) set_data(t6, /*count2*/ ctx[1]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      ...
    }
  };
}

function instance($$self, $$props, $$invalidate) {
  let count = 0;
  let count2 = 0;
  const click_handler = () => $$invalidate(0, count++, count);
  const click_handler_1 = () => $$invalidate(1, count2++, count2);
  return [count, count2, click_handler, click_handler_1];
}

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}

export default App;
```

- 当我们点击按钮1时，执行`click_handler`方法，内部调用`$$invalidate(0, count++, count)`
- `$$invalidate`内部执行`not_equal($$.ctx[i], $$.ctx[i] = value)`，i此时是0，`$$.ctx[0]`是0，执行`$$.ctx[0] = 1`之后，和原来的值不一样，执行`make_dirty`
- 首先是初始`dirty[0]`是-1，先填充为`dirty.fill(0)`，变成`dirty[0]`是0。执行`component.$$.dirty[(i / 31) | 0] |= 1 << i % 31`，`0 % 31`是0，`1<<0`仍是1，`(0 / 31) | 0`得到0，我们需要注意`component.$$.dirty[xxx] |= xxx`中间是一个位或运算。`0 | 1`得到1，最终`component.$$.dirty[0] = 1`。
- 微任务中执行`schedule_update`里的逻辑，调用`fragment.p`方法，此时`[dirty]`数组是`[1]`，`1 && 1`是1，能够执行`set_data(t4, /*count*/ ctx[0])`，`set_data`方法内通过设置`document.createTextNode().data`的值来更新页面的展示。`1 & 2`是0，不执行`set_data(t6, /*count2*/ ctx[1])`。之后`dirty`数组重新变成`[-1]`
```javascript
p(ctx, [dirty]) {
  if (dirty & /*count*/ 1) set_data(t4, /*count*/ ctx[0]);
  if (dirty & /*count2*/ 2) set_data(t6, /*count2*/ ctx[1]);
}
```

- 当点击按钮2时，执行`click_handler`方法，内部调用`$$invalidate(1, count++, count)`
- `$$invalidate`内部执行`not_equal($$.ctx[i], $$.ctx[i] = value)`，i此时是1，`$$.ctx[1]`是1，执行`$$.ctx[1] = 1`之后，和原来的值不一样，执行`make_dirty`
-  依旧是初始`dirty[0]`是-1，先填充为`dirty.fill(0)`，变成`dirty[0]`是0。执行`component.$$.dirty[(i / 31) | 0] |= 1 << i % 31`，`1 % 31`是1，`1<<1`是2，`(1 / 31) | 0`得到0，`0 | 2`得到2，最终`component.$$.dirty[0] = 2`。
- 执行`schedule_update`，调用`fragment.p`方法，此时`[dirty]`数组是`[2]`，`2 && 2`是1，能够执行`set_data(t6, /*count2*/ ctx[1])`，`2 & 1`是0，不执行`set_data(t4, /*count*/ ctx[0])`

## 小结

本章我们学习了：
- `SvelteComponent`的基本功能
- `init`方法的基本功能
- `instance`方法的基本功能，它就是把我们在`<script></script>`中定义的更新数据的方法包裹起来，然后编译成新的更新语句，同时返回一个数组，`ctx`会接收这个数组的值。
- `$$invalidate`的基本逻辑，触发更新操作的关键方法
- `make_dirty`的基本逻辑，里面有位运算的运用
- `create_fragment`的基本功能，里面包含了一个组件的基本生命周期方法
- dom操作的封装
- Svelte文件被编译后，数据更新的大体流程。
---
title: Svelte从入门到精通——基本流程
description: 【实现篇】基本流程
---

我们在源码阶段已经初步了解了Svelte的整体运作流程，从这一章开始，笔者将和读者朋友们一起，自己动手实现一个简化版的Svelte，在实现完后，读者朋友们可以和源码篇一起阅读相辅相成，进一步夯实自己对Svelte的理解。

```bash
npm create vite@latest
```
选择vanilla js，即原生js。

## 目录结构

基本目录结构：
![](/images/svelte/38-1.png)

- app.js：我们最终经过compiler解析后得到的内容。
- main.js：引用app.js并挂载到dom上。
- svelte.js：我们要实现的Svelte的全部逻辑。
- App.svelte：svelte文件内容。
- index.html：浏览器访问页面

`index.html`的内容如下：
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/main.js"></script>
  </body>
</html>
```

现在各个js文件的内容都为空，使用`npm run dev`，只能看到一片空白。

我们的最终目的是实现一个简化版的Svelte，这个Svelte能够解析基本的html标签，能够绑定事件，能够实现ifblock的逻辑。

`main.js`文件内容如下：
```javascript
// main.js
import App from './app';

App().create(document.querySelector('#root'));
```

## 流程

基本流程是：
- svelte.js中读取App.svelte的内容，使用acron解析成ast，将ast转义成浏览器能执行的js，导出到app.js。
- main.js引用app.js并执行。
- index.html引用main.js。

`app.js`导出一个默认方法。
```javascript
// app.js
export default function() {}
```

所有js文件使用esm的导入导出形式。在svelte.js中，我们创建如下代码：
```javascript
// svelte.js
import * as fs from "fs"
import { fileURLToPath } from "url"
import { dirname, resolve } from "path"

const modulePath = dirname(fileURLToPath(import.meta.url))

function bootstrap(){
  try {
    const inputPath = resolve(modulePath, "./App.svelte");
    const outputPath = resolve(modulePath, "./app.js");
    const content = fs.readFileSync(inputPath, "utf-8");
    fs.writeFileSync(outputPath, compile(content), "utf-8")
  } catch (e) {
    console.error(e);
  }
}

function compile(content) {
  return `
    export default function() {}
  `;
}

bootstrap();
```

在esm模块中，我们使用`dirname(fileURLToPath(import.meta.url))`来代替`__dirname`。
首先我们定义了文件输入路径`inputPut`和`outputPath`，从`inputPath`中读取文件内容（很明显，我们是读取App.svelte的内容），经过`compile(content)`后，把编译后的内容重新写到app.js中。

在package.json中添加命令`"compile": "node svelte.js"`
```json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "compile": "node svelte.js"
  },
}
```

我们先在compile方法中写个假的返回值测试下，根据main.js中的引用，很明显我们的方法需要返回一个对象，这个对象里有个create方法，用于最初的dom挂载。因此：
```javascript
function compile(content) {
  return `
    export default function() {
      return {
        create(target) {
          const div = document.createElement('div');
          div.textContent = 'hello svelte';
          target.appendChild(div);
        }
      }
    }
  `;
}
```

现在我们执行`npm run compile`。如果你在`npm run dev`后一直没有关闭，那打开`localhost:5173`看看，希望你能看到如下：
![](/images/svelte/38-2.png)

我们的最终目的是，能把App.svelte的内容转成能够在浏览器上正常运行的js代码。

## 运行时方法

在阅读源码时，我们了解到Svelte代码中涉及了大量的dom操作，然而原生的操作dom的api过于冗长，Svelte对它们进行了简单的封装。这里我们也做同样的处理。

### compile
修改我们的compile方法。
```javascript
function compile(content) {
  return `
    function element(name) {
      return document.createElement(name);
    }

    function text(data) {
      return document.createTextNode(data);
    }

    function append(target, node) {
      target.appendChild(node);
    }

    function detach(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }

    export function listen(node, event, handler) {
      node.addEventListener(event, handler);
      return () => node.removeEventListener(event, handler);
    }
    
    export default function() {
      return {
        create(target) {
          const div = document.createElement('div');
          div.textContent = 'hello svelte';
          target.appendChild(div);
        }
      }
    }
  `;
}
```
我们封装了`createElement`,`createText`, `appendChild`,`removeChild`,`addEventListener`和`removeEventListener`。

## 编译时方法

我们刚刚把编译后的代码写在了compile方法里，现在我们对其进行改造。

```javascript
function compile(content) {
  const ast = parse(content); // 解析svelte文件内容成ast
  return generate(ast);
}

function parse(content) {
  const ast = {};
  return ast;
}

function generate(ast) {
  return `
    ···
    export default function() {}
  `;
}
```

然后把一大串字符串模板内容放到generate方法中。现在，compile方法的主要逻辑是：通过`parse(content)`解析出ast，然后通过ast数据`generate`出字符串模板内容。

### parse
在parse方法中，我们定义一些基础方法，后续的解析会用到这些方法。

```javascript
function parse(content) {
  let i = 0;
  const ast = {};
  return ast;

  function match(str) {
    return content.slice(i, i + str.length) === str;
  }

  function eat(str) {
    if (match(str)) {
      i += str.length;
    } else {
      throw new Error(`Parse error: expecting "${str}"`);
    }
  }

  function readWhileMatching(reg) {
    let startIndex = i;
    while(i < content.length && reg.test(content[i])) {
      i++;
    }
    return content.slice(startIndex, i);
  }

  function skipWhitespace() {
    readWhileMatching(/[\s\n]/);
  }
}
```

- match(str)：接下来要解析的字符串是否等于str
- eat(str)：如果匹配str成功，i索引更新
- readWhileMatching(reg)：读取匹配reg格式的内容直到不匹配为止，同时i索引更新，返回读取成功的内容
- skipWhitespace：跳过空格

在下一章中，我们将继续实现parse和generate的内容。

## 小结

本章我们实现了：
- 框架的整体运行流程
- 辅助函数---
title: Svelte从入门到精通——解析script
description: 【实现篇】解析script
---

我们继续完善上一章中的parse方法。我们从App.svelte读取到字符串内容后，传递进了compile方法中，继而传进到parse方法中。在parse方法内，我们定义一个parseFragments方法，将解析出的字符串内容分类存储。

## parseFragments

首先设置一个索引`i`，从0开始，这个索引指向文件字符串内容的第i位。
同时定义了一个变量`ast`，最终我们的parse方法会返回这个ast对象。
```javascript
function parse(content) {
  let i = 0;
  const ast = {};
  parseFragments();
  return ast;

  ...
}
```

parseFragments的内容如下：
```javascript
function parseFragments() {
	while (i < content.length) { // 因为i是从0开始的，所以使用<比较即可
	  parseFragment();
	}
}

function parseFragment() {
    parseScript();
}
```

parseFragments内部是一个while循环，表示从文件内容的开始执行到结束。内部的parseFragment方法包含了i索引的变更。

本章笔者将率先讲解的是解析script，所以parseFragment内部只有一个parseScript方法。

### parseScript
#### acorn
前面的章节中，我们已经了解了acorn的作用，它能将合理的字符串解析成ast对象。
引入acorn：
```bash
npm install acorn -D
```

```javascript
// svelte.js
import * as fs from "fs";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";
import * as acorn from "acorn";

...
```

parseScript内容如下：
```javascript
// svelte.js
  function parseScript() {
    skipWhitespace();
    if (match("<script>")) {
      eat("<script>");
      const startIndex = i;
      const endIndex = content.indexOf("</script>", i);
      const code = content.slice(startIndex, endIndex);
      ast.script = acorn.parse(code, { ecmaVersion: 2023 });
      i = endIndex;
      eat("</script>");
      skipWhitespace();
    }
  }
```

主要逻辑是解析`<script></script>`内的内容，使用acorn对读取到的字符串内容进行解析，然后把解析出来的script内容存到ast.script变量中。

#### escodegen

为了将ast转换成正常的代码，我们需要引入escodegen：
```bash
npm install escodegen -D
```

```javascript
// svelte.js
import * as fs from "fs";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";
import * as acorn from "acorn";
import * as escodegen from "escodegen";

...
```

将ast.script变量的内容重新生成出来。在generate方法返回的模板字符串中，调用`escodegen.generate`：
```javascript
function generate(ast) {
  return `
    ...
    
    export default function() {
      ${escodegen.generate(ast.script)}
      return {
        create(target) {
          ...
        }
      }
    }
  `;
}
```

现在让我们在App.svelte中添加一个script标签，在里面定义一些内容，然后`npm run compile`解析一下吧。
```html
<script>
  let msg = '解析script';
</script>
```

相信你能看到在app.js中有以下内容
```javascript
export default function() {
  let msg = '解析script';
  return {
	create(target) {
	  const div = document.createElement('div');
	  div.textContent = 'hello svelte';
	  target.appendChild(div);
	}
  }
}
```
如果读者们想试验一下，甚至能够把我们在上一节在create方法中的内容做一个更改，
```diff
create(target) {
    const div = document.createElement('div');
-   div.textContent = 'hello svelte'
+   div.textContent = msg;
    target.appendChild(div);
}
```

重新`npm run compile`后便能得到：
```javascript
export default function() {
  let msg = '解析script';
  return {
	create(target) {
	  const div = document.createElement('div');
	  div.textContent = msg;
	  target.appendChild(div);
	}
  }
}
```
访问localhost:5173
![](/images/svelte/39-1.png)

## 完整代码

最后，为了防止读者们在跟着步骤来实现时出现代码混淆的情况，在每一章结束后，笔者都会把本章实现后的svelte.js的内容呈现出来，读者可一一比对实现。

```javascript
import * as fs from "fs";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";
import * as acorn from "acorn";
import * as escodegen from "escodegen";

const modulePath = dirname(fileURLToPath(import.meta.url));

function bootstrap() {
  try {
    const inputPath = resolve(modulePath, "./App.svelte");
    const outputPath = resolve(modulePath, "./app.js");
    const content = fs.readFileSync(inputPath, "utf-8");
    fs.writeFileSync(outputPath, compile(content), "utf-8");
  } catch (e) {
    console.error(e);
  }
}

function compile(content) {
  const ast = parse(content); // 解析svelte文件内容成ast
  return generate(ast);
}

function parse(content) {
  let i = 0;
  const ast = {};
  parseFragments();
  return ast;

  function parseFragments() {
    while (i < content.length) {
      parseFragment();
    }
  }

  function parseFragment() {
    parseScript();
  }

  function parseScript() {
    skipWhitespace();
    if (match("<script>")) {
      eat("<script>");
      const startIndex = i;
      const endIndex = content.indexOf("</script>", i);
      const code = content.slice(startIndex, endIndex);
      ast.script = acorn.parse(code, { ecmaVersion: 2023 });
      i = endIndex;
      eat("</script>");
      skipWhitespace();
    }
  }

  function match(str) {
    return content.slice(i, i + str.length) === str;
  }

  function eat(str) {
    if (match(str)) {
      i += str.length;
    } else {
      throw new Error(`Parse error: expecting "${str}"`);
    }
  }

  function readWhileMatching(reg) {
    let startIndex = i;
    while(i < content.length && reg.test(content[i])) {
      i++;
    }
    return content.slice(startIndex, i);
  }

  function skipWhitespace() {
    readWhileMatching(/[\s\n]/);
  }
}

function generate(ast) {
  return `
    function element(name) {
      return document.createElement(name);
    }

    function text(data) {
      return document.createTextNode(data);
    }

    function append(target, node) {
      target.appendChild(node);
    }

    function detach(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }

    export function listen(node, event, handler) {
      node.addEventListener(event, handler);
      return () => node.removeEventListener(event, handler);
    }
    
    export default function() {
      ${escodegen.generate(ast.script)}
      return {
        create(target) {
          const div = document.createElement('div');
          div.textContent = msg;
          target.appendChild(div);
        }
      }
    }
  `;
}

bootstrap();
```

## 小结

本章我们实现了：
- 对`<script>...</script>`标签内容的解析
- 对解析的script内容重新编译生成
---
title: Svelte从入门到精通——解析html
description: 【实现篇】解析html
---

在上一章中，我们完成了script的解析，其主要逻辑都集中在parseScript中

## 标签
### 解析标签

在parseFragment方法内，添加parseElement的解析逻辑：
```javascript
function parseFragment() {
    return parseScript() ?? parseElement();
}
```
`??`是一个空值合并运算符，当前面的值为null或undefined时，会执行后面的逻辑。parseScript的方法没有返回值，因此当执行完parseScript后，会执行parseElement。

parseElement的逻辑如下：
```javascript
function parseElement() {
	skipWhitespace();
	if (match('<')) {
	  eat('<');
	  const tagName = readWhileMatching(/[a-z]/);
	  eat('>');
	  const endTag = `</${tagName}>`;
	  const element = {
		type: 'Element',
		name: tagName,
		attributes: [],
		children: [],
	  };
	  eat(endTag);
	  skipWhitespace();
	  return element;
	}
}
```
主要逻辑是，遇到`<`开头的标签后，读取接下来的标签名称，然后返回一个fragment对象。

我们将从html字符串中解析得到的内容称为fragment，随着解析内容的深入，我们可能会遇到不同类型的fragment。在parseElement方法中，解析得到的fragment的类型是`type: 'Element'`。除了type之外，name存储读取到的标签名，attributes存储标签上的属性，children存储标签内的子标签对象。

因为我们parseElement中有返回一个对象，我们需要调整我们的parseFragments方法：
```javascript
function parseFragments() {
    const fragments = [];
    while (i < content.length) {
      const fragment = parseFragment();
      if (fragment) {
        fragments.push(fragment);
      }
    }
    return fragments;
}
```

将parseFragments()返回值赋给ast.html：
```javascript
function parse(content) {
  let i = 0;
  const ast = {};
  ast.html = parseFragments();
  return ast;

  ...
}
```
现在我们的ast对象上不止有script属性，也有html属性。

### 生成标签

接着我们开始完善generate的方法
```javascript
function generate(ast) {
  const code = {
    variables: [],
    create: [],
    destroy: [],
  };
  
  let counter = 1;

  function traverse(node, parent) {
    switch(node.type) {
      case 'Element': {
        const variableName = `${node.name}_${counter++}`;
        code.variables.push(variableName);        
        code.create.push(
          `${variableName} = element('${node.name}')`
        );
        code.create.push(`append(${parent}, ${variableName})`);
        code.destroy.push(`detach(${variableName})`);        
        break;
      }
    }
  }

  ast.html.forEach((fragment) => traverse(fragment, 'target'));

  return `
    ...
    
    export default function() {
	    ...
    }
  `;
}
```

我们定义一个变量code，里面用来收集在解析过程中的各种用于转换的参数。其中，create用来存储组件创建时的数据，destroy用来存储组件销毁时的数据。variables数组用来存储在编译时用来声明的变量。

ast.html中存储的是一个数组，`ast.html.forEach`遍历这个数组，然后对数组里的内容作`traverse`转换。
因为目前我们只解析了标签，数组里只有`type: Element`的数据，所以我们先只处理标签的转换。

仔细看转换的代码：
```javascript
case 'Element': {
	const variableName = `${node.name}_${counter++}`;
	code.variables.push(variableName);        
	code.create.push(
	  `${variableName} = element('${node.name}')`
	);
	code.create.push(`append(${parent}, ${variableName})`);
	code.destroy.push(`detach(${variableName})`);        
	break;
}
```
node.name是标签名，counter是一个自增变量，用来区分不同的变量。不如我们可能会解析出很多div标签，第一个div是div1，然后counter加1，下一个div标签则是div2，确保相同标签的解析变量不会重名。然后我们把这个变量存入到`code.variables`中。

在`code.create`中，我们添加创建标签的代码，在`code.destroy`中，我们添加移除标签的代码。还记得我们在基本流程章节中定义的运行时方法吗，这里便派上了用场：element、append、detach。

经过转换后，我们的create和destroy中已经存储了组件在创建时如何运行和销毁时如何运行的js代码。

现在我们重构字符串模板中的导出内容。
```javascript
function generate(ast) {
	...
	return `
		export default function() {
		${code.variables.map(v => `let ${v};`).join('\n')}
		
		${escodegen.generate(ast.script)}

			var lifecycle = {
        create(target) {
          ${code.create.join('\n')}
        },
        destroy(target) {
          ${code.destroy.join('\n')}
        }
			};
		    return lifecycle;
	    }	
    `
}
```
在方法最开头，把`code.variables`中的变量全都使用`let ${v}`打印出来，然后在lifecycle的create中调用`code.create`，在destroy中调用`code.destroy`。

## 纯文本

### 解析纯文本

解析完Element之后，我们开始解析纯文本Text：
```javascript
function parseFragment() {
  return parseScript() ?? parseElement() ?? parseText();
}
```

解析得到的对象，我们将其类型定义为`type: 'Text'`：
```javascript
function parseText() {
  const text = readWhileMatching(/[^<{]/);
  if (text.trim() !== '') {
    return {
      type: 'Text',
      value: text.trim(),
    }
  }
}
```

### 生成纯文本
完善generate里的traverse方法，添加对Text类型的转换：
```javascript
function traverse(node, parent) {
  switch(node.type) {
    case 'Element': {
      ...
    }
    case 'Text': {
      const variableName = `txt_${counter++}`;
      code.variables.push(variableName);
      code.create.push(`${variableName} = text('${node.value}');`);
      code.create.push(`append(${parent}, ${variableName})`);
      code.destroy.push(`detach(${variableName})`);
      break;
    }
  }
}
```
同样是在create时存入创建文本内容的逻辑，在destroy时存入销毁文本内容的逻辑。

在App.svelte中添加测试内容：
```html
<script>
  let msg = '解析文本';
</script>

文本内容1
<div></div>
文本内容2
```
看看`npm run compile`后的结果吧。
![](/images/svelte/40-1.png)
现在如果我们往div标签里添加内容，编译往往会报错。因为还没有实现递归解析html内容的逻辑。这也是为什么笔者在这里只演示了最基本的html标签的写法。

## 标签属性
### 解析标签属性

修改parseElement的内容：
```diff
function parseElement() {
  skipWhitespace();
  if (match('<')) {
    eat('<');
    const tagName = readWhileMatching(/[a-z]/);
+   const attributes = parseAttributes();
    eat('>');
    const endTag = `</${tagName}>`;
    const element = {
      type: 'Element',
      name: tagName,
-     attributes: [],
+     attributes,
      children: [],
    };
    eat(endTag);
    skipWhitespace();
    return element;
  }
}
```
在一开始，我们把attributes设置成了空数组，现在我们通过parseAttributes来解析出这部分内容。

```javascript
function parseAttributes() {
  skipWhitespace();
  const attributes = [];
  while(!match('>')) {
    attributes.push(parseAttribute());
    skipWhitespace();
  }
  return attributes;
}

function parseAttribute() {
  const name = readWhileMatching(/[^=]/);
  if (match('={')) {
    eat('={');
    const value = parseJavaScript();
    eat('}');
    return {
      type: 'Attribute',
      name,
      value,
    };
  }
}
```
parseAttributes的主要逻辑是解析从`<`到`>`之间的内容，其内部调用parseAttribute方法；
而parseAttribute则解析`key={value}`格式的内容，之后返回`type: Attribute`的对象。因此parseAttributes返回的是`type: Attribute`对象数组。
目前我们只实现诸如`on:click={onClick}`形式的内容。

### 解析行内表达式
```javascript
function parseJavaScript() {
  const js = acorn.parseExpressionAt(content, i, { ecmaVersion: 2023 });
  i = js.end;
  return js;
}
```
这里同样使用acron提供的能力。
### 生成标签属性
完善generate里的traverse方法：
```javascript
function traverse(node, parent) {
  switch(node.type) {
    case 'Element': {
      ...
      node.attributes.forEach(attribute => {
        traverse(attribute, variableName);
      });
    }
    case "Attribute": {
      if (node.name.startsWith("on:")) {
        const eventName = node.name.slice(3);
        const eventHandler = node.value.name;
        const eventNameCall = `${eventName}_${counter++}`;
        code.variables.push(eventNameCall);
        code.create.push(
          `${eventNameCall} = listen(${parent}, "${eventName}", ${eventHandler})`
        );
        code.destroy.push(`${eventNameCall}()`);
      }
      break;
    }
  }
}
```

判断属性是不是`on:`开头，是才处理。因为我们对addEventListener做了封装，当我们执行listen()方法后，会返回一个用于移除事件监听的方法。我们在destroy阶段调用这个方法。

修改App.svelte的内容：
```html
<script>
  let count = 0;
  const updateCount = () => {
    count++;
    console.log('update count', count);
  }
</script>

文本内容1
<button on:click={updateCount}></button>
文本内容2
```
因为现在仍不支持标签内添加元素，因此，我们单独在index.html内给button添加样式，方便我们测试
```html
<!-- index.html -->
<style>
button {
  width: 100px;
  height:100px;
  background: orange;
}
</style>
```

执行`npm run compile`看一下效果吧。
![](/images/svelte/40-2.gif)

## 完整代码
按照惯例，本章最后附上代码：
```javascript
import * as fs from "fs";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";
import * as acorn from "acorn";
import * as escodegen from "escodegen";

const modulePath = dirname(fileURLToPath(import.meta.url));

function bootstrap() {
  try {
    const inputPath = resolve(modulePath, "./App.svelte");
    const outputPath = resolve(modulePath, "./app.js");
    const content = fs.readFileSync(inputPath, "utf-8");
    fs.writeFileSync(outputPath, compile(content), "utf-8");
  } catch (e) {
    console.error(e);
  }
}

function compile(content) {
  const ast = parse(content); // 解析svelte文件内容成ast
  return generate(ast);
}

function parse(content) {
  let i = 0;
  const ast = {};
  ast.html = parseFragments();
  
  return ast;

  function parseFragments() {
    const fragments = [];
    while (i < content.length) {
      const fragment = parseFragment();
      if (fragment) {
        fragments.push(fragment);
      }
    }
    return fragments;
  }

  function parseFragment() {
    return parseScript() ?? parseElement() ?? parseText();
  }

  function parseScript() {
    skipWhitespace();
    if (match("<script>")) {
      eat("<script>");
      const startIndex = i;
      const endIndex = content.indexOf("</script>", i);
      const code = content.slice(startIndex, endIndex);
      ast.script = acorn.parse(code, { ecmaVersion: 2023 });
      i = endIndex;
      eat("</script>");
      skipWhitespace();
    }
  }

  function parseElement() {
    skipWhitespace();
    if (match('<')) {
      eat('<');
      const tagName = readWhileMatching(/[a-z]/);
      const attributes = parseAttributes();
      eat('>');
      const endTag = `</${tagName}>`;
      const element = {
        type: 'Element',
        name: tagName,
        attributes,
        children: [],
      };
      eat(endTag);
      skipWhitespace();
      return element;
    }
  }

  function parseAttributes() {
    skipWhitespace();
    const attributes = [];
    while(!match('>')) {
      attributes.push(parseAttribute());
      skipWhitespace();
    }
    return attributes;
  }

  function parseAttribute() {
    const name = readWhileMatching(/[^=]/);
    if (match('={')) {
      eat('={');
      const value = parseJavaScript();
      eat('}');
      return {
        type: 'Attribute',
        name,
        value,
      };
    }
  }

  function parseJavaScript() {
    const js = acorn.parseExpressionAt(content, i, { ecmaVersion: 2023 });
    i = js.end;
    return js;
  }

  function parseText() {
    const text = readWhileMatching(/[^<{]/);
    if (text.trim() !== '') {
      return {
        type: 'Text',
        value: text.trim(),
      }
    }
  }

  function match(str) {
    return content.slice(i, i + str.length) === str;
  }

  function eat(str) {
    if (match(str)) {
      i += str.length;
    } else {
      throw new Error(`Parse error: expecting "${str}"`);
    }
  }

  function readWhileMatching(reg) {
    let startIndex = i;
    while(i < content.length && reg.test(content[i])) {
      i++;
    }
    return content.slice(startIndex, i);
  }

  function skipWhitespace() {
    readWhileMatching(/[\s\n]/);
  }
}

function generate(ast) {

  const code = {
    variables: [],
    create: [],
    destroy: [],
  };

  let counter = 1;

  function traverse(node, parent) {
    switch(node.type) {
      case 'Element': {
        const variableName = `${node.name}_${counter++}`;
        code.variables.push(variableName);
        code.create.push(
          `${variableName} = element('${node.name}')`
        )
        node.attributes.forEach(attribute => {
          traverse(attribute, variableName);
        });

        code.create.push(`append(${parent}, ${variableName})`);
        code.destroy.push(`detach(${variableName})`);
        break;
      }
      case 'Text': {
        const variableName = `txt_${counter++}`;
        code.variables.push(variableName);
        code.create.push(`${variableName} = text('${node.value}');`);
        code.create.push(`append(${parent}, ${variableName})`);
        code.destroy.push(`detach(${variableName})`);
        break;
      }
      case "Attribute": {
        if (node.name.startsWith("on:")) {
          const eventName = node.name.slice(3);
          const eventHandler = node.value.name;
          const eventNameCall = `${eventName}_${counter++}`;
          code.variables.push(eventNameCall);
          code.create.push(
            `${eventNameCall} = listen(${parent}, "${eventName}", ${eventHandler})`
          );
          code.destroy.push(`${eventNameCall}()`);
        }
        break;
      }
    }
  }

  ast.html.forEach((fragment) => traverse(fragment, 'target'));

  return `
    function element(name) {
      return document.createElement(name);
    }

    function text(data) {
      return document.createTextNode(data);
    }

    function append(target, node) {
      target.appendChild(node);
    }

    function detach(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }

    export function listen(node, event, handler) {
      node.addEventListener(event, handler);
      return () => node.removeEventListener(event, handler);
    }
    
    export default function() {
      ${code.variables.map(v => `let ${v};`).join('\n')}

      ${escodegen.generate(ast.script)}

      var lifecycle = {
        create(target) {
          ${code.create.join('\n')}
        },
        destroy(target) {
          ${code.destroy.join('\n')}
        }
      };
      return lifecycle;
    }
  `;
}

bootstrap();
```


## 小结

本章我们实现了：
- 解析正常的html标签
- 解析纯文本
- 解析标签上的属性，解析行内表达式，完成对标签进行事件绑定的功能---
title: Svelte从入门到精通——function
description: 【对比篇】function
---

有了数据，那必然要有更新数据的方法，以及平时在业务上为了服务数据更新而派生出来的一堆处理数据或者操作页面的方法，那么方法在各个UI库中应该如何定义呢？

## React
在React中，为元素标签绑定方法使用`on[事件]`的驼峰命名形式，比如点击事件`onClick`，提交事件`onSubmit`等。  

### function component

上一节我们讲解了`useState()`返回的参数的含义，返回数组中第一个参数表示存储值的变量，第二个参数则用于更新数据。
```javascript
import { useState } from "react";

export default function Page() {
  const [count, setCount] = useState(0);

  const updateCount = () => {
    setCount(count + 1);
  };

  return (
    <div>
      count: {count}
      <button onClick={updateCount}>+1</button>
    </div>
  );
}
```

### class component

在`class component`中，我们沿用上一节的例子：

```javascript
import React from 'react';

export default class Page extends React.Component {
  constructor() {
    super();
    this.state = {
      count: 0
    }
  }
  updateCount() {
    this.setState({
      count: this.state.count + 1
    })
  }
  render() {
    const { count } = this.state;
    return (
      <div>
        count: {count}
        <button onClick={() => this.updateCount()}>+1</button>
      </div>
    )
  }
}
```

可以发现，如果我们使用`class component`，代码量比`function component`多了不少。

#### this
在`class component`中，我们还需要时刻关注this的指向和组件内的生命周期。拿上述的代码来说，如果我们把`onClick={() => this.updateCount()}`改成`onClick={this.updateCount}`，那你在控制台便能看到`Uncaught TypeError: Cannot read properties of undefined (reading 'setState')`这种报错。当然造成这种现象的最根本原因是javascript的`this`指向问题。

而要解决这种问题，有几种方式。

方式一：在constructor中进行bind绑定
```diff
export default class Page extends React.Component {
  constructor() {
    super();
    this.state = {
      count: 0
    }
+   this.updateCount = this.updateCount.bind(this);
  }
  updateCount() {
    this.setState({
      count: this.state.count + 1
    })
  }
  render() {
    const { count } = this.state;
    return (
      <div>
        count: {count}
        <button onClick={this.updateCount}>+1</button>
      </div>
    )
  }
}
```

方式二：像最开始的例子中，onClick中使用箭头函数二次调用
```diff
+  <button onClick={() => this.updateCount()}>+1</button>
```

方式三：在声明方法时就使用箭头函数
```diff
+ updateCount = () => {
    this.setState({
      count: this.state.count + 1
    })
  }
```
之所以举了这么多例子，就是想说明一件事，在React的`class component`中使用方法有一定的心智负担。

### Event

如果我们要使用事件中的event参数
```javascript
export default function Page() {
  const handleClick = (event) => {
    console.log(event);
  }
  const handleClick2 = (event, param) => {
    console.log(event);
  }
  return <div>
    <button onClick={handleClick}>click1</button>
    <button onClick={e => handleClick2(e, 'hello')}>click2</button>
  </div>
}
```

## Vue

在Vue中，为元素标签添加事件使用`@[事件]`或`v-on:[事件]`，带`@`符号的事件绑定是对`v-on`形式的缩写。

### 3.x
```html
<template>
  <div>
    count: {{count}}
    <button @click="updateCount">+1</button>
    <button v-on:click="updateCount">+1</button>
  </div>
</template>

<script setup>
  import { ref } from 'vue';

  const count = ref(0);

  const updateCount = () => {
    count.value++;
  }
</script>
```
我们这里可以先对比下vue和react的事件绑定方式的不同，拿click方法来说，vue使用的是`@click="func"`的形式，而React则是`onClick={func}`的形式。

### 2.x
在Vue 2.x中，事件的绑定方式不变，事件的声明则在options api的methods选项中。
```html
<template>
  <div>
    <button @click="updateCount">update count</button>
    count:{{ count }}
  </div>
</template>

<script>
export default {
  data() {
    return {
      count: 0,
    };
  },
  methods: {
    updateCount() {
      this.count++;
    },
  },
};
</script>
```

### Event
```html
<template>
  <div>
    <button @click="handleClick">click1</button>
    <button @click="handleClick2($event, 'hello')">click2</button>
  </div>
</template>

<script>
export default {
  methods: {
    handleClick(event) {
      console.log(event);
    },
    handleClick2(event, param) {
      console.log(event);
    },
  },
};
</script>
```

### 事件修饰符
在事件处理程序中调用`event.preventDefault()`或`event.stopPropagation()`是非常常见的需求。Vue提供了一些事件修饰符，我们可以通过他们来优化业务代码，减少关心DOM事件细节。事件修复符之间可以链式调用，但要注意调用的顺序。
```html
<a v-on:click.stop.prevent="func"></a>
```

## Svelte

在Svelte中，添加事件绑定的方式通过`on:[事件]`的方式。
```html
<script>
  let count = 0;

  const updateCount = () => {
    count++;
  }
</script>


<div>
  count: {count}
  <button on:click={updateCount}>+1</button>
</div>
```
而且我们不用考虑方法this的指向，也无需通过`this`来获取变量。Svelte仍旧比其他两大框架在写法上更为简洁。

### Event
```html
<script>
  const handleClick = (event) => {
    console.log(event)
  }
  const handleClick2 = (event, param) => {
    console.log(event);
  }
</script>

<button on:click={handleClick}>click1</button>
<button on:click={(e) => handleClick2(e, 'hello')}>click2</button>
```

### 事件修饰符

同样Svelte也提供了一些事件修饰符，修饰符也可以链式调用，和Vue不同的是，Svelte的事件修饰符使用`|`来引用。
```html
<a v-on:click|stop|prevent="func"></a>
```

## 小结

本章我们对比了：
- React中使用`on[事件]`的驼峰形式绑定事件、Vue使用`@[事件]`或`v-on:[事件]`的形式绑定事件、Svele使用`on:[事件]`的形式绑定事件
- React的`function component`中使用`useState`hooks时，返回值的第二个参数用于更新数据；`class component`中使用`this.setState`更新数据
- React进行事件绑定时需要注意this的指向
- Vue`2.x`中事件需要定义在`methods`中
- Svelte的事件除了要求写在script内无其他额外要求
- 三大框架绑定事件后的event对象的获取
---
title: Svelte从入门到精通——if
description: 【对比篇】if
---

## React

### if-else
在React中，条件判断在`{}`中执行，通过三元表达式的判断来显示内容。
```javascript
{boolean ? 真值内容 : 假值内容}
```

```javascript
import { useState } from 'react';

export default function Page() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>add</button>
      {count === 0 ? <span>没值</span> : <h2>有值了！{count}</h2>}
    </div>
  )
}
```

![](/images/svelte/28-1.gif)

### `&&`
除了三元表达式`? :` 外，还能使用二院表达式`&&`来判断。
```javascript
boolean && 显示内容
```

修改上面的例子：
```javascript
import { useState } from 'react';

export default function Page() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>add</button>
      {count > 0 && <h2>有值了！{count}</h2>}
    </div>
  )
}
```
这种方式适用需要页面隐藏的情况。

### 引用

因为React使用的是jsx语法，非常灵活，即使我们无法在`{}`内用ifelse或switch来判断显示，我们仍有一些委婉的方式来实现。

```javascript
import { useEffect, useState } from 'react';

export default function Page() {
  const [count, setCount] = useState(0);
  const [component, setComponent] = useState();

  useEffect(() => {
    if (count > 0) {
      setComponent(<h2>有值了！{count}</h2>)
    } else {
      setComponent(<span>没值</span>)
    }
  }, [
    count
  ])

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>add</button>
      {component}
    </div>
  )
}
```
通过把组件内容设置成一个变量的形式来引用。

## Vue

### if-else

在Vue中，通过 `v-if`、`v-else-if`、`v-else`来判断内容的展示。
```html
<template>
  <section>
    <button @click="updateCount">add</button> count: {{ count }}
    <div v-if="count >= 0 && count < 2">及格</div>
    <div v-else-if="count >= 2 && count < 4">良好</div>
    <div v-else>优秀</div>
  </section>
</template>

<script>
export default {
  data() {
    return {
      count: 0,
    };
  },
  methods: {
    updateCount() {
      this.count++;
    },
  },
};
</script>
```

![](/images/svelte/28-2.gif)

`v-if`能单独使用，单独使用使用有隐藏内容的情况。需要注意当使用`v-else-if`和`v-else`时，需要前置有`v-if`内容，单独使用其中一个都会报错。

### v-show

在Vue中，除了提供`v-if`来控制内容的显示隐藏，使用`v-show`同样能控制元素的显示隐藏。
```html
<template>
  <section>
    <input type="checkbox" v-model="checked" />
    <div v-show="checked">显示！！！</div>
  </section>
</template>

<script>
export default {
  data() {
    return {
      checked: false,
    };
  },
};
</script>
```

![](/images/svelte/28-3.gif)

二者的区别在于： `v-if`指令，是根据表达式值的真假来销毁或者重建一个我们绑定的DOM元素；而`v-show`指令利用元素的display属性控制着元素的显示隐藏，不管初始条件是什么，元素总是会被渲染。

## Svelte

### if-else

在Svelte中，通过 `{#if}{:else if}{:else}{/if}`来判断内容的展示。
```html
<script>
  let count = 0;

  const updateCount = () => {
    count++;
  };
</script>

<button on:click={updateCount}>Add</button>
{count}
{#if count >= 0 && count < 2}
  <div>及格</div>
{:else if count >= 2 && count < 4}
  <div>良好</div>
{:else}
  <div>优秀</div>
{/if}
```
`{:else if}`和`{:else}`是可选的。

## 小结

本章我们对比了：
- React在`{}`中使用三元表达式`? :`或二元表达式`&&`来实现内容切换。
- Vue通过`v-if`、`v-else-if`、`v-else`和`v-show`来判断内容的展示。
- Svelte通过 `{#if}{:else if}{:else}{/if}`来判断内容的展示。
---
title: Svelte从入门到精通——for
description: 【对比篇】for
---

## React

在React中，我们可以灵活地操作数组类型的数据，如果要把数组数据以列表的形式展示到页面上，jsx允许我们正常地使用数组支持的方法，比如map、forEach等。  

在`function component`的`return`中或者`class component`的`render`方法的`return`中，我们通常直接使用map来返回列表：
```javascript
function FunctionComponent() {
  return (
    list.map((item, index) => {
      return 内容;
    })
  )
}

class ClassComponent extends React.Component {
  render() {
    return (
      list.map((item, index) => {
        return 内容;
      })
    )
  }
}
```

```javascript
import { useState } from "react";

export default function Page() {
  const [list] = useState([1, 2, 3]);

  return (
    <ul>
      {list.map((item, index) => {
        return <li key={index}>item - {item}</li>;
      })}
    </ul>
  );
}
```
React的循环列表项中，要求我们需要为每一项添加一个key值。

如果我们想使用forEach呢？以上面一个例子为例：
```javascript
import { useEffect, useState } from "react";

export default function Page() {
  const [list] = useState([1, 2, 3]);
  const [items, setItems] = useState([]);

  useEffect(() => {
    const newLists = [];
    list.forEach((item,index) => {
      newLists.push(<li key={index}>item - {item}</li>)
    });
    setItems(newLists);
  }, [list])

  return (
    <ul>
      {items}
    </ul>
  );
}
```
使用forEach，我们能够在数组循环时做一些复杂的逻辑。

#### key
React[官网](https://legacy.reactjs.org/docs/lists-and-keys.html)中详细地阐释了key在循环中的作用。我们直接演示例子：
```javascript
import { useState } from "react";

function Item(props) {
  return (
    <div className="flex mb-4">
      <label>{props.name}</label>
      <div>
        <input type="text" className="border" />
      </div>
    </div>
  );
}

export default function Page() {
  const [list, setList] = useState([
    { name: "Foo", id: 1 },
    { name: "Bar", id: 2 },
  ]);

  const addItem = () => {
    const id = +new Date();

    setList([{ name: "Random" + id, id }, ...list]);
  };

  return (
    <div className="text-black">
      <button className="border p-2" onClick={addItem}>add item</button>
      <h3>
        Dangerous <code>key=index</code>
      </h3>
      <form>
        {list.map((todo, index) => (
          <Item {...todo} key={index} />
        ))}
      </form>
      <h3>
        Better <code>key=id</code>
      </h3>
      <form>
        {list.map((todo) => (
          <Item {...todo} key={todo.id} />
        ))}
      </form>
    </div>
  );
}
```
![](/images/svelte/29-1.gif)
我们可以看到，我们在两个不同的列表中，同样是在Foo输入框中输入值，但使用index作为key的输入框，在添加了新的输入框后，表现异常，原来在Foo输入框的值，一直存在在第一个输入框中，而使用id作为key的输入框则表现正常。

key可以帮助React识别出哪些元素改变了，比如被添加或删除。如果列表项目的顺序可能会变化，不建议使用索引来用作key值，因为这样做会导致性能变差，还可能引起组件状态的问题。这种异常表现在Vue和Svelte中都存在。

## Vue

```html
<template>
  <ul>
    <li v-for="(item, index) in list" :key="index">item - {{ item }}</li>
  </ul>
</template>

<script setup>
import { reactive } from "vue";

const list = reactive([1, 2, 3]);
</script>

```
在Vue中，使用`v-for`来进行数组循环，同样要求在循环项中绑定key，以`:key=""`的形式。

#### key
同样以上面的例子来展示：
```html
<!-- Child.vue -->
<template>
  <div class="flex mb-4">
    <label>{{ name }}</label>
    <div>
      <input type="text" class="border" />
    </div>
  </div>
</template>

<script>
export default {
  props: {
    name,
  },
};
</script>
```

```html
<template>
  <div class="text-black">
    <button class="border p-2" @click="addItem">add item</button>
    <h3>Dangerous <code>key=index</code></h3>
    <form>
      <Item v-for="(todo, index) in list" :name="todo.name" :key="index" />
    </form>
    <h3>Better <code>key=id</code></h3>
    <form>
      <Item v-for="(todo, index) in list" :name="todo.name" :key="todo.id" />
    </form>
  </div>
</template>

<script>
import Item from "./Child.vue";

export default {
  data() {
    return {
      list: [
        { name: "Foo", id: 1 },
        { name: "Bar", id: 2 },
      ],
    };
  },
  methods: {
    addItem() {
      const id = +new Date();
      this.list = [{ name: "Random" + id, id }, ...this.list];
    },
  },
  components: {
    Item,
  },
};
</script>
```
## Svelte

```html
<script>
  const list = [1,2,3];
</script>

<ul>
  {#each list as item, index (key)}
    <li>item - {item}</li>
  {/each}
</ul>
```
在Svelte中，循环的功能放在`{#each}{/each}`中，key是可选的。

#### key
同样以相同的例子举例：
```html
<script>
// Child.svelte
  export let name;
</script>

<div class="flex mb-4">
  <label>{name}</label>
  <div>
    <input type="text" class="border" />
  </div>
</div>
```

```html
<script>
  import Item from './Child.svelte';

  let list = [{ name: "Foo", id: 1 },
    { name: "Bar", id: 2 }]

  const addItem = () => {
    const id = +new Date();

    list = [{ name: "Random" + id, id }, ...list]
  };
</script>

<div class="text-black">
  <button class="border p-2" on:click={addItem}>add item</button>
  <h3>
    Dangerous <code>key=index</code>
  </h3>
  <form>
    {#each list as todo}
      <Item {...todo} />
    {/each}
  </form>
  <h3>
    Better <code>key=id</code>
  </h3>
  <form>
    {#each list as todo (todo.id)}
      <Item {...todo} />
    {/each}
  </form>
</div>
```
## 小结

本章我们对比了：
- React通过数组的`map`方法来实现循环列表功能
- Vue通过`v-for`的方式来实现循环列表功能
- Svelte通过`{#each}{/each}`来实现循环列表的功能
- key在循环中的重要性。---
title: Svelte从入门到精通——遍历
description: 【实现篇】遍历
---

## 解析子节点
在前面的章节中，我们反复提到没有支持标签内子元素的展示，而导致我们在演示时只能干写标签而无内容，在本章中我们将完善这一功能。

首先我们要改造的是parseFragments：
```javascript
function parseFragments(condition) {
  const fragments = [];
  while (condition()) {
    const fragment = parseFragment();
    if (fragment) {
      fragments.push(fragment);
    }
  }
  return fragments;
}
```

将其改为接收一个参数condition，condition是一个方法，执行后得到是否符合条件的布尔值。修改这一步的原因是因为在解析子元素时的while判断条件和初始解析时的判断条件不一样。

之后我们修改最初调用parseFragments时的代码，将原来while的判断改成一个方法参数传入。
```javascript
ast.html = parseFragments(() => i < content.length);
```

修改parseElement的内容
```diff
function parseElement() {
  skipWhitespace();
  if (match('<')) {
    eat('<');
    const tagName = readWhileMatching(/[a-z]/);
    const attributes = parseAttributeList();
    eat('>');
    const endTag = `</${tagName}>`;
    const element = {
      type: 'Element',
      name: tagName,
      attributes,
-     children: []
+     children: parseFragments(() => !match(endTag)),
      };
    eat(endTag);
    skipWhitespace();
    return element;
  }
}
```
很明显，从一个标签开始到标签结束的这部分内容，我们把它看成是子标签的内容。

完善generate内traverse对Element的转换
```javascript
function traverse(node, parent) {
  switch(node.type) {
    case 'Element': {
      ...

      node.children.forEach(child => {
        traverse(child, variableName);
      });

      ...
    }
  ...
}
```

往上一章中的App.svelte中添加内容：
```html
<script>
  let count = 0;
  const updateCount = () => {
    count++;
    console.log('update count', count);
  }
</script>

文本内容1
<button on:click={updateCount}>标签内文本</button>
文本内容2
```

`npm run compile`执行看一下
![](/images/svelte/41-1.gif)

## prettier
现在我们已经有了基本的Svelte编译思路，然而我们不管是从我们执行`npm run compile`后的app.js还是从控制台中看，编译出来的代码的格式都非常不美观。
![](/images/svelte/41-2.png)

一种方式是我们每次在`npm run compile`后，手动地通过VSCode的格式化功能来格式化我们app.js的代码，那有没有更便捷的方式呢？答案便是我们可以在代码中引入[Prettier](https://prettier.io/)。

```bash
npm install prettier -D
```

```javascript
import * as fs from "fs";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";
import * as acorn from "acorn";
import * as escodegen from "escodegen";
import * as prettier from "prettier";
```

修改我们的入口方法：
```javascript
async function bootstrap() {
  try {
    const inputPath = resolve(modulePath, "./App.svelte");
    const outputPath = resolve(modulePath, "./app.js");
    const content = fs.readFileSync(inputPath, "utf-8");
    const compiledContent = compile(content);;
    const prettierContent = await prettier.format(compiledContent, {parser: 'babel'});
    fs.writeFileSync(outputPath, prettierContent, "utf-8");
  } catch (e) {
    console.error(e);
  }
}
```

重新执行`npm run compile`看下
![](/images/svelte/41-3.png)
之后我们就能清晰地看到经过编译后的js代码长什么样啦。

## 完整代码
```javascript
import * as fs from "fs";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";
import * as acorn from "acorn";
import * as escodegen from "escodegen";
import * as prettier from "prettier";

const modulePath = dirname(fileURLToPath(import.meta.url));

async function bootstrap() {
  try {
    const inputPath = resolve(modulePath, "./App.svelte");
    const outputPath = resolve(modulePath, "./app.js");
    const content = fs.readFileSync(inputPath, "utf-8");
    const compiledContent = compile(content);
    const prettierContent = await prettier.format(compiledContent, {parser: 'babel'});
    fs.writeFileSync(outputPath, prettierContent, "utf-8");
  } catch (e) {
    console.error(e);
  }
}

function compile(content) {
  const ast = parse(content); // 解析svelte文件内容成ast
  return generate(ast);
}

function parse(content) {
  let i = 0;
  const ast = {};
  ast.html = parseFragments(() => i < content.length);
  
  return ast;

  function parseFragments(condition) {
    const fragments = [];
    while (condition()) {
      const fragment = parseFragment();
      if (fragment) {
        fragments.push(fragment);
      }
    }
    return fragments;
  }

  function parseFragment() {
    return parseScript() ?? parseElement() ?? parseText();
  }

  function parseScript() {
    skipWhitespace();
    if (match("<script>")) {
      eat("<script>");
      const startIndex = i;
      const endIndex = content.indexOf("</script>", i);
      const code = content.slice(startIndex, endIndex);
      ast.script = acorn.parse(code, { ecmaVersion: 2023 });
      i = endIndex;
      eat("</script>");
      skipWhitespace();
    }
  }

  function parseElement() {
    skipWhitespace();
    if (match('<')) {
      eat('<');
      const tagName = readWhileMatching(/[a-z]/);
      const attributes = parseAttributes();
      eat('>');
      const endTag = `</${tagName}>`;
      const element = {
        type: 'Element',
        name: tagName,
        attributes,
        children: parseFragments(() => !match(endTag)),
      };
      eat(endTag);
      skipWhitespace();
      return element;
    }
  }

  function parseAttributes() {
    skipWhitespace();
    const attributes = [];
    while(!match('>')) {
      attributes.push(parseAttribute());
      skipWhitespace();
    }
    return attributes;
  }

  function parseAttribute() {
    const name = readWhileMatching(/[^=]/);
    if (match('={')) {
      eat('={');
      const value = parseJavaScript();
      eat('}');
      return {
        type: 'Attribute',
        name,
        value,
      };
    }
  }

  function parseJavaScript() {
    const js = acorn.parseExpressionAt(content, i, { ecmaVersion: 2023 });
    i = js.end;
    return js;
  }

  function parseText() {
    const text = readWhileMatching(/[^<{]/);
    if (text.trim() !== '') {
      return {
        type: 'Text',
        value: text.trim(),
      }
    }
  }

  function match(str) {
    return content.slice(i, i + str.length) === str;
  }

  function eat(str) {
    if (match(str)) {
      i += str.length;
    } else {
      throw new Error(`Parse error: expecting "${str}"`);
    }
  }

  function readWhileMatching(reg) {
    let startIndex = i;
    while(i < content.length && reg.test(content[i])) {
      i++;
    }
    return content.slice(startIndex, i);
  }

  function skipWhitespace() {
    readWhileMatching(/[\s\n]/);
  }
}

function generate(ast) {

  const code = {
    variables: [],
    create: [],
    destroy: [],
  };

  let counter = 1;

  function traverse(node, parent) {
    switch(node.type) {
      case 'Element': {
        const variableName = `${node.name}_${counter++}`;
        code.variables.push(variableName);
        code.create.push(
          `${variableName} = element('${node.name}')`
        )
        node.attributes.forEach(attribute => {
          traverse(attribute, variableName);
        });

        node.children.forEach(child => {
          traverse(child, variableName);
        });

        code.create.push(`append(${parent}, ${variableName})`);
        code.destroy.push(`detach(${variableName})`);
        break;
      }
      case 'Text': {
        const variableName = `txt_${counter++}`;
        code.variables.push(variableName);
        code.create.push(`${variableName} = text('${node.value}');`);
        code.create.push(`append(${parent}, ${variableName})`);
        code.destroy.push(`detach(${variableName})`);
        break;
      }
      case "Attribute": {
        if (node.name.startsWith("on:")) {
          const eventName = node.name.slice(3);
          const eventHandler = node.value.name;
          const eventNameCall = `${eventName}_${counter++}`;
          code.variables.push(eventNameCall);
          code.create.push(
            `${eventNameCall} = listen(${parent}, "${eventName}", ${eventHandler})`
          );
          code.destroy.push(`${eventNameCall}()`);
        }
        break;
      }
    }
  }

  ast.html.forEach((fragment) => traverse(fragment, 'target'));

  return `
    function element(name) {
      return document.createElement(name);
    }

    function text(data) {
      return document.createTextNode(data);
    }

    function append(target, node) {
      target.appendChild(node);
    }

    function detach(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }

    export function listen(node, event, handler) {
      node.addEventListener(event, handler);
      return () => node.removeEventListener(event, handler);
    }
    
    export default function() {
      ${code.variables.map(v => `let ${v};`).join('\n')}

      ${escodegen.generate(ast.script)}

      var lifecycle = {
        create(target) {
          ${code.create.join('\n')}
        },
        destroy(target) {
          ${code.destroy.join('\n')}
        }
      };
      return lifecycle;
    }
  `;
}

bootstrap();
```
## 小结

本章我们实现了：
- 对html标签进行递归解析
- 对编译后的代码进行格式化的美化操作---
title: Svelte从入门到精通——变量更新
description: 【实现篇】变量更新
---

## 解析表达式
目前，我们在标签内的展示内容，都是静态文本。这一样，我们添加对诸如`<div>{count}</div>`形式内容的支持。

首先在`parseFragment`方法中添加`parseExpression`方法：
```javascript
function parseFragment() {
  return parseScript() ?? parseElement() ?? parseText() ?? parseExpression();
}
```

```javascript
function parseExpression() {
  if (match('{')) {
    eat('{');
    const expression = parseJavaScript();
    eat('}');
    return {
    type: 'Expression',
    expression,
    };
  }
}
```
在《解析html》章节，我们已经实现了`parseJavaScript`的支持，其功能就是调用`acorn`的`parseExpressionAt`方法。`parseExpression`返回`type: 'Expression'`类型的对象。

完善generate内的traverse方法：
```javascript
function traverse(node, parent) {
  switch(node.type) {
    ...

    case 'Expression': {
      const variableName = `exp_${counter++}`;
      const expressionStr = escodegen.generate(node.expression);
      code.variables.push(variableName);
      code.create.push(
        `${variableName} = text(${expressionStr})`
      );
      code.create.push(`append(${parent}, ${variableName});`);
      break;
    }
  }
}
```
对于`Expression`类型的对象，调用`escodegen.generate`来生成js代码。

修改App.svelte的内容，同时我们把原来的button自定义样式移除。
![](/images/svelte/42-1.gif)

通过编译后的方法中，我们可以看到：
![](/images/svelte/42-2.png)  

我们的`{count}`已经能被编译成`exp_5 = text(count)`。现在我们还差关键的一步：更新状态。


## 静态分析

我们知道Svelte是在静态代码阶段就解析出变量之间的关系，从而实现了响应式。首先我们定义一个`analyse`方法，用来解析代码中变量之间的关系，然后在生成阶段，我们会用到这部分数据。

```javascript
function compile(content) {
  const ast = parse(content); // 解析svelte文件内容成ast
  const analysis = analyse(ast);
  return generate(ast, analysis);
}
```

```javascript
function analyse(ast) {
  const result = {
    variables: new Set(),
    willChange: new Set(),
    useInTemplate: new Set(),
  };

  return result;
}
```

result对象中有三个属性：viriables记录声明的变量，willChange记录会触发更新的变量，useInTemplate记录在html模板内容中使用到的变量。使用Set集合来确保我们记录到的变量唯一不重复。

### 解析script

安装`estree-walker`和`periscopic`。`estree-walker`用来编译ast对象，`periscopic`用来分析代码的作用域。
```bash
npm install estree-walker periscopic -D
```

```diff
  import * as fs from "fs";
  import { fileURLToPath } from "url";
  import { dirname, resolve } from "path";
  import * as acorn from "acorn";
  import * as escodegen from "escodegen";
  import * as prettier from "prettier";
+ import * as estreewalker from "estree-walker";
+ import * as periscopic from "periscopic";
```

```javascript
function analyse(ast) {
  ...
  const { scope: rootScope, map, globals } = periscopic.analyze(ast.script);
  result.variables = new Set(rootScope.declarations.keys());
  result.rootScope = rootScope;
  result.map = map;

  let currentScope = rootScope;
  estreewalker.walk(ast.script, {
    enter(node) {
      if (map.has(node)) {
        currentScope = map.get(node)
      }
      if (node.type === 'UpdateExpression' || node.type === 'AssignmentExpression') {
        const names = periscopic.extract_names(node.type === 'UpdateExpression' ? node.argument : node.left);
        for(const name of names) {
          if (currentScope.find_owner(name) === rootScope || globals.has(name)) {
            result.willChange.add(name);
          }
        }
      }
    },
    leave(node) {
      if (map.has(node)) {
        currentScope = currentScope.parent;
      }
    }
  })
}
```

- 首先我们用`periscopic`来`analyse`script标签内代码的作用域，`rootScope.declarations.keys()`能够拿到我们定义在script标签内声明的所有变量。
- 使用`estreewalker`来遍历script的抽象语法树。`enter`方法首先拿到当前节点的作用域。然后如果节点的类型是`UpdateExpression`或`AssignmentExpression`，它将提取出所有的变量名，并检查这些名字是否在根作用域（rootScope）或全局变量（globals）中。如果是，将这些名字加入到`willChange`变量中。
- 离开节点时重置作用域

我们举个简单的例子来演示下：
```javascript
import * as acorn from 'acorn';
import { extract_names } from 'periscopic';
import { walk } from "estree-walker";

export let a = `let a = 0;
let b = 1;
let add1 = () => {
  a++;
}
let add2 = () => {
  a = b + 1;
}
`;

let ast = acorn.parse(a, { ecmaVersion: 2023 });

walk(ast, {
  enter(node) {
    console.log('ast node', node);
    if (node.type === 'UpdateExpression' || node.type === 'AssignmentExpression') {
      const names = extract_names(node.type === 'UpdateExpression' ? node.argument : node.left);
      console.log('variable names', names)
    }
  },
  leave(node) {}
})
```

![](/images/svelte/42-4.png)

我们可以看到，`UpdateExpression`对应的是`a++`相关节点，通过`extract_names`取`node.argument`里的name即是自增赋值后要更新的变量a，而`AssignmentExpression`对应的是`a = b + 1;`，`extract_names`需要取`node.left`里的name，才能取到被赋值后的变量。

### 解析html

完善`analyse`方法：
```javascript
function traverse(fragment) {
  switch(fragment.type) {
    case 'Element':
      fragment.children.forEach((child) => traverse(child));
      break;
    case 'Expression': {
      periscopic.extract_names(fragment.expression).forEach((name) => {
        result.willUseInTemplate.add(name);
      });
      break;
    } 
  }
}
ast.html.forEach(fragment => traverse(fragment));
```

`willUseInTemplate`用来存储在html模板语法内使用到的变量，比如以下例子：  
```html
<div>{count}</div>
```
`{count}`中的`count`会被记录到`willUseInTemplate`中。

## 编译

完善generate方法：
```diff
function generate(ast, analysis) {

  const code = {
    variables: [],
    create: [],
+   update: [],
    destroy: [],
  };
  ...
}
```
添加`update`属性，用来存放更新逻辑的代码。

### 编译script
在`generate`方法中添加：
```javascript
const { rootScope, map } = analysis;
let currentScope = rootScope;
estreewalker.walk(ast.script, {
  enter(node, parent) {
    if (map.has(node)) {
      currentScope = map.get(node)
    }
    if (node.type === 'UpdateExpression' || node.type === 'AssignmentExpression') {
      const names = periscopic
        .extract_names(
          node.type === 'UpdateExpression' ? node.argument : node.left
        )
        .filter(
          (name) =>
            currentScope.find_owner(name) === rootScope &&
            analysis.willUseInTemplate.has(name)
        );
      if (names.length > 0) {
        this.replace({
          type: 'SequenceExpression',
          expressions: [
            node,
            acorn.parseExpressionAt(`$$update(${JSON.stringify(names)})`, 0, {
              ecmaVersion: 2023,
            }),
          ],
        });
        this.skip();
      }
    }
  },
  leave(node) {
    if (map.has(node)) {
      currentScope = currentScope.parent;
    }
  }
});
```

- 一个比较重要的步骤是使用`periscopic`的`extract_names`方法提取出所有的变量名，然后过滤出在根作用域中并且在模板中会使用的变量名。
- 如果我们筛选出了符合条件的变量名，我们在这个变量名后面添加一个约定字符串`$$update([x])`，这个其实是一个方法，我们用它来模拟在运行时的`$invalidate`。

演示一个例子：
```javascript
import * as acorn from "acorn";
import { walk } from "estree-walker";
import * as escodegen from "escodegen";

export let a = `() => { a = b + c}`;

let ast = acorn.parse(a, { ecmaVersion: 2023 });
walk(ast, {
  enter(node) {
    if (node.type === "BinaryExpression") {
      this.replace({
        type: "SequenceExpression",
        expressions: [
          node,
          acorn.parseExpressionAt(`$$update()`, 0, {
            ecmaVersion: 2023,
          }),
        ],
      });
      this.skip();
    }
  },
});

let newCode = escodegen.generate(ast);
console.log('new code', newCode);
```
![](/images/svelte/42-5.png)

### 编译html

为`Expression`添加逻辑：
```javascript
function generate(ast, analysis) {
  const code = {
    variables: [],
    create: [],
    update: [],
    destroy: [],
  };

  let counter = 1;

  function traverse(node, parent) {
    switch (node.type) {
	  ...
	  
      case "Expression": {
        ...

        // 更新
        const names = periscopic.extract_names(node.expression);
        if (analysis.willChange.has(names[0])) {
          let condition = `changed.includes('${names[0]}')`;
          code.update.push(`if (${condition}) {
            ${variableName}.data = ${expressionStr};
          }`);
        }
        break;
      }
    }
  }

  ast.html.forEach((fragment) => traverse(fragment, "target"));

  ...
  
}
```

- 首先我们从expression表达式中的变量中筛选出即将要更新的变量
- 这里我们假设我们的`{}`表达式内只存在一个变量。`willChange`中记录的是被赋值后将要更新的变量，判断`{}`内获取到的变量名是否存在在`willChange`集合中，是的话填写我们的编译后的判断条件代码，把这部分执行逻辑放到`code.update`中，让它在变量更新后执行。


最后，我们需要完善我们默认导出的字符串模板内容
```javascript
function generate(ast, analysis) {
  return `
    ...
    
    export default function() {
      ${code.variables.map((v) => `let ${v};`).join("\n")}

      let collectChanges = [];
      
      function $$update(changed) {
        changed.forEach(c => collectChanges.push(c));
        lifecycle.update(collectChanges);
      }

      ${escodegen.generate(ast.script)}

      var lifecycle = {
        create(target) {
          ${code.create.join("\n")}
        },
        update(changed) {
          ${code.update.join('\n')}
        },
        destroy(target) {
          ${code.destroy.join("\n")}
        }
      };
      return lifecycle;
    }
  `;
}
```

- 添加`$$update`方法，这个方法我们在前面已经通过逻辑判断，只要变量会更新，在后面便会带上该方法。
- `lifecycle`中补充`update`的逻辑，展开`code.update`中已经存放好的update生命周期的方法。

我们修改App.svelte的内容测试一下：
```html
<script>
  let count = 0;
  const updateCount = () => {
    count++;
    console.log('update count', count);
  }
</script>

<button on:click={updateCount}>add</button>
count: {count}
```

![](/images/svelte/42-3.gif)  

观察编译后的代码，发现在`count++`后携带了`$$update([count])`：  
![](/images/svelte/42-6.png)

到这里，一个最最基本的Svelte编译器已经完成！

## 完整代码
```javascript
import * as fs from "fs";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";
import * as acorn from "acorn";
import * as escodegen from "escodegen";
import * as prettier from "prettier";
import * as estreewalker from "estree-walker";
import * as periscopic from "periscopic";

const modulePath = dirname(fileURLToPath(import.meta.url));

async function bootstrap() {
  try {
    const inputPath = resolve(modulePath, "./App.svelte");
    const outputPath = resolve(modulePath, "./app.js");
    const content = fs.readFileSync(inputPath, "utf-8");
    const compiledContent = compile(content);
    const prettierContent = await prettier.format(compiledContent, {
      parser: "babel",
    });
    fs.writeFileSync(outputPath, prettierContent, "utf-8");
  } catch (e) {
    console.error(e);
  }
}

function compile(content) {
  const ast = parse(content); // 解析svelte文件内容成ast
  const analysis = analyse(ast);
  return generate(ast, analysis);
}

function parse(content) {
  let i = 0;
  const ast = {};
  ast.html = parseFragments(() => i < content.length);

  return ast;

  function parseFragments(condition) {
    const fragments = [];
    while (condition()) {
      const fragment = parseFragment();
      if (fragment) {
        fragments.push(fragment);
      }
    }
    return fragments;
  }

  function parseFragment() {
    return parseScript() ?? parseElement() ?? parseText() ?? parseExpression();
  }

  function parseScript() {
    skipWhitespace();
    if (match("<script>")) {
      eat("<script>");
      const startIndex = i;
      const endIndex = content.indexOf("</script>", i);
      const code = content.slice(startIndex, endIndex);
      ast.script = acorn.parse(code, { ecmaVersion: 2023 });
      i = endIndex;
      eat("</script>");
      skipWhitespace();
    }
  }

  function parseElement() {
    skipWhitespace();
    if (match("<")) {
      eat("<");
      const tagName = readWhileMatching(/[a-z]/);
      const attributes = parseAttributes();
      eat(">");
      const endTag = `</${tagName}>`;
      const element = {
        type: "Element",
        name: tagName,
        attributes,
        children: parseFragments(() => !match(endTag)),
      };
      eat(endTag);
      skipWhitespace();
      return element;
    }
  }

  function parseAttributes() {
    skipWhitespace();
    const attributes = [];
    while (!match(">")) {
      attributes.push(parseAttribute());
      skipWhitespace();
    }
    return attributes;
  }

  function parseAttribute() {
    const name = readWhileMatching(/[^=]/);
    if (match("={")) {
      eat("={");
      const value = parseJavaScript();
      eat("}");
      return {
        type: "Attribute",
        name,
        value,
      };
    }
  }

  function parseExpression() {
    if (match("{")) {
      eat("{");
      const expression = parseJavaScript();
      eat("}");
      return {
        type: "Expression",
        expression,
      };
    }
  }

  function parseJavaScript() {
    const js = acorn.parseExpressionAt(content, i, { ecmaVersion: 2023 });
    i = js.end;
    return js;
  }

  function parseText() {
    const text = readWhileMatching(/[^<{]/);
    if (text.trim() !== "") {
      return {
        type: "Text",
        value: text.trim(),
      };
    }
  }

  function match(str) {
    return content.slice(i, i + str.length) === str;
  }

  function eat(str) {
    if (match(str)) {
      i += str.length;
    } else {
      throw new Error(`Parse error: expecting "${str}"`);
    }
  }

  function readWhileMatching(reg) {
    let startIndex = i;
    while (i < content.length && reg.test(content[i])) {
      i++;
    }
    return content.slice(startIndex, i);
  }

  function skipWhitespace() {
    readWhileMatching(/[\s\n]/);
  }
}

function analyse(ast) {
  const result = {
    variables: new Set(),
    willChange: new Set(),
    useInTemplate: new Set(),
  };

  const { scope: rootScope, map, globals } = periscopic.analyze(ast.script);
  result.variables = new Set(rootScope.declarations.keys());
  result.rootScope = rootScope;
  result.map = map;

  let currentScope = rootScope;
  estreewalker.walk(ast.script, {
    enter(node) {
      if (map.has(node)) {
        currentScope = map.get(node);
      }
      if (
        node.type === "UpdateExpression" ||
        node.type === "AssignmentExpression"
      ) {
        const names = periscopic.extract_names(
          node.type === "UpdateExpression" ? node.argument : node.left
        );
        for (const name of names) {
          if (
            currentScope.find_owner(name) === rootScope ||
            globals.has(name)
          ) {
            result.willChange.add(name);
          }
        }
      }
    },
    leave(node) {
      if (map.has(node)) {
        currentScope = currentScope.parent;
      }
    },
  });

  function traverse(fragment) {
    switch (fragment.type) {
      case "Element":
        fragment.children.forEach((child) => traverse(child));
        break;
      case "Expression": {
        periscopic.extract_names(fragment.expression).forEach((name) => {
          result.useInTemplate.add(name);
        });
        break;
      }
    }
  }
  ast.html.forEach((fragment) => traverse(fragment));

  return result;
}


function generate(ast, analysis) {
  const code = {
    variables: [],
    create: [],
    update: [],
    destroy: [],
  };

  let counter = 1;

  function traverse(node, parent) {
    switch (node.type) {
      case "Element": {
        const variableName = `${node.name}_${counter++}`;
        code.variables.push(variableName);
        code.create.push(`${variableName} = element('${node.name}')`);
        node.attributes.forEach((attribute) => {
          traverse(attribute, variableName);
        });

        node.children.forEach((child) => {
          traverse(child, variableName);
        });

        code.create.push(`append(${parent}, ${variableName})`);
        code.destroy.push(`detach(${variableName})`);
        break;
      }
      case "Text": {
        const variableName = `txt_${counter++}`;
        code.variables.push(variableName);
        code.create.push(`${variableName} = text('${node.value}');`);
        code.create.push(`append(${parent}, ${variableName})`);
        code.destroy.push(`detach(${variableName})`);
        break;
      }
      case "Attribute": {
        if (node.name.startsWith("on:")) {
          const eventName = node.name.slice(3);
          const eventHandler = node.value.name;
          const eventNameCall = `${eventName}_${counter++}`;
          code.variables.push(eventNameCall);
          code.create.push(
            `${eventNameCall} = listen(${parent}, "${eventName}", ${eventHandler})`
          );
          code.destroy.push(`${eventNameCall}()`);
        }
        break;
      }
      case "Expression": {
        const variableName = `exp_${counter++}`;
        const expressionStr = escodegen.generate(node.expression);
        code.variables.push(variableName);
        code.create.push(`${variableName} = text(${expressionStr})`);
        code.create.push(`append(${parent}, ${variableName});`);

        // 更新
        const names = periscopic.extract_names(node.expression);
        if (analysis.willChange.has(names[0])) {
          let condition = `changed.includes('${names[0]}')`;
          code.update.push(`if (${condition}) {
            ${variableName}.data = ${expressionStr};
          }`);
        }
        break;
      }
    }
  }

  ast.html.forEach((fragment) => traverse(fragment, "target"));

  const { rootScope, map } = analysis;
  let currentScope = rootScope;
  estreewalker.walk(ast.script, {
    enter(node, parent) {
      if (map.has(node)) {
        currentScope = map.get(node)
      }
      if (node.type === 'UpdateExpression' || node.type === 'AssignmentExpression') {
        const names = periscopic
          .extract_names(
            node.type === 'UpdateExpression' ? node.argument : node.left
          )
          .filter(
            (name) =>
              currentScope.find_owner(name) === rootScope &&
              analysis.useInTemplate.has(name)
          );
        if (names.length > 0) {
          this.replace({
            type: 'SequenceExpression',
            expressions: [
              node,
              acorn.parseExpressionAt(`$$update(${JSON.stringify(names)})`, 0, {
                ecmaVersion: 2023,
              }),
            ],
          });
          this.skip();
        }
      }
    },
    leave(node) {
      if (map.has(node)) {
        currentScope = currentScope.parent;
      }
    }
  });

  return `
    function element(name) {
      return document.createElement(name);
    }

    function text(data) {
      return document.createTextNode(data);
    }

    function append(target, node) {
      target.appendChild(node);
    }

    function detach(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }

    export function listen(node, event, handler) {
      node.addEventListener(event, handler);
      return () => node.removeEventListener(event, handler);
    }
    
    export default function() {
      ${code.variables.map((v) => `let ${v};`).join("\n")}

      let collectChanges = [];
      
      function $$update(changed) {
        changed.forEach(c => collectChanges.push(c));
        lifecycle.update(collectChanges);
      }

      ${escodegen.generate(ast.script)}

      var lifecycle = {
        create(target) {
          ${code.create.join("\n")}
        },
        update(changed) {
          ${code.update.join('\n')}
        },
        destroy(target) {
          ${code.destroy.join("\n")}
        }
      };
      return lifecycle;
    }
  `;
}

bootstrap();
```

## 小结

本章我们实现了：
- 解析html模板内的变量
- 收集文件中存在更新操作的变量
- 对`<script></script>`标签内的更新方法进行重新编译，编译成能够触发框架更新的`$$update`方法---
title: Svelte从入门到精通——生态
description: 【展望篇】生态
---

尽管 Svelte 的生态环境和 React、Vue 这两大框架相比稍显得不够庞大，但对于基本的开发已经覆盖全面。为了展现其全面性，会继续从三大框架的各个方面进行对比。

## 对比

|                | Svelte                                                                                                                                                                                             | React                                                                                                                                            | Vue                                                                                                                                                                           |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| cli            | 旧版：[svelte-cli](https://github.com/sveltejs/svelte-cli)<br/>目前：[Vite](https://vitejs.dev/)                                                                                                   | [create-react-app](https://create-react-app.dev/)                                                                                                | [Vue Cli](https://cli.vuejs.org/)<br />[Vite](https://vitejs.dev/)                                                                                                            |
| 路由           | [routify](https://github.com/roxiness/routify)<br />[svelte-spa-router](https://github.com/ItalyPaleAle/svelte-spa-router)<br />[svelte-routing](https://github.com/EmilTholin/svelte-routing)     | [react-router](https://github.com/remix-run/react-router)                                                                                        | [vue-router](https://github.com/vuejs/vue-router)                                                                                                                             |
| 状态管理       | svelte/store                                                                                                                                                                                       | [redux](https://github.com/reduxjs/redux)                                                                                                        | [vuex](https://github.com/vuejs/vuex)<br />[pinia](https://github.com/vuejs/pinia)                                                                                            |
| SSR            | [SvelteKit](https://kit.svelte.dev/)                                                                                                                                                               | [Next.js](https://nextjs.org/)                                                                                                                   | [Nuxt](https://nuxt.com/)                                                                                                                                                     |
| 静态/文档      | [SvelteKit](https://kit.svelte.dev/)<br />[Elder.js](https://elderguide.com/tech/elderjs/)                                                                                                         | [Next.js](https://nextjs.org/)<br />[Gatsby](https://www.gatsbyjs.com/)<br />[Docusaurus](https://docusaurus.io/)                                | [VuePress](https://vuepress.vuejs.org/)<br />[VitePress](https://vitepress.dev/)                                                                                              |
| UI 组件        | [shadcn-svelte](https://www.shadcn-svelte.com/)<br />[svelte-material-ui](https://sveltematerialui.com/)<br />[Flowbite Svelte](https://flowbite-svelte.com/)<br />[Melt UI](https://melt-ui.com/) | [Ant Design](https://ant-design.antgroup.com/index-cn)<br />[MUI](https://mui.com/)<br />[chakra](https://chakra-ui.com/)                        | [Element Plus](https://element-plus.gitee.io/zh-CN/)<br />[Ant Design Vue](https://antdv.com/components/overview)<br />[Vant](https://vant-ui.github.io/vant/#/zh-CN)         |
| 测试           | [svelte-testing-library](https://github.com/testing-library/svelte-testing-library)                                                                                                                | [react-testing-library](https://github.com/testing-library/react-testing-library)<br />[Enzyme](https://enzymejs.github.io/enzyme/)              | [vue-testing-library](https://testing-library.com/docs/vue-testing-library/intro/)<br />[Vue Test Utils](https://v1.test-utils.vuejs.org/)<br />[Vitest](https://vitest.dev/) |
| dev tools      | [Svelte DevTools](https://chromewebstore.google.com/detail/svelte-devtools/kfidecgcdjjfpeckbblhmfkhmlgecoff?utm_source=ext_app_menu)                                                               | [React Developer Tools](https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?utm_source=ext_app_menu) | [Vue.js devtools](https://chromewebstore.google.com/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?utm_source=ext_app_menu)                                           |
| webpack loader | [svelte-loader](https://github.com/sveltejs/svelte-loader)                                                                                                                                         | [babel-loader](https://github.com/babel/babel-loader)                                                                                            | [vue-loader](https://github.com/vuejs/vue-loader)                                                                                                                             |
| Rollup plugin  | [rollup-plugin-svelte](https://github.com/sveltejs/rollup-plugin-svelte)                                                                                                                           | [@rollup/plugin-babel](https://github.com/rollup/plugins/tree/master/packages/babel)                                                             | [rollup-plugin-vue](https://github.com/vuejs/rollup-plugin-vue)                                                                                                               |
| Vite plugin    | [@sveltejs/vite-plugin-svelte](https://github.com/sveltejs/vite-plugin-svelte)                                                                                                                     | [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react)                                                                              | [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue)                                                                                                               |
| Native         | [Svelte Native](https://svelte-native.technology/)                                                                                                                                                 | [React Native](https://reactnative.dev/)                                                                                                         | [Weex](https://weexapp.com/)                                                                                                                                                  |
| 小程序         | [tarojs-plugin-svelte](https://github.com/SyMind/tarojs-plugin-svelte)                                                                                                                             | [Taro](https://docs.taro.zone/docs/)                                                                                                             | [mpvue](http://mpvue.com/)                                                                                                                                                    |
| 社区           | [sveltesociety](https://www.sveltesociety.dev/)                                                                                                                                                    | [react community](https://react.dev/community)                                                                                                   | [vue community](https://vue-community.org/)                                                                                                                                   |

## Svelte 5

`Svelte` 宣布了一项新特性 `"runes"`，这个特性将在 `Svelte5` 中大幅改变开发者的体验。`Rune` 是一种可以影响 `Svelte` 编译器的符号，`Svelt5` 中的 `runes` 使用函数语法实现，达到和现有的声明式语法等效的效果，如 `$state` 用于声明响应式状态。`Rune` 的引入，可以让你的 `.svelte` 文件之外的其他文件也拥有响应式能力。相较于现有的 `store API`，`rune` 可以更简单地处理更复杂的事物。

### Runes

Svelte 5 最大的改动便是引入了**Runes**。Runes 是一组函数式的符号，无需额外引入，可以直接使用，是 Svelte5 语言的特性，目前有以下 Runes，文章里会挑选比较重要的几个进行讲解：

- `$state`
- `$derived`
- `$effect`
- `$props`

#### `$state`

```html
<script>
	let count = $state(0);
</script>

<button on:click={() => count++}>
click
</button>
{count}
```

对比之前的数据声明，多了`$state`。

使用`$state`声明的数组可以直接操作了。

```html
<script>
  const arr = $state([1, 2]);

  const onAdd = () => {
    arr.push(1);
  };

  const onSub = () => {
    arr.pop();
  };
</script>

<p>
  <button on:click="{onAdd}">增加</button>
  <button on:click="{onSub}">减少</button>
</p>
数组：{arr.join(',')}
```

#### `$derived`

`$derived`接收一个参数，这个参数是一个没有副作用的表达式。

```html
<script>
  let count = $state(0);
  let double = $derived(count * 2);

  const onClick = () => {
    count++;
  };
</script>

<button on:click="{onClick}">更新</button><br />
count: {count} double: {double}
```

我们可以传`count * 2`，但是不能传`count++`。
在 Svelte4 中，我们要声明一个派生属性，需在`$: `里进行。

#### `$effect`

> runs when the component is mounted, and again whenever `count` or `doubled` change,after the DOM has been updated.

因此，`$effect`相当于`$: {}`和`onMount`、`afterUpdate`的结合体。笔者对此改动表示热烈欢迎，因为本人始终觉得在有些框架中，一个组件对外提供一大串又丑又长的生命周期，着实加大了开发者的心智负担。

```html
<script>
  let width = $state(10);

  $effect(() => {
    console.log("width改变", width);
  });
</script>

width: <input type="number" bind:value="{width}" />
```

#### `$props`

和明显，用来接收 props 的 Runes。

```html
<script>
  export let value;
</script>

子组件：{value}
```

```html
<script>
  let { value } = $props();
</script>

子组件：{value}
```

### Snippets

俗称片段。使用 Snippets 可以进行内容复用。

```html
<script>
  let arr = $state([
    {
      name: "carter",
      age: 18,
      gender: "男",
    },
    {
      name: "lily",
      age: 19,
      gender: "女",
    },
  ]);
</script>

{#snippet person({ name, age, gender })}
<p>
  <span>姓名：{name}</span>
  <span> 年龄：{age}</span>
  <span>性别：{gender}</span>
</p>
{/snippet} {#each arr as item, i} {@render person(item)} {/each}
```

使用`{#snippet snippetName()}...{/snippet}`来定义我们要复用的片段，使用`{@render snippetName()}`来复用定义好的片段。

在之前，如果我们要复用这一段代码，只能把它放入到另一个 svelte 文件中，当成组件来引用。

### 事件

#### 事件监听

在演示 Runes 和 Snippets 时，笔者在使用到数据绑定时，仍旧使用的是 Svelte4`on:eventname`的形式。其实在 Svelte5 中，关于方法的使用也有更新：从原来`on:eventname`的形式转变为`oneventname`的形式。

```diff
<script>
  const onClick = () => {
    console.log('click');
  }
</script>

- <button on:click={onClick}>click</button>
+ <button onclick={onClick}>click</button>
```

#### 组件事件

使用`$props()`来接收方法。终于不用使用难用的`createEventDispatcher`了。

```html
<script>
  let { onClick, onClick2 } = $props();
</script>

<button onclick={onClick}>click</button>
<button onclick={e => onClick2('hello svelte')}>click2</button>
```

```html
<script>
  import Svelte5 from "./Svelte5.svelte";

  const onClick = (event) => {
    console.log("event", event);
  };

  const onClick2 = (value) => {
    console.log("value", value);
  };
</script>

<Svelte5 {onClick} {onClick2} />
```

除了接收方法，我们还能接收插槽内容。没错，在 Svelte5 中，插槽的使用转而投向了 jsx 的写法，通过`let { children } = $props()`来接收插槽内容。

```html
<script>
  let { children } = $props();
</script>

<div>
  <header>头部</header>
  <main>{@render children() }</main>
  <footer>底部</footer>
</div>
```

```html
<script>
  import Svelte5 from "./Svelte5.svelte";
</script>

<Svelte5> 内容 </Svelte5>
```

这里的`{@render ...}`和后面介绍的 Snippets 有关。思考：如何接收具名插槽？

### 方法

#### untrack

```html
<script>
  let width = $state(10);
  let height = $state(10);
  let area;

  $effect(() => {
    console.log("width or height change", width, height);
  });
</script>

width: <input type="number" bind:value="{width}" />, height:
<input type="number" bind:value="{height}" />
```

如果我们只想在 width 执行时输出 console，那就需要不追踪 height 的依赖。

```html
<script>
  import { untrack } from "svelte";

  let width = $state(10);
  let height = $state(10);

  $effect(() => {
    console.log(
      "width or height change",
      width,
      untrack(() => height)
    );
  });
</script>

width: <input type="number" bind:value="{width}" />, height:
<input type="number" bind:value="{height}" />
```

#### mount

```javascript
import { mount } from "svelte";
import App from "./App.svelte";

const app = mount(App, {
  target: document.querySelector("#app"),
  props: { some: "property" },
});
```

Svelte4

```javascript
import App from "./App.svelte";

const app = new App({
  target: document.getElementById("app"),
});

export default app;
```

更多详细内容参考[Svelte5 抢先看](https://juejin.cn/post/7341592148305870857)

## 小结

本章我们学习了：

- Svelte 对比其他框架的生态优劣
- Svelte5 的新特性前瞻
---
title: Svelte从入门到精通——IfBlock
description: 【实现篇】IfBlock
---

## 特殊block

这是实现模块的最后一章，笔者会带大家编写如何实现一个简单的if逻辑判断。

首先我们需要在原来判断表达式的逻辑里，加上对特殊html标签的判断。
```diff
function parseExpression() {
- if (match("{")) {
+ if (match("{") && !match('{#')) {
    eat("{");
    const expression = parseJavaScript();
    eat("}");
    return {
      type: "Expression",
      expression,
    };
  }
}
```

添加解析特殊标签的逻辑。
```javascript
function parseFragment() {
  return parseScript() ?? parseElement() ?? parseText() ?? parseExpression() ?? parseBlock();
}
```

parseBlock的具体内容：
```javascript
function parseBlock() {
	if (match('{#')) {
	  if (match('{#if')) {
		eat('{#if')
		skipWhitespace();
		const expression = parseJavaScript();
		eat('}');
		const endTag = '{/if}';
		const block = {
		  type: 'IfBlock',
		  expression,
		  children: parseFragments(() => !match(endTag))
		}
		eat(endTag);
		return block;
	  }
	}
}
```
我们判断在`{#if}{/if}`中的内容为IfBlock。对于里面的内容，继续调用parseFragments进行解析。


完善generate里的traverse方法
```javascript
function traverse(node, parent) {
  switch (node.type) {
    case "IfBlock": {
      const variableName = `if_block_${counter++}`;
      const funcName = `${variableName}_func`;
      const funcCallName = `${funcName}_call`;
      const expressionStr = escodegen.generate(node.expression);
      code.variables.push(variableName);
      code.variables.push(funcName);
      code.variables.push(funcCallName);
		  code.create.push(`
      ${funcName} = () => {
        if (${expressionStr}) {
          if (${funcCallName}) {return;}
          ${variableName} = element('span');
        `)
      node.children.forEach(subNode => {
        traverse(subNode, variableName)
      });

      code.create.push(`
        append(${parent}, ${variableName});
        ${funcCallName} = true;
        } else {
          ${funcCallName} = false;
          if (${variableName} && ${variableName}.parentNode) {
            detach(${variableName});
          }
        }
      }
      ${funcName}()
      `);
      
      code.destroy.push(`detach(${variableName})`);
      code.update.push(`${funcName}()`);
      
      break;
    }
  }
}
```

在App.svelte中测试一下
```html
<script>
  let count = 0;
  const updateCount = () => {
    count++;
    console.log('update count', count);
  }
</script>

<button on:click={updateCount}>add</button>
count: {count}
{#if count > 2 && count < 5}hello{/if}
```

![](/images/svelte/43-1.gif)

有了parseBlock方法，我们就可以在里面继续添加EachBlock、AwaitBlock等其他特殊标签的解析。

```javascript
addBtn.addEventListener('click', function() {
  text = document.createTextNode('');
  const div = document.createElement('div');
  div.innerHTML = 'hello';
  
  box.appendChild(text);
  box.appendChild(div);
})

removeBtn.addEventListener('click', function() {
  if (text) {
    text.parentNode.removeChild(text.nextElementSibling);
    text.parentNode.removeChild(text);
  }
})
```

## 完整代码
```javascript
import * as fs from "fs";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";
import * as acorn from "acorn";
import * as escodegen from "escodegen";
import * as prettier from "prettier";
import * as estreewalker from "estree-walker";
import * as periscopic from "periscopic";

const modulePath = dirname(fileURLToPath(import.meta.url));

async function bootstrap() {
  try {
    const inputPath = resolve(modulePath, "./App.svelte");
    const outputPath = resolve(modulePath, "./app.js");
    const content = fs.readFileSync(inputPath, "utf-8");
    const compiledContent = compile(content);
    const prettierContent = await prettier.format(compiledContent, {
      parser: "babel",
    });
    fs.writeFileSync(outputPath, prettierContent, "utf-8");
  } catch (e) {
    console.error(e);
  }
}

function compile(content) {
  const ast = parse(content); // 解析svelte文件内容成ast
  const analysis = analyse(ast);
  return generate(ast, analysis);
}

function parse(content) {
  let i = 0;
  const ast = {};
  ast.html = parseFragments(() => i < content.length);

  return ast;

  function parseFragments(condition) {
    const fragments = [];
    while (condition()) {
      const fragment = parseFragment();
      if (fragment) {
        fragments.push(fragment);
      }
    }
    return fragments;
  }

  function parseFragment() {
    return parseScript() ?? parseElement() ?? parseText() ?? parseExpression() ?? parseBlock();
  }

  function parseScript() {
    skipWhitespace();
    if (match("<script>")) {
      eat("<script>");
      const startIndex = i;
      const endIndex = content.indexOf("</script>", i);
      const code = content.slice(startIndex, endIndex);
      ast.script = acorn.parse(code, { ecmaVersion: 2023 });
      i = endIndex;
      eat("</script>");
      skipWhitespace();
    }
  }

  function parseElement() {
    skipWhitespace();
    if (match("<")) {
      eat("<");
      const tagName = readWhileMatching(/[a-z]/);
      const attributes = parseAttributes();
      eat(">");
      const endTag = `</${tagName}>`;
      const element = {
        type: "Element",
        name: tagName,
        attributes,
        children: parseFragments(() => !match(endTag)),
      };
      eat(endTag);
      skipWhitespace();
      return element;
    }
  }

  function parseAttributes() {
    skipWhitespace();
    const attributes = [];
    while (!match(">")) {
      attributes.push(parseAttribute());
      skipWhitespace();
    }
    return attributes;
  }

  function parseAttribute() {
    const name = readWhileMatching(/[^=]/);
    if (match("={")) {
      eat("={");
      const value = parseJavaScript();
      eat("}");
      return {
        type: "Attribute",
        name,
        value,
      };
    }
  }

  function parseExpression() {
    if (match("{") && !match('{#')) {
      eat("{");
      const expression = parseJavaScript();
      eat("}");
      return {
        type: "Expression",
        expression,
      };
    }
  }

  function parseJavaScript() {
    const js = acorn.parseExpressionAt(content, i, { ecmaVersion: 2023 });
    i = js.end;
    return js;
  }

  function parseText() {
    const text = readWhileMatching(/[^<{]/);
    if (text.trim() !== "") {
      return {
        type: "Text",
        value: text.trim(),
      };
    }
  }

  function parseBlock() {
    if (match('{#')) {
      if (match('{#if')) {
        eat('{#if')
        skipWhitespace();
        const expression = parseJavaScript();
        eat('}');
        const endTag = '{/if}';
        const block = {
          type: 'IfBlock',
          expression,
          children: parseFragments(() => !match(endTag))
        }
        eat(endTag);
        return block;
      }
    }
  }

  function match(str) {
    return content.slice(i, i + str.length) === str;
  }

  function eat(str) {
    if (match(str)) {
      i += str.length;
    } else {
      throw new Error(`Parse error: expecting "${str}"`);
    }
  }

  function readWhileMatching(reg) {
    let startIndex = i;
    while (i < content.length && reg.test(content[i])) {
      i++;
    }
    return content.slice(startIndex, i);
  }

  function skipWhitespace() {
    readWhileMatching(/[\s\n]/);
  }
}

function analyse(ast) {
  const result = {
    variables: new Set(),
    willChange: new Set(),
    useInTemplate: new Set(),
  };

  const { scope: rootScope, map, globals } = periscopic.analyze(ast.script);
  result.variables = new Set(rootScope.declarations.keys());
  result.rootScope = rootScope;
  result.map = map;

  let currentScope = rootScope;
  estreewalker.walk(ast.script, {
    enter(node) {
      if (map.has(node)) {
        currentScope = map.get(node);
      }
      if (
        node.type === "UpdateExpression" ||
        node.type === "AssignmentExpression"
      ) {
        const names = periscopic.extract_names(
          node.type === "UpdateExpression" ? node.argument : node.left
        );
        for (const name of names) {
          if (
            currentScope.find_owner(name) === rootScope ||
            globals.has(name)
          ) {
            result.willChange.add(name);
          }
        }
      }
    },
    leave(node) {
      if (map.has(node)) {
        currentScope = currentScope.parent;
      }
    },
  });

  function traverse(fragment) {
    switch (fragment.type) {
      case "Element":
        fragment.children.forEach((child) => traverse(child));
        break;
      case "Expression": {
        periscopic.extract_names(fragment.expression).forEach((name) => {
          result.useInTemplate.add(name);
        });
        break;
      }
    }
  }
  ast.html.forEach((fragment) => traverse(fragment));

  return result;
}


function generate(ast, analysis) {
  const code = {
    variables: [],
    create: [],
    update: [],
    destroy: [],
  };

  let counter = 1;

  function traverse(node, parent) {
    switch (node.type) {
      case "Element": {
        const variableName = `${node.name}_${counter++}`;
        code.variables.push(variableName);
        code.create.push(`${variableName} = element('${node.name}')`);
        node.attributes.forEach((attribute) => {
          traverse(attribute, variableName);
        });

        node.children.forEach((child) => {
          traverse(child, variableName);
        });

        code.create.push(`append(${parent}, ${variableName})`);
        code.destroy.push(`detach(${variableName})`);
        break;
      }
      case "Text": {
        const variableName = `txt_${counter++}`;
        code.variables.push(variableName);
        code.create.push(`${variableName} = text('${node.value}');`);
        code.create.push(`append(${parent}, ${variableName})`);
        code.destroy.push(`detach(${variableName})`);
        break;
      }
      case "Attribute": {
        if (node.name.startsWith("on:")) {
          const eventName = node.name.slice(3);
          const eventHandler = node.value.name;
          const eventNameCall = `${eventName}_${counter++}`;
          code.variables.push(eventNameCall);
          code.create.push(
            `${eventNameCall} = listen(${parent}, "${eventName}", ${eventHandler})`
          );
          code.destroy.push(`${eventNameCall}()`);
        }
        break;
      }
      case "Expression": {
        const variableName = `exp_${counter++}`;
        const expressionStr = escodegen.generate(node.expression);
        code.variables.push(variableName);
        code.create.push(`${variableName} = text(${expressionStr})`);
        code.create.push(`append(${parent}, ${variableName});`);

        // 更新
        const names = periscopic.extract_names(node.expression);
        if (analysis.willChange.has(names[0])) {
          let condition = `changed.includes('${names[0]}')`;
          code.update.push(`if (${condition}) {
            ${variableName}.data = ${expressionStr};
          }`);
        }
        break;
      }
      case "IfBlock": {
        const variableName = `if_block_${counter++}`;
        const funcName = `${variableName}_func`;
        const funcCallName = `${funcName}_call`;
        const expressionStr = escodegen.generate(node.expression);
        code.variables.push(variableName);
        code.variables.push(funcName);
        code.variables.push(funcCallName);

        code.create.push(`
        ${funcName} = () => {
          if (${expressionStr}) {
            if (${funcCallName}) {return;}
            ${variableName} = element('span');
          `)
          node.children.forEach(subNode => {
            traverse(subNode, variableName)
          });

        code.create.push(`
          append(${parent}, ${variableName});
          ${funcCallName} = true;
          } else {
            ${funcCallName} = false;
            if (${variableName} && ${variableName}.parentNode) {
              detach(${variableName});
            }
          }
        }
        ${funcName}()
        `);
        
        code.destroy.push(`detach(${variableName})`);
        code.update.push(`${funcName}()`);
        
        break;
      }
    }
  }

  ast.html.forEach((fragment) => traverse(fragment, "target"));

  const { rootScope, map } = analysis;
  let currentScope = rootScope;
  estreewalker.walk(ast.script, {
    enter(node, parent) {
      if (map.has(node)) {
        currentScope = map.get(node)
      }
      if (node.type === 'UpdateExpression' || node.type === 'AssignmentExpression') {
        const names = periscopic
          .extract_names(
            node.type === 'UpdateExpression' ? node.argument : node.left
          )
          .filter(
            (name) =>
              currentScope.find_owner(name) === rootScope &&
              analysis.useInTemplate.has(name)
          );
        if (names.length > 0) {
          this.replace({
            type: 'SequenceExpression',
            expressions: [
              node,
              acorn.parseExpressionAt(`$$update(${JSON.stringify(names)})`, 0, {
                ecmaVersion: 2023,
              }),
            ],
          });
          this.skip();
        }
      }
    },
    leave(node) {
      if (map.has(node)) {
        currentScope = currentScope.parent;
      }
    }
  });

  return `
    function element(name) {
      return document.createElement(name);
    }

    function text(data) {
      return document.createTextNode(data);
    }

    function append(target, node) {
      target.appendChild(node);
    }

    function detach(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }

    export function listen(node, event, handler) {
      node.addEventListener(event, handler);
      return () => node.removeEventListener(event, handler);
    }
    
    export default function() {
      ${code.variables.map((v) => `let ${v};`).join("\n")}

      let collectChanges = [];
      
      function $$update(changed) {
        changed.forEach(c => collectChanges.push(c));
        lifecycle.update(collectChanges);
      }

      ${escodegen.generate(ast.script)}

      var lifecycle = {
        create(target) {
          ${code.create.join("\n")}
        },
        update(changed) {
          ${code.update.join('\n')}
        },
        destroy(target) {
          ${code.destroy.join("\n")}
        }
      };
      return lifecycle;
    }
  `;
}

bootstrap();
```

## 小结

本章我们实现了：
- IfBlock的解析。

笔者在本章使用的实现方式存在一个缺点：IfBlock的内容外层多了一个span标签包裹。然而对于不是专门介绍框架实现的小册内容来说，瑕不掩瑜。

科目一
五部分：
- 教师职业理念
- 教育法律法规
- 教师职业道德规范
- 文化素养
- 基本能力
素质教育的内涵
- 提高国民素质为根本宗旨
- 面向全体学生的教育
- 促进学生全面发展
- 促进学生个性发展
- 培养创新精神和实践能力
新课改下的教学观
- 提倡教学从“以教育者为中心”转向“以学习者为中心”
- 提倡教学从“教会学生知识”转向“教会学生学习”
- 提倡教学从“重结果轻过程"转向“重结果更重过程"
- 提倡教学从”关注学科"到“关注人"
教师观
- 教师角色


  - 从教师与学生的关系 学生学习的引导者和发展的促进者
  - 教师 研究 教育教学的研究者
  - 教师与课程 课程的建设者和开发者
  - 学校 社区 社区型的开放教师
- 教师行为


  - 师生关系，尊重，赞赏
  - 教学，帮助，引导
  - 自我，反思
  - 其他教育者，合作
学生观
- 学生是发展的人
  - 身心发展是有规律的
  - 学生有巨大的发展潜能
  - 学生处于发展过程
- 学生是独特的人
  - 学生是完整的人
  - 有自身的独特性
  - 学生与成人之间有巨大的差异性
- 学生是独立意义的人
  - 学生是独立于教师头脑之外，不以教师意志为转移的客观存在
  - 学生是学习主体
  - 学生是责权主体
教师职业道德
  TODO：详细内容待完善
- 爱国守法 热爱祖国，热爱人民。拥护社会主义，拥护中国共产党。贯彻党的方针政策，依法行使教师权利。
- 爱岗敬业 乐于奉献，甘为人梯。认真备课上课，认真批改作业，认真辅导学生。不敷衍塞责。
- 关爱学生 关心爱护全体学生。关心学生身体健康，保护学生安全，维护学生人格。不惩罚、侮辱学生。
- 教书育人 遵循素质教育理念。循循教导，因材施教。
- 为人师表 衣着得体，言行得当。廉洁执教。尊重家长。
- 终身学习
教师的权利
- 教育教学权
- 学术研究权
- 指导评价权
- 报酬待遇权
- 民主管理权
- 进修培训权
学生的权利
- 受教育权
- 人身权
- 财产权
由细菌感染引起的常见疾病有肺结核、百日咳、白喉、破伤风、伤寒、霍乱、败血症、鼠疫等

气质的类型
- 胆汁质，精力旺盛，粗枝大叶，表里如一。易感情用事。
- 多血质，反映迅速，有朝气，活泼好动，动作敏捷，情绪不稳定
- 粘液质，稳重，踏实，死板，缺乏灵活性，缺乏生气
- 抑郁质，外表温柔，怯懦，孤独，行动缓慢
课程内容：课程计划、课程标准、教材
- 课程计划：根据教学目的和不同类型学校的教学任务，由国家教育主管部门制定的关于教学和教育工作的指导性文件。课程计划是课程设置的整体规划，对学校的教育教学，生产劳动，课外活动等做出全面安排 课程计划的构成： 培养目标 教学科目的设置 学科顺序 课时分配 学年编制与学周安排
- 课程标准：课程计划的具体化。
- 教材教育
教育的本质属性
教育是有目的地培养人的社会活动
教育的社会属性
- 永恒性
- 历史性
- 继承性
- 长期性
- 相对独立性
- 生产性
教育的发展
原始社会
古代社会
中国古代
  世界上最早的教育学专著《学记》。道而弗牵，强而弗抑，开而弗达。
  教育一词最早出现于《孟子·尽心上》
西方古代
  斯巴达：尚武
  古希腊：崇文
近代社会
现代社会
孔子：性相近，习相远。有教无类。学而优则仕。
不愤不启，不悱不发。启发式教育。启发诱导、因材施教、温故知新。
教育学的产生与发展
培根首提出
捷克 夸美纽斯，近代教育学之父，泛智教育，提出班级授课制《大教学论》
康德 大学里讲
德国 赫尔巴特 现代教育学之父 传统。《普通教育学》 
1原则 2基础 3中心 4阶段
1原则：教育性教学原则
2基础：伦理学和心理学
3中心：教师中心、教材中心、课堂中心
4段教学法：明了、联想、系统、方法
昆体良《雄辩术原理》（《论演说家的教育》），西方第一部教育专著
法国 卢梭 《爱弥儿》
美国 杜威，真现代，实用主义哲学创始人。新三中心。《民主主义与教育》教育即生活，教育即生长，教育即经验的改造
新三中心：儿童中心，经验中心，活动中心
| 人物       |     著作     |      思想      |
赞科夫
布卢姆
布鲁纳
瓦根舍因
苏霍姆林斯基
巴班斯基
姆有掌握目标，纳来发现结构，瓦根找范例，高度赞发展，巴班最优化，全面和谐好斯基。
个体身心发展的动因
-内发论
孟子：“仁义礼智，非由外铄我也，我固有之也”。“人之所不学而能者，其良能也。所不虑而知者，其良知也。”
弗洛伊德
威尔逊
格赛尔
霍尔
高尔顿
- 外铄论 荀子 洛克：白板 绅士 华生
教育的作用 
- 生产力与教育
- 生产力对教育的制约 生产力的发展水平决定教育事业的发展水平 生产力的发展水平决定人才培养的规模和结构 生产力的发展水平决定教学的内容、方法、形式、手段
- 教育的经济功能 劳动力再生产 科学知识再生产 技术创新
- 政治经济制度与教育
- 政治经济制度对教育的制约 政治经济制度决定教育的性质 政治经济制度决定教育的宗旨与目的 政治经济制度决定教育的领导权 政治经济制度决定受教育权 政治经济制度决定教育内容与教育管理体制
- 教育的政治作用 培养政治经济制度所需要的人才 促进政治民主化 宣传统治阶级的思想意识，创造舆论来为政治服务 传播意识形态，完成年青一代的政治社会化
- 文化与教育
- 文化对教育的影响 文化对教育有价值定向作用 影响教育的目的的确立 影响教学方法的使用 影响教育的内容与水平 影响教育环境和教育模式
- 教育对文化的作用 传递、保存 传播、交流 选择、提升 更新、创造
- 人口与教育 ？？？TODO
我国主要的学制
- 壬寅学制，首次制定，未实施
- 癸卯学制，以日本为蓝本
- 壬子癸丑学制，男女同校，第一个资本教育性质的学制
- 壬戌学制，以美国为蓝本
- 身心发展 顺序性、阶段性、不平衡性、互补性、个体差异性
- 影响身心发展的因素 影响人身心发展的因素
- 遗传 遗传的概念：从上一代继承下来的生理解剖上的特点，包括结构、形态、感官、神经等 遗传在人的发展中的作用：人身心发展的必要物质前提，为身心发展提供可能性
- 环境 概念：个体生活中影响个体身心发展的一切外部因素，包括社会环境和自然环境 环境在人的发展中的作用：使遗传提供的发展可能性变为现实。
- 学校 学校在人的发展中起主导作用 有计划、有目的、有组织 由受过专业训练的教师进行 控制影响发展的各种因素 ？？？TODO
- 个体的主观能动性 概念：个体的主观能动性是指人的主观意识对客观世界的反映和能动作用。 作用：主观能动性是推动人身心发展的内在动力；实践活动是决定性因素
教育目的的相关理论
社会本位论
个体本位论
教育目的的层次：教育目的、培养目标、课程目标、教学目标
教育目的的功能：导向、调控、激励、评价
教育目的的确立依据是特定社会的政治、经济、文化发展要求和个体的身心发展需求
我国制定教育目的的理论基础是马克思关于人的全面发展理论。教育和生产劳动相结合是培养全面发展的人的唯一途径。
全面发展教育
- 德育，在全面发展教育中起灵魂和统帅的作用
- 智育，前提和支持作用
- 体育，基础作用
- 美育，动力作用
- 劳动技术教育，综合作用
课程类型
按内容属性分：学科课程、活动课程
按组织方式分：分科课程、综合课程
按设计开发主体分：国家课程、地方课程、校本课程
按课程呈现方式分：显性课程、隐性课程
课程内容
- 课程计划
- 课程标准
- 教材
新课程改革的课程结构
整体设置九年一贯的义务教育课程
- 小学阶段以综合课程为主，初中阶段设置以分科和综合相结合的课程
- 高中以分科课程为主
- 从小学至高中设置综合实践课程并作为必修课程

教学评价的分类
按实施功能分为：
- 诊断性评价：学期教学开始或单元教学开始时所进行的评价
- 形成性评价：在教学进程中进行的经常性评价
- 总结性评价：在一个大的学习阶段结束后进行的全面评价
按运用标准分为：
- 相对性评价
- 绝对性评价
- 个体内差异评价
斯金纳的操作性条件作用理论
强化
  正强化：表扬、奖励
  负强化：撤销处分
惩罚：体罚、谴责
消退：不予理睬
情绪的分类
- 心境
- 激情
- 应激
埃里克森的社会化发展理论
？？？TODO
中学生常见心理障碍
- 抑郁：持续性的心境低落
- 恐惧：非理性惧怕
- 强迫：重复
- 焦虑：紧张不安
常用的心理辅导方法
？？？TODO
品德发展阶段理论
*皮亚杰道德发展阶段理论
- 自我中心阶段（2-5岁）
- 权威阶段（5-8岁）
- 可逆性阶段（8-10岁）
- 公正阶段（10-12岁）
*科尔伯格道德发展阶段理论
三水平                六阶段
前习俗（9岁以下）       惩罚与服从
                      相对功利
习俗（9-16）           寻求认可
                      遵守法规
后习俗（16岁之后）      社会契约
                      普遍原则
德育过程的基本规律
- 德育是促进学生知、情、意、行互动发展的过程
- 德育过程是组织学生的活动和交往，统一多方面教育影响的过程
- 德育过程促使学生思想内部矛盾积极转化的过程
- 德育过程是一个长期的，反复的，不断前进的过程
德育的原则
- 导向性原则
- 疏导性原则
- 尊重学生与严格要求学生相结合原则（严慈相济原则）
- 知行统一原则
- 正面教育与纪律约束相结合的原则
- 发挥积极因素，克服消极因素原则
- 教育的一致性与连贯性原则
- 因材施教原则
- 集体教育与个别教育相结合的原则
德育的方法
- 说服法
- 榜样法
- 陶冶法
- 锻炼法
- 自我修养发
- 品德评价法
- 教师的职业素养 思想道德素养 知识素养 能力素养 心理素养 身体素养
- 创造性思维的培养 创设有利于创造性产生的适宜环境 创设宽松的心理环境 给学生留有选择的余地 改革考试制度与考试内容 注重创造性个性的塑造 保护好奇心 解除个体对答错问题的恐惧心理 开设培养创造性的课程，教授创造性思维策略 发散思维训练 头脑风暴驯良
- 班级授课制的优缺点 优点： 经济有效、大面积地培养人才 发挥教师的主导作用 发挥班集体的教学作用 缺点： 不利于因材施教 不利于培养学生自主性和独立性 教学缺乏灵活性
马斯洛需要层次论
分为五个层次，由低到高依次为：生理需要、安全需要、归属和爱需要、尊重需要、自我实现需要。
马斯洛的需要层次理论认为，只有低层次的需要基本满足后，才会出现高一级的需要。
考试焦虑形成的原因：
- 家长或老师的期望值过高
- 学生自身的期望值过高
- 有过失败的考试经历
- 有容易引发焦虑的品质
操作技能的训练要求：
- 准确的示范与讲解
- 必要而适当的练习
- 充分而有效的反馈
- 建立稳定清晰的动觉
教师的成长和发展的基本途径主要有两种：
一、通过师范教育培养新教师
二、通过实践训练提高在职教师
观摩和分析优秀教师的教学活动
开展微格教学
专门的教学能力训练
反思性教学
班主任工作的意义和作用
- 班主任是班集体的组织者和教育者
- 班主任是学生全面发展的指导者
- 班主任是联系班级中各任课教师的纽带
- 班主任是沟通学校与家庭、社会的桥梁
- 班主任是学校领导实施教育教学工作计划的得力助手和骨干力量
德育过程的内涵
德育过程即思想品德教育过程，是教育者将社会的道德规范转化为受教育者个体思想品德的过程。德育过程是教育者与受教育者共同参与，双向互动的教育活动过程。
德育过程与品德形成过程的区别
- 区别：德育过程是一种教育过程，是教育者与受教育者双方统一活动的过程，是培养和发展受教育者品德的过程。品德形成过程是受教育者的思想道德结构不断建构完善的过程，品德形成 过程属于人的发展过程，
- 联系：德育过程与思想品德形成过程是教育与发展的关系。

品德的心理结构
- 道德认识
- 道德情感
- 道德意志
- 道德行为

气质类型与教育
克服气质偏见，根据学生的气质因材施教。
- 胆汁质：以柔克刚。在发展其热情、豪放、爽朗、勇敢和主动的个性同时，也要避免产生粗暴、任性、高傲等特性。
- 多血质：刚柔并济。严格其组织纪律的同时，要对他们热情。
- 黏液质：着重发展其诚恳待人，踏实顽强等品质。多给予其参与活动的机会。
- 抑郁质：着重发展其敏感、机智、认真细致、有自尊心和有信心等品质，要给予关怀，帮助，避免在公共场合指责。
注意的品质
- 注意的稳定性，注意保持在某一对象或某一活动上的时间长短
- 注意的广度，同一时间内意识能把握到的对象的数量
- 注意的转移，有意识的把注意从一种对象转移到另一种对象
- 注意的分配，在同一时间内把注意分配到两种或两种以上的不同的对象上
第三章 中学教学 
我国现阶段的教学任务
- 使学生掌握系统的现代科学基础知识和基本技能。这是我国教学的首要任务
- 发展学生智能，特别是培养学生的能力和创造力
- 发展学生体力，促进学生的身体健康
- 培养学生科学的世界观、良好的思想品德、健康的审美情趣和良好的心理素质
教学过程的特殊性：
- 间接性
- 引导性
- 简捷性
- 教育性
教学过程的基本规律
- 直接经验和间接经验相统一的规律（间接性规律）
- 掌握知识和发展能力相统一的规律（发展性规律）
- 教师主导与学生主体相统一的规律（双边性规律）
- 传授知识与思想教育相统一的规律（教育性规律）
教学原则
- 直观性原则
- 启发性原则
- 循序渐进原则（系统性原则）
- 巩固性原则
- 量力性原则
- 思想性（教育性）与科学性相统一原则
- 理论联系实际原则
- 因材施教原则
贯彻启发性原则的要求
- 加强学习的目的性教育，调动学生学习的主动性
- 启发学生独立思考，发展学生的逻辑思维能力
- 让学生自己动手，培养学生独立解决问题的能力
- 发扬教学民主
中小学常用的教学方法
- 语言传递：讲授法、谈话法、讨论法、读书指导法
- 直观感知：演示法、参观法
- 实际训练：练习法、实验法、实习作业法、实践活动法
- 情感陶冶：欣赏教学法、情境教学法
第四章
认知的过程：感觉、知觉、注意、记忆、思维、想象
知觉分类：物体知觉、社会知觉、错觉
社会知觉包含：
- 首因效应
- 近因效应
- 刻板效应
- 晕轮效应
- 投射效应
注意的分类
- 无意注意（不随意注意）
- 有意注意（随意注意）
- 有意后注意（随意后注意）
培养学生注意力的方法：？？？
记忆的分类
- 瞬时记忆
- 短期记忆
- 长期记忆
遗忘的规律：艾宾浩斯遗忘曲线
- 影响遗忘的因素
- 时间因素的制约
- 识记材料的重要性，或者识记者的态度
- 识记材料的性质与数量
- 识记材料的学习程度
- 识记材料的系列位置
- 识记方法
遗忘的原因理论学说
- 消退说
- 干扰说：前摄抑制、后摄抑制
- 压抑说
- 提取失败说
- 同化说
- 防止遗忘的方法（有效组织复习的方法）
- 及时复习
- 合理分配复习时间
- 分散复习与集中复习相结合
- 复习方法多样化
- 运用多种感官参与复习
- 尝试回忆与反复识记相结合
- 掌握复习的量
思维
想象的分类：
- 无意想象
- 有意想象 再造想象 创造想象 幻想 培养学生创造力的方法：？？？
第二节：学习概述
学习的内涵
学习是个体在特定情境下
学习的分类 
加涅的学习层次分类
加涅的学习结果分类
奥苏贝尔的学习分类
布鲁姆的学习分类
冯忠良的学习分类
影响学习的因素
第三节：学习理论
- 行为主义学习理论
  - 巴甫洛夫：经典型条件作用理论
  - 桑代克：尝试-错误说 基本规律：准备律、练习律、效果律
  - 斯金纳：正强化、负强化、惩罚、消退
  - 班杜拉：观察（社会）学习理论
- 认知注意学习理论
  - 苛勒
  - 托尔曼
  - 布鲁纳：认知发现
  - 奥苏贝尔：有意义的学习
  - 加涅
- 建构主义学习理论
- 人本主义学习理论 人本主义观点，罗杰斯
学习动机 
学习动机的分类
按动机产生的诱因分为：内部学习动机和外部学习动机
按学习内容的意义分为：高尚的学习动机和低级的学习动机
按目标的远近分为：近景性动机和远景性动机
按学习动机与学习活动的关系：直接动机和间接动机
奥苏贝尔成就动机分类：认知内驱力、附属内驱力、自我提高内驱力
学习动机理论
- 强化理论
- 需要层次理论，马斯洛
- 成就动机理论，阿特金森
- 成败归因理论，韦纳
- 自我效能理论，班杜拉
- 成就目标理论
学习动机的培养
学习动机的激发
第四节：学习迁移
概念：学习迁移是指一种学习对另一种学习的影响
学习迁移的分类
- 正迁移
- 负迁移
- 顺向迁移
- 逆向迁移
- 一般迁移
- 具体迁移
- 水平迁移
- 垂直迁移
学习迁移的理论
- 形式训练说
- 相同要素说
- 概括化理论
- 关系转换说
- 认知结构迁移论
影响学习迁移的因素
第五节：学习策略
学习策略的分类：
- 认知策略
- 元认知策略
- 资源管理策略
第六节：知识的学习与技能的形成
第五章：中学生发展心理
第一节：中学生的认知发展
一、皮亚杰认知发展阶段
皮亚杰的认知发展阶段理论
- 感知运动阶段（0-2岁）：客体永恒性
- 前运算阶段（2-7岁）：万物有灵论、自我为中心、不可逆、不守恒
- 具体运算阶段（7-11岁）：简单抽象思维，守恒、去中心、可逆
- 形式运算阶段（11-16岁）：推理、逻辑思维
发展的结构：
- 图式
- 同化
- 顺应
- 平衡
二、维果斯基心理发展观
文化历史理论：心理发展观的核心理论是文化历史理论。
  低级心理机能：人和动物都有，以本能行为为主
  高级心理机能：只有人才有，以后天的语言符号为中介
心理发展观：孩子一步步从低级心理机能发展到高级心理机能，这个过程称为心理发展观
内化学说：语言符号需要从外界学习，如何把外界的语言符号转化为自己的能力，这个过程为内化学说。
教学与发展的关系
  最近发展区
  教学走在发展的前面
三、个别差异与因材施教
认知风格：
- 场独立与场依存 场独立：思考问题时以内在参照为主，自己做决定，不太参照外界观点 场依存：做决定时一直参照别人的观点，没主见
- 沉思型与冲动型 沉思型：重准确，答问题一定要正确 冲动型：重速度，答问题一定要快
- 辐合型与发散型 辐合型：问题指向唯一答案 发散型：一题多解
- 整体型与系列型 整体性：从多个角度思考问题 系列型：只能从一个角度思考问题
第二节：中学生情绪与意志发展
一、情绪
情绪的概念：个体在其需要是否得到满足的情景中直接产生的心理体验和相应反应。
情绪的特点：主观性、社会性、两极性
情绪的分类
情绪理论
詹姆斯-兰格理论：情绪是由生理反应产生的
坎农-巴德学说：刺激发生时，情绪和生理反应同时产生
阿诺德评定-兴奋说：人之所以产生情绪，是因为对刺激进行了评价，评价不同产生不同的情绪
沙赫特-辛格情绪理论：当外界刺激发生时，生理反应、认知性唤醒和对环境的评估是同时出现的，然后产生情绪
中学生情绪的发展与培养
中学生情绪的特点
- 体验迅速、强烈
- 不稳定性与两极性
- 内隐性与外露性
- 时间延长，出现心境化
情绪调节的方法
敏锐的观察情绪
大方的接纳情绪
正确的调整情绪
有效的表达情绪
保持和创造快乐情绪
二、情感
情感的概念：个体在意识到自己与客观事物的关系后而产生的稳定的、深刻的心理体验
情感的分类
- 道德感：对于人的言行是否符合一定的道德标准而产生的情感体验
- 理智感：人的智力活动中产生的情感体验
- 美感：根据审美标准来评价自然现象，社会现象和文艺作品时产生的
三、情绪与情感的关系
？？？TODO
四、意志
定义：意志是有意识地确立目的，调节和支配行动，并通过克服困难和挫折，达到预定目的的心理过程。
意志的基本阶段：
采取决定阶段
执行决定阶段
双趋冲突
双避冲突
趋避冲突
多重趋避
第六章：中学生心理辅导
第一节：中学生的心理健康
中学生的障碍性问题
- 抑郁症
- 恐怖症
- 焦虑症
- 强迫症
- 网络成瘾
- 入学适应不良
第二节：中学生心理辅导的方法
心理辅导的目标：学会调适、寻求发展
心理辅导的原则：
- 面向全体学生原则
- 预防与发展相结合原则
- 尊重与理解学生原则
- 学生主体性原则
- 个别化对待原则
- 整体性发展原则
心理辅导的主要方法：
- 强化法
- 代币奖励法
- 惩罚法
- 消退法
- 系统脱敏法
- 来访者中心疗法
- 合理情绪疗法
第七章：中学德育
第八章：中学班级管理与教师心理
群体的心理功能：
- 归属功能
- 认同功能
- 支持功能
- 塑造功能
教师劳动的特点
复杂性和创造性
复杂性：目的全面性、任务多样，对象的差异性
创造性：因材施教、不断创新、教育机智
连续性和广延性
连续性：时间连续。不断了解学生的过去与现状，预测发展与未来。得到反馈，准备新一轮教学。
广延性：空间广延。课堂内外，学校内外都是教师的劳动场所。
长期性和间接性
长期性：人才培养时间周期长，教育影响迟延
间接性：不直接创造劳动财富，以学生为中介实现教师劳动价值
主体性和示范性
主体性：教师自身能成为教育因素和有影响力的榜样
示范性：教师的言行举止会成为学生学习的对象
劳动方式的个体性和劳动成果的群体性
个体性：教育教学活动是通过一个个教室的个体劳动完成的
群体性：教师的劳动成果又是集体劳动的成果。
教学工作的基本环节
备课
上课
作业检查与批改
课外辅导
学业成绩的评定
一堂好课的标准
- 目标明确
- 重点突出
- 内容正确
- 方法得当
- 表达清晰
- 组织严密
- 课堂气氛热烈
班主任的工作
- 了解和研究学生
- 组织和培养班集体
- 建立学生档案
- 组织班会活动和课外活动
- 操作评定
- 协调各种教育影响
- 班主任的工作计划和总结
- 个别教育工作
教师阶段
福勒和布朗
关注生存阶段
关注情境阶段
关注学生阶段
叶澜
非关注
虚拟关注
关注生存
关注情境
自我更新Excel常用函数
- 求和SUM
- 平均值AVERAGE
- 计数COUNT
- 最大值MAX
- 最小值MIN
- 绝对值ABS
PowerPoint视图
- 普通视图
- 幻灯片浏览视图
- 幻灯片放映视图
- 备注页视图
多媒体技术计算公式
- 图像大小计算
- 音频大小计算
- 视频大小计算
图像文件格式
- png
- jpg/jpeg
- bmp
- gif
- psd
- wmf
- tif
Flash动画类型
- 逐帧动画
- 运动补间动画
- 形状补间动画
- 路径动画
- 遮罩动画
计算机网络OSI模型
- 物理层
- 数据链路层
- 网络层
- 传输层
- 会话层
- 表示层
- 应用层
信息安全防范的基本方法
- 物理防范
  - 环境维护
  - 防盗
  - 防火
  - 防静电
  - 防雷击
  - 防电磁泄露
- 逻辑防范
  - 访问控制
  - 信息加密
IP地址的组成和分类
IP地址由两部分组成：网络标识和主机标识。分为A、B、C三种基本类型，每类有不同长度的网络标识和主机标识，D类用于组播，E类用于试验和保留。
IP地址	网络字节数	主机号字节数	第一个字节十进制范围
A类	1	3	1126
B类	2	2	128191
C类	3	1	192 〜223
计算机病毒的含义、特点和传播途径：
含义：计算机病毒是编制者在计算机程序中插入的能够破坏计算机功能或数据，影响计算机使用，能够自我复制的一组计算机指令或程序代码。
特点：寄生性、传染性、潜伏性、隐蔽性、可触发性、破坏性、不可预见性等特点
传播途径：常见的移动设备包括U盘和移动硬盘。网络是计算机病毒传播的首选途径。
搜索引擎的分类：全文搜索引擎和目录搜索引擎
循环冗余码
数据模型
- 层次模型
- 网状模型
- 关系模型
信息技术教育教学知识
第一章：课程理论知识
高中信息技术课的基本理念包含哪几方面？
- 坚持立德树人的课程价值观，培养具有信息素养的中国公民
- 设置满足学生多元需求的课程结构，促进学生的个性发展
- 选择体现时代性和基础性的课程内容，支撑学生信息素养的发展
- 培养以学习为中心的教与学关系，在问题解决过程中提升信息素养
- 构建基于学科核心素养的评价体系，推动数字化时代的学习创新
高中信息技术学科核心素养：
- 信息意识
- 计算思维
- 数字化学习与创新
- 信息社会责任
信息技术4个学科大概念：数据、算法、信息系统和信息社会。
教学环节：导入新课、新课讲授、巩固提高和小结作业。
第二章：教学实施
第一节：导入新课类
导入原则：
- 针对性原则
- 趣味性原则
- 简洁性原则
- 启发性原则
导入方法：
- 开门见山
- 温故知新
- 生活情境
- 作品情境
- 活动情境
第二节：教学方法类
方法类型：
- 讲授法
- 自主学习法
- 合作探究法（讨论法）
- 演示操作法
- 提问启发发
- 任务驱动法
- 项目学习法
任务驱动法的教学过程：创建情境 -> 提出任务 -> 分析任务 -> 完成任务 -> 总结评价
项目学习法的教学过程：选定项目 -> 规划设计 -> 探究活动 -> 项目实施 -> 成果交流 -> 活动评价
选择依据：
- 依据教学目标
- 依据教学内容特点
- 依据学生实际特点
- 依据教师的自身素质
- 依据教学环境条件
第三节：教法实施原则类
任务驱动法的开展
- 任务的设计：任务的设计要有趣味性、任务的设计要有梯度性
- 任务的完成
- 任务的反馈
提问启发法的开展
- 问题的设计：问题指向明确、问题逻辑清晰
- 回答的反馈
合作探究法的开展
- 合理分组
- 师生互动
- 结果反馈
讲演法的开展
- 讲演时机
- 讲演互动
- 讲演反馈
第四节：设计意图类
发挥主体地位
切入点：项目、任务、活动；合作、探究
激发学习动机
切入点：游戏、竞赛、有意义的情境/素材/活动
指明学习方向
切入点：素材支持、任务分解、提醒话语
面向全体学生
切入点：分层、难度不一的任务、异质分组
加深知识掌握
切入点：回顾旧识、课堂练习、课堂小结、课后作业
第三章：教学设计
完整的教案：
一、教学目标
1.
2.
3.
二、教学重难点
1.教学重点
2.教学难点
三、教学过程
1.导入新课
2.新课讲授
3.巩固提高
4.小结作业
四、板书设计
第一节：教学目标
三维教学目标是指三个教学维度，分别是知识与技能目标、过程与方法目标、情感态度与价值观目标。
知识与技能目标
学生能够准确说出/区分/总结/制作_____（知识/作品）
过程与方法目标
通过_____（学法），发展/掌握/提升_____能力
情感态度与价值观目标
通过_____，体会/感受_____（便捷性），激发_____（兴趣）
第二节：教学重难点
第三节：教学过程