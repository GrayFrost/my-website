---
title: Rust学习-4
date: '2024-11-25'
tags: ['rust']
draft: false
---

泛型

## 泛型是什么
泛型允许我们不完全定义一个 struct 或 enum，使编译器能够根据我们的代码使用情况，在编译时创建一个完全定义的版本。

Rust 通常可以通过查看我们的实例化来推断出最终的类型，但是如果需要帮助，你可以使用 `::<T>` 操作符来显式地进行操作， 该操作符也被称为 turbofish

```rust
// 一个部分定义的结构体类型
struct BagOfHolding<T> {
    item: T,
}

fn main() {
    // 注意：通过使用泛型，我们创建了编译时创建的类型，使代码更大
    // Turbofish 使之显式化
    let i32_bag = BagOfHolding::<i32> { item: 42 };
    let bool_bag = BagOfHolding::<bool> { item: true };
    
    // Rust 也可以推断出泛型的类型！
    let float_bag = BagOfHolding { item: 3.14 };

    // 注意：在现实生活中，不要把一袋东西放在另一袋东西里:)
    let bag_in_bag = BagOfHolding {
        item: BagOfHolding { item: "嘭！" },
    };

    println!(
        "{} {} {} {}",
        i32_bag.item, bool_bag.item, float_bag.item, bag_in_bag.item.item
    );
}

```

## 表示空
Rust没有null，使用None来表示空
```rust
enum Item {
    Inventory(String),
    // None represents the absence of an item
    None,
}

struct BagOfHolding {
    item: Item,
}
```

## Option
Rust 有一个内置的泛型枚举叫做 Option，它可以让我们不使用 null 就可以表示可以为空的值。
```rust
enum Option<T> {
    None,
    Some(T),
}
```

```rust
// 一个部分定义的结构体
struct BagOfHolding<T> {
    // 我们的参数类型T可以传递给其他
    item: Option<T>,
}

fn main() {
    // 注意：一个放 i32 的 bag，里面什么都没有！
    // 我们必须注明类型，否则 Rust 不知道 bag 的类型
    let i32_bag = BagOfHolding::<i32> { item: None };

    if i32_bag.item.is_none() {
        println!("there's nothing in the bag!")
    } else {
        println!("there's something in the bag!")
    }

    let i32_bag = BagOfHolding::<i32> { item: Some(42) };

    if i32_bag.item.is_some() {
        println!("there's something in the bag!")
    } else {
        println!("there's nothing in the bag!")
    }

    // match 可以让我们优雅地解构 Option，并且确保我们处理了所有的可能情况！
    match i32_bag.item {
        Some(v) => println!("found {} in bag!", v),
        None => println!("found nothing"),
    }
}

```

## Resut
Rust 有一个内置的泛型枚举叫做 Result，它可以让我们返回一个可能包含错误的值

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

```rust
fn do_something_that_might_fail(i:i32) -> Result<f32,String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("this is not the right number"))   
    }
}

fn main() {
    let result = do_something_that_might_fail(12);

    // match 让我优雅地解构 Rust，并且确保我们处理了所有情况！
    match result {
        Ok(v) => println!("found {}", v),
        Err(e) => println!("Error: {}",e),
    }
}
```

## 可失败的主函数
main 函数有可以返回 Result 的能力

```rust
fn do_something_that_might_fail(i: i32) -> Result<f32, String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("this is not the right number"))
    }
}

// 主函数不返回值，但可能返回一个错误！
fn main() -> Result<(), String> {
    let result = do_something_that_might_fail(12);

    match result {
        Ok(v) => println!("found {}", v),
        Err(_e) => {
            // 优雅地处理错误
            
            // 返回一个说明发生了什么的新错误！
            return Err(String::from("something went wrong in main!"));
        }
    }

    // Notice we use a unit value inside a Result Ok
    // to represent everything is fine
    Ok(())
}

```

## 优雅地错误处理
Result 如此常见以至于 Rust 有个强大的操作符 ? 来与之配合。 以下两个表达式是等价的：

```rust
do_something_that_might_fail()?
```

```rust
match do_something_that_might_fail() {
    Ok(v) => v,
    Err(e) => return Err(e),
}
```

```rust
fn do_something_that_might_fail(i: i32) -> Result<f32, String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("this is not the right number"))
    }
}

fn main() -> Result<(), String> {
    // 看看我们节省了多少代码！
    let v = do_something_that_might_fail(42)?;
    println!("found {}", v);
    Ok(())
}

```

## 丑陋的Option/Result处理
当你只是试图快速地写一些代码时，Option/Result 对付起来可能比较无聊。 Option 和 Result 都有一个名为 unwrap 的函数：这个函数可以简单粗暴地获取其中的值。 unwrap 会：

获取 Option/Result 内部的值
如果枚举的类型是 None/Err， 则会 panic!
这两段代码是等价的：

```rust
my_option.unwrap()
```

```rust
match my_option {
    Some(v) => v,
    None => panic!("some error message generated by Rust!"),
}
```
类似的：
```rust
my_result.unwrap()
```
```rust
match my_result {
    Ok(v) => v,
    Err(e) => panic!("some error message generated by Rust!"),
}
```

```rust
fn do_something_that_might_fail(i: i32) -> Result<f32, String> {
    if i == 42 {
        Ok(13.0)
    } else {
        Err(String::from("this is not the right number"))
    }
}

fn main() -> Result<(), String> {
    // 简洁但假设性强，而且很快就会变得丑陋
    let v = do_something_that_might_fail(42).unwrap();
    println!("found {}", v);
    
    // 这会 panic!
    let v = do_something_that_might_fail(1).unwrap();
    println!("found {}", v);
    
    Ok(())
}
```

`Result<T, E>`: 当你有一个 Result 类型的变量，并且你知道或者期望它一定是 Ok 值（即不包含错误）时，可以使用 `.unwrap()`方法。它会提取并返回 Ok 包含的值。但如果该 Result 是 Err 值（包含错误），`.unwrap()` 会触发一个运行时`panic`，并停止程序执行，同时打印出错误信息。

`Option<T>`: 当你有一个 Option 类型的变量，并且你知道或者期望它一定是 Some 值（即包含值）时，可以使用 `.unwrap()` 方法。它会提取并返回 Some 包含的值。但如果该 Option 是 None 值（不包含值），`.unwrap()` 也会触发一个运行时`panic`。

## Vectors
一些经常使用的泛型是集合类型。一个 vector 是可变长度的元素集合，以 Vec 结构表示。

比起手动构建，宏 vec! 让我们可以轻松地创建 vector。

Vec 有一个形如 iter() 的方法可以为一个 vector 创建迭代器，这允许我们可以轻松地将 vector 用到 for 循环中去。

内存细节：

Vec 是一个结构体，但是内部其实保存了在堆上固定长度数据的引用。
一个 vector 开始有默认大小容量，当更多的元素被添加进来后，它会重新在堆上分配一个新的并具有更大容量的定长列表

```rust
fn main() {
    // 我们可以显式确定类型
    let mut i32_vec = Vec::<i32>::new(); // turbofish <3
    i32_vec.push(1);
    i32_vec.push(2);
    i32_vec.push(3);

    // 但是看看 Rust 是多么聪明的自动检测类型啊
    let mut float_vec = Vec::new();
    float_vec.push(1.3);
    float_vec.push(2.3);
    float_vec.push(3.4);

    // 这是个漂亮的宏！
    let string_vec = vec![String::from("Hello"), String::from("World")];

    for word in string_vec.iter() {
        println!("{}", word);
    }
}
```